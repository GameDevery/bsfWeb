<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-120676613-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-120676613-1');
</script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - Advanced materials</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='https://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Advanced materials </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#advMaterials_a">Material parameters</a></li>
<li class="level1"><a href="#advMaterials_b">Creating a shader manually</a><ul><li class="level2"><a href="#advMaterials_b_a">Creating a pass</a></li>
<li class="level2"><a href="#advMaterials_b_b">Creating a technique</a></li>
<li class="level2"><a href="#materials_b_c">Creating a shader</a></li>
<li class="level2"><a href="#materials_b_d">Shader parameters</a><ul><li class="level3"><a href="#materials_b_d_a">Advanced parameters</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#materials_c">Manually rendering using the material</a><ul><li class="level2"><a href="#materials_c_a">Binding material</a></li>
<li class="level2"><a href="#materials_c_b">Binding material parameters</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>We have already talked about how to create materials, assign them parameters and bind them to a <b>Renderable</b> component. In this section we'll show an advanced way to assign material parameters, how to use materials for rendering directly (without using <b>Renderable</b> component) and how to create your own shaders without the use of BSL.</p>
<h1><a class="anchor" id="advMaterials_a"></a>
Material parameters</h1>
<p>Previously we have shown to how to set <b>Material</b> parameters by calling methods like <a class="el" href="classbs_1_1_t_material.html#a9ad49a50506ffb45b02343bc021047fe">Material::setTexture()</a>, <a class="el" href="classbs_1_1_t_material.html#ac0dfa1b5ca5cca9a5feda6657c531b6d">Material::setFloat()</a>, <a class="el" href="classbs_1_1_t_material.html#ae9917c5f5467303d2f733f84ebc5c1fd">Material::setColor()</a>, <a class="el" href="classbs_1_1_t_material.html#a2bb6607097658e67d9901d7213ca6005">Material::setVec4()</a> and similar.</p>
<p>As an alternative you can also set materials through material parameter handles. Once a material handle is retrieved it allows you to set material parameters much more efficiently than by calling the methods above directly.</p>
<p>To retrieve the handles call any of the following methods, depending on material parameter type:</p><ul>
<li><a class="el" href="classbs_1_1_t_material.html#ab9d3afb28f8ad78989d5d1e61edf2e39">ct::Material::getParamTexture()</a> - Outputs a <a class="el" href="classbs_1_1_t_material_param_texture.html">MaterialParamTexture</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_material.html#a56b2ef758f5e47c5e5764ed98cecff51">ct::Material::getParamLoadStoreTexture()</a> - Outputs a <a class="el" href="classbs_1_1_t_material_param_load_store_texture.html">MaterialParamLoadStoreTexture</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_material.html#add7658fc7eb0cfdb539576dbad377ae6">ct::Material::getParamBuffer()</a> - Outputs a <a class="el" href="classbs_1_1_t_material_param_buffer.html">MaterialParamBuffer</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_material.html#ab62bc414f0449dc155a2e283d81c5557">ct::Material::getParamSamplerState()</a> - Outputs a <a class="el" href="classbs_1_1_t_material_param_samp_state.html">MaterialParamSampState</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_material.html#aa07301733897452363b796650b0ee1ba">ct::Material::getParamFloat()</a> - Outputs a <a class="el" href="classbs_1_1_t_material_data_param.html">MaterialParamFloat</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_material.html#a9aa8d3d1c146d7f59afd22421d7a64bd">ct::Material::getParamVec2()</a> - Outputs a <a class="el" href="classbs_1_1_t_material_data_param.html">MaterialParamVec2</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_material.html#ad878c42848d7a8d5a9af5af6a0f000f8">ct::Material::getParamVec3()</a> - Outputs a <a class="el" href="classbs_1_1_t_material_data_param.html">MaterialParamVec3</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_material.html#a9631dc6043a3a1163e27699c3d95fa21">ct::Material::getParamVec4()</a> - Outputs a <a class="el" href="classbs_1_1_t_material_data_param.html">MaterialParamVec4</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_material.html#a0398a52c8a90275184c27c72c064c1e9">ct::Material::getParamColor()</a> - Outputs a <a class="el" href="classbs_1_1_t_material_data_param.html">MaterialParamColor</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_material.html#ada5bd50fb5fe8936d9b2869470a4c7f4">ct::Material::getParamMat3()</a> - Outputs a <a class="el" href="classbs_1_1_t_material_data_param.html">MaterialParamMat3</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_material.html#ae3adab4d75479c99cf7bf633c254983a">ct::Material::getParamMat4()</a> - Outputs a <a class="el" href="classbs_1_1_t_material_data_param.html">MaterialParamMat4</a> handle that can be used for reading &amp; writing the parameter value.</li>
</ul>
<p>Handles provide <b>set()</b> and <b>get()</b> methods that can be used for writing and reading the parameter values.</p>
<div class="fragment"><div class="line">HMaterial material = ...;</div><div class="line"></div><div class="line">MaterialParamMat4 myMatParam;</div><div class="line">MaterialParamTexture myTextureParam;</div><div class="line"></div><div class="line">material-&gt;getParamMat4(<span class="stringliteral">&quot;vertProjMatrix&quot;</span>, myMatParam);</div><div class="line">material-&gt;getParamTexture(<span class="stringliteral">&quot;mainTexture&quot;</span>, myTextureParam);</div><div class="line"></div><div class="line">Matrix4 viewProjMat = ...;</div><div class="line">SPtr&lt;Texture&gt; someTexture = ...;</div><div class="line"></div><div class="line">myVectorParam.set(viewProjMat);</div><div class="line">myTextureParam.set(someTexture);</div></div><!-- fragment --><p>Material handles are very similar as <b>GpuParams</b> handles we talked about earlier. There are two major differences:</p><ul>
<li><b>GpuParams</b> handles will only set the parameter value for a specific <b>GpuProgram</b>, while material handles will set the values for all <b>GpuProgram</b>s that map to that handle.</li>
<li><b>GpuProgram</b> parameters are retrieved directly from program source code, while <b>Material</b> parameters need to be explicitly defined in the <b>Shader</b> (shown below). <b>Material</b> parameters always map to one or multiple <b>GpuProgram</b> parameters.</li>
</ul>
<h1><a class="anchor" id="advMaterials_b"></a>
Creating a shader manually</h1>
<p>So far when we wanted to create a shader we would create a BSL file which would then be imported, creating a <a class="el" href="classbs_1_1_shader.html">Shader</a>. But you can also create shaders manually by explicitly providing HLSL/GLSL code for <b>GpuProgram</b>s and non-programmable states. Most of the things outlined in this section are performed by BSL compiler internally when a <b>Shader</b> is imported.</p>
<p>Each shader definition contains two things:</p><ul>
<li>A list of parameters, with a mapping of each parameter to one or multiple variables in a GPU program</li>
<li>One or multiple <a class="el" href="classbs_1_1_technique.html">Technique</a>s. Each technique is essentially a fully fledged shader of its own. Techniques are chosen by the renderer depending on the context. For example some techniques only support the DirectX backend, while others only the Vulkan backend. Different techniques will also exist for different shader variations (e.g. a high- and low-end version of the same shader).<ul>
<li>Each technique contains one or multiple <a class="el" href="classbs_1_1_pass.html">Pass</a>es. A pass is a set of GPU programs and non-programmable states. When rendering using a certain technique each pass will be executed one after another. This allows you to render objects that require more complex rendering that requires multiple separate steps - althrough in practice most techniques have only a single pass.</li>
</ul>
</li>
</ul>
<p>To summarize, the relationship between materials, shaders, techniques and passes is:</p><ul>
<li><b>Material</b> [contains one]-&gt; <b>Shader</b> [contains one or multiple]-&gt; <b>Technique</b> [contains one or multiple]-&gt; <b>Pass</b></li>
</ul>
<p>Optionally, the shader definition can also contain a set of <a class="el" href="structbs_1_1_sub_shader.html">SubShader</a>s. As explained previously sub-shaders are a set of techniques that are used to override specific renderer behaviour.</p>
<h2><a class="anchor" id="advMaterials_b_a"></a>
Creating a pass</h2>
<p>A <b>Pass</b> can be created by filling out a <a class="el" href="structbs_1_1_p_a_s_s___d_e_s_c.html">PASS_DESC</a> descriptor and passing it to <a class="el" href="classbs_1_1_pass.html#abef887857bb39856272cdcc26c003ac3">Pass::create()</a> method. <b>PASS_DESC</b> is fairly simple and it expects a set of GPU program and non-programmable state descriptors.</p>
<div class="fragment"><div class="line">GPU_PROGRAM_DESC vertexProgDesc = ...;</div><div class="line">GPU_PROGRAM_DESC fragmentProgDesc = ...;</div><div class="line"></div><div class="line">BLEND_STATE_DESC blendStateDesc = ...;</div><div class="line"></div><div class="line"><span class="comment">// Create a pass with a vertex and fragment program, and a non-default blend state</span></div><div class="line">PASS_DESC desc;</div><div class="line">desc.vertexProgram = vertexProgDesc;</div><div class="line">desc.fragmentProg = fragmentProgDesc;</div><div class="line">desc.blendState = blendStateDesc;</div><div class="line"></div><div class="line">SPtr&lt;Pass&gt; pass = Pass::create(desc);</div></div><!-- fragment --><p>The descriptors for GPU programs and non-programmable states are filled out as described in the low-level rendering API manual.</p>
<h2><a class="anchor" id="advMaterials_b_b"></a>
Creating a technique</h2>
<p>Now that we know how to create a pass, we can use one or multiple passes to initialize a <b>Technique</b>. A technique is just a container for one or multiple passes.</p>
<p>To create a technique call <a class="el" href="classbs_1_1_technique.html#a3fc523059b2f7f90b96376f8e41f4557">Technique::create()</a> and provide it with:</p><ul>
<li>Shading language name - This should be "HLSL" or "GLSL". The engine will not use this technique unless this language is supported by the current render API.</li>
<li>Array containing one or multiple passes</li>
</ul>
<p>For example: </p><div class="fragment"><div class="line">SPtr&lt;Pass&gt; pass = ...;</div><div class="line"></div><div class="line"><span class="comment">// Create a technique that uses HLSL and has a single pass</span></div><div class="line">SPtr&lt;Technique&gt; technique = Technique::create(<span class="stringliteral">&quot;HLSL&quot;</span>, { pass });</div></div><!-- fragment --><h2><a class="anchor" id="materials_b_c"></a>
Creating a shader</h2>
<p>Now that we have a technique we can create the shader by calling <a class="el" href="classbs_1_1_shader.html#a83b962f984a5cda93a8ee3d3153e0a6e">Shader::create()</a>, which expects the name of the shader and a <a class="el" href="structbs_1_1_t_s_h_a_d_e_r___d_e_s_c.html">SHADER_DESC</a> structure as input.</p>
<p><a class="el" href="structbs_1_1_t_s_h_a_d_e_r___d_e_s_c.html">SHADER_DESC</a> contains a list of techniques to initialize the shader with, as well as a set of optional parameters to control how the shader rendering works:</p><ul>
<li><a class="el" href="structbs_1_1_t_s_h_a_d_e_r___d_e_s_c.html#a891c5ad5ded8a07cae2023829ee0557c">SHADER_DESC::queueSortType</a> - Controls how should objects rendered with this shader be sorted. Either front to back, back to front, or without sorting. This property can be used for the active renderer to properly render objects, as certain effects (like transparency) require their objects to be rendered in a specific order.</li>
<li><a class="el" href="structbs_1_1_t_s_h_a_d_e_r___d_e_s_c.html#ac75f0ac288b1c558d9cabff7c6ee2cb8">SHADER_DESC::queuePriority</a> - Controls at what point should objects rendered with this shader be rendered relative to other objects. Objects with higher priority will be rendered before ones with lower priority, and sorting due to <b>SHADER_DESC::queueSortType</b> will never sort outside of priority groups. This can allow you to render a certain type of objects before all others (e.g. all opaque objects should be rendered before transparent ones).</li>
<li><a class="el" href="structbs_1_1_t_s_h_a_d_e_r___d_e_s_c.html#af8c03d3856e2fdfcc03ff5e1fd3fb1a1">SHADER_DESC::separablePasses</a> - An optimization hint to the renderer that can improve performance when turned on. Only relevant if the shader has techniques with multiple passes. When true the renderer will not necessarily execute passes right after another, but might render other objects in-between passes. This can reduce state switching as multiple objects can be rendered with a single pass, but is only relevant for algorithms that can handle such a process (most can't).</li>
</ul>
<div class="fragment"><div class="line">SPtr&lt;Technique&gt; technique = ...;</div><div class="line"></div><div class="line">SHADER_DESC desc;</div><div class="line">desc.queueSortType = QueueSortType::None;</div><div class="line">desc.queuePriority = 0;</div><div class="line">desc.separablePasses = <span class="keyword">false</span>;</div><div class="line">desc.techniques = { technique };</div><div class="line"></div><div class="line">SPtr&lt;Shader&gt; shader = Shader::create(<span class="stringliteral">&quot;MyShader&quot;</span>, desc);</div></div><!-- fragment --><h2><a class="anchor" id="materials_b_d"></a>
Shader parameters</h2>
<p>Shader parameters allow you to change values of parameters in GPU programs through the <b>Material</b> interface. They are similar to GPU program parameters described earlier, but they set the values on all GPU programs on all passes in the active technique, instead of doing so only on a single GPU program. Additionally they also support renderer semantics (see below).</p>
<p>To create the parameter interface you must populate the <b>SHADER_DESC</b> structure by calling one of the <a class="el" href="structbs_1_1_t_s_h_a_d_e_r___d_e_s_c.html#a31e2ec961e7f672b7aaf38e084e34efe">SHADER_DESC::addParameter()</a> overloads.</p>
<p>Parameters come in two variants:</p><ul>
<li>Data - These are primitive types like float, int or bool. This includes their vector and array variants. Check <a class="el" href="group___utility-_core.html#ga8cd5dffb4633f43e5afe604420a118e4">GpuParamDataType</a> for a list of all data parameter types.</li>
<li>Object - These are object types like texture, buffer or sampler state. Check <a class="el" href="group___utility-_core.html#gadad4be1cd5f0eea1b67992f36f794b08">GpuParamObjectType</a> for a list of all object parameter types.</li>
</ul>
<p>For each parameter you must specify:</p><ul>
<li>Its name. This will be the name accessible through <b>Material</b>. It can be anything you like, as long as it is unique.</li>
<li>Name of the GPU variable it maps to. This must be a variable defined in source code of one or multiple GPU programs used in the shader (across all techniques/passes).</li>
<li>Type of the GPU variable, as described above.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Extended example from above</span></div><div class="line">SPtr&lt;Technique&gt; technique = ...;</div><div class="line"></div><div class="line">SHADER_DESC desc;</div><div class="line">desc.queueSortType = QueueSortType::None;</div><div class="line">desc.queuePriority = 0;</div><div class="line">desc.separablePasses = <span class="keyword">false</span>;</div><div class="line">desc.techniques = { technique };</div><div class="line"></div><div class="line"><span class="comment">// Add a 4x4 transform matrix data parameter</span></div><div class="line">desc.addParameter(<span class="stringliteral">&quot;WorldTfrm&quot;</span>, <span class="stringliteral">&quot;WorldTfrm&quot;</span>, <a class="code" href="group___utility-_core.html#gga8cd5dffb4633f43e5afe604420a118e4abe72adb327b1de5a76afd77c363cae16">GPDT_MATRIX_4X4</a>);</div><div class="line"></div><div class="line"><span class="comment">// Add a texture parameter</span></div><div class="line">desc.addParameter(<span class="stringliteral">&quot;AlbedoTex&quot;</span>, <span class="stringliteral">&quot;AlbedoTex&quot;</span>, <a class="code" href="group___utility-_core.html#ggadad4be1cd5f0eea1b67992f36f794b08a0de5d053fe01b3c9ede7dc571f63a766">GPOT_TEXTURE2D</a>);</div><div class="line"></div><div class="line">SPtr&lt;Shader&gt; shader = Shader::create(<span class="stringliteral">&quot;MyShader&quot;</span>, desc);</div></div><!-- fragment --><h3><a class="anchor" id="materials_b_d_a"></a>
Advanced parameters</h3>
<p><b>SHADER_DESC::addParameter</b> also supports two additional arguments we didn't touch on in the previous section: renderer semantic and default value.</p>
<p>Renderer semantic allows you to give the parameter a unique tag that can be recognized by the active renderer. The renderer can then use these semantics to automatically assign values to them while rendering. For example the "WVP" semantic might notify the renderer to populate this parameter with the world-view-projection matrix. This way the user is not responsible for setting such parameters manually. The actual semantics supported depend on the active renderer. If provided and renderer doesn't support a semantic, it will be ignored. We'll talk more on how to access semantics in the renderer manual.</p>
<p>The parameter default value allows you to provide a value that will be used for initializing the parameter when a <b>Material</b> is initially constructed. For data parameters the default value is a provided as a raw block of memory, and for object parameters it can be a reference to a <b>Texture</b> or a <b>SamplerState</b>.</p>
<div class="fragment"><div class="line"><span class="comment">// An extended example from above with semantics and default values:</span></div><div class="line">SPtr&lt;Technique&gt; technique = ...;</div><div class="line"></div><div class="line">SHADER_DESC desc;</div><div class="line">desc.queueSortType = QueueSortType::None;</div><div class="line">desc.queuePriority = 0;</div><div class="line">desc.separablePasses = <span class="keyword">false</span>;</div><div class="line">desc.techniques = { technique };</div><div class="line"></div><div class="line"><span class="comment">// Add a 4x4 transform matrix data parameter with a &quot;W&quot; semantic and identity matrix as default</span></div><div class="line">desc.addParameter(<span class="stringliteral">&quot;WorldTfrm&quot;</span>, <span class="stringliteral">&quot;WorldTfrm&quot;</span>, <a class="code" href="group___utility-_core.html#gga8cd5dffb4633f43e5afe604420a118e4abe72adb327b1de5a76afd77c363cae16">GPDT_MATRIX_4X4</a>, <span class="stringliteral">&quot;W&quot;</span>, 1, 0, &amp;Matrix4::Identity);</div><div class="line"></div><div class="line"><span class="comment">// Add a texture parameter with an &quot;Albedo&quot; semantic and a white texture as default</span></div><div class="line">desc.addParameter(<span class="stringliteral">&quot;AlbedoTex&quot;</span>, <span class="stringliteral">&quot;AlbedoTex&quot;</span>, <a class="code" href="group___utility-_core.html#ggadad4be1cd5f0eea1b67992f36f794b08a0de5d053fe01b3c9ede7dc571f63a766">GPOT_TEXTURE2D</a>, Texture::White, <span class="stringliteral">&quot;Albedo&quot;</span>);</div><div class="line"></div><div class="line">HShader shader = Shader::create(<span class="stringliteral">&quot;MyShader&quot;</span>, desc);</div></div><!-- fragment --><h1><a class="anchor" id="materials_c"></a>
Manually rendering using the material</h1>
<p>In an earlier manual we have shown how to render using a <b>Material</b> by attaching it to a <b>Renderable</b> component and letting the renderer do the rest. You can however render using the material completely manually, using the low-level rendering API.</p>
<p>Material is a <b>CoreObject</b> which means it also has a core-thread interface accessible through <a class="el" href="classbs_1_1_material.html#a0eb9f0a504e384d737061328bcb6e662">Material::getCore()</a>. The interface is the same as the non-core interface we have described so far.</p>
<h2><a class="anchor" id="materials_c_a"></a>
Binding material</h2>
<p><b>Material</b> cannot be bound directly to the low level rendering API. You must instead manually retrieve a pipeline state for one of its passes.</p>
<p>You can retrieve a specific pass from a material by calling <a class="el" href="classbs_1_1_t_material.html#a8f56cbe1ad7bd83c73e8adbd662b0ca4">Material::getPass()</a>. The method expects an index of a technique and an index of a pass. To get the number of supported techniques call <a class="el" href="classbs_1_1_t_material.html#a7027d9d7abe0178ee552426cd0435033">Material::getNumTechniques()</a>, and to get the number of passes for a specific technique call <a class="el" href="classbs_1_1_t_material.html#a31530b82f1bbfec89d68980f95dda096">Material::getNumPasses()</a> with a specific technique index.</p>
<p>Once you have a <b>Pass</b> you can retrieve from it either a <b>GraphicsPipelineState</b> or a <b>ComputePipelineState</b> by calling <a class="el" href="classbs_1_1_t_pass.html#a5bc8594fb16a75fb8360fadd6f316691">Pass::getGraphicsPipelineState()</a> and <a class="el" href="classbs_1_1_t_pass.html#ae621dc5c5bf352b68951cbcbd0b76b71">Pass::getComputePipelineState()</a>, respectively. Those can then be bound for rendering as shown in the low level rendering API manual.</p>
<div class="fragment"><div class="line">SPtr&lt;Material&gt; material = ...;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> passIdx = 0;</div><div class="line"><span class="keywordtype">int</span> techniqueIdx = 0;</div><div class="line">SPtr&lt;Pass&gt; pass = material-&gt;getPass(passIdx, techniqueIdx);</div><div class="line"></div><div class="line">RenderAPI&amp; rapi = RenderAPI::instance();</div><div class="line">rapi.setGraphicsPipeline(pass-&gt;getGraphicsPipelineState());</div></div><!-- fragment --><p>Alternatively you can use the helper methods <a class="el" href="classbs_1_1ct_1_1_renderer_utility.html#a2bdc1aa82db4c8075246fb0e34e643e7">RendererUtility::setPass()</a> or <a class="el" href="classbs_1_1ct_1_1_renderer_utility.html#a640cd45193f56f021bfece01b3a4fd1e">RendererUtility::setComputePass()</a>.</p>
<h2><a class="anchor" id="materials_c_b"></a>
Binding material parameters</h2>
<p>In order to bind material parameters we need to somehow get access to a <b>GpuParams</b> object from the material. This is done through an intermediate class <a class="el" href="classbs_1_1_gpu_params_set.html">GpuParamsSet</a>, created by a call to <a class="el" href="classbs_1_1_t_material.html#a99d1acdf12d30246c7b50f9e09a1fa88">Material::createParamsSet()</a>, which as a parameter takes a technique index.</p>
<p><b>GpuParams</b> for a specific pass can then be retrieved by calling <a class="el" href="classbs_1_1_t_gpu_params_set.html#acac051eb52cd902035a28728f785e1e7">GpuParamsSet::getGpuParams()</a> with the pass index. They can then be bound as described in the low level render API manual.</p>
<div class="fragment"><div class="line">SPtr&lt;Material&gt; material = ...;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> passIdx = 0;</div><div class="line"><span class="keywordtype">int</span> techniqueIdx = 0;</div><div class="line">SPtr&lt;GpuParamsSet&gt; paramsSet = material-&gt;createParamsSet(techniqueIdx);</div><div class="line"></div><div class="line">RenderAPI&amp; rapi = RenderAPI::instance();</div><div class="line">rapi.setGpuParams(paramsSet-&gt;getGpuParams(passIdx));</div></div><!-- fragment --><p>Note that creation of a <b>GpuParamsSet</b> object is expensive, and the intent is that it will be created once (or just a few times) per material. <b>GpuParamsSet</b> contains a completely separate storage from the <b>Material</b> it was created from, therefore whenever material parameters are updated you must transfer its contents into <b>GpuParams</b> by calling <a class="el" href="classbs_1_1_t_gpu_params_set.html#afde3cae8398b17041310c36a7262d489">GpuParamsSet::update()</a>.</p>
<div class="fragment"><div class="line">SPtr&lt;GpuParamsSet&gt; paramsSet = material-&gt;createParamsSet(techniqueIdx);</div><div class="line"></div><div class="line"><span class="comment">// ...update some parameters on the material...</span></div><div class="line"></div><div class="line"><span class="comment">// Transfer the updated data</span></div><div class="line">paramsSet-&gt;update(material);</div></div><!-- fragment --><p>Once both the material's pipeline state and parameters are bound, you can then proceed to render as normally, as described in the low-level rendering manual. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
