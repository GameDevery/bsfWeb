<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - RenderAPI Class Reference</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='http://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="../SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="../SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebs.html">bs</a></li><li class="navelem"><b>ct</b></li><li class="navelem"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html">RenderAPI</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Methods</a> &#124;
<a href="classbs_1_1ct_1_1_render_a_p_i-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RenderAPI Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___internals.html">Internals</a> &raquo; <a class="el" href="group___internal-_core.html">Core</a> &raquo; <a class="el" href="group___render_a_p_i-_internal.html">RenderAPI</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Provides low-level API access to rendering commands (internally wrapping DirectX/OpenGL/Vulkan or similar). </p>
<p>Methods that accept a <a class="el" href="classbs_1_1ct_1_1_command_buffer.html" title="Contains a list of render API commands that can be queued for execution on the GPU. ">CommandBuffer</a> parameter get queued in the provided command buffer, and don't get executed until executeCommands() method is called. User is allowed to populate command buffers from non-core threads, but they all must get executed from the core thread.</p>
<p>If a command buffer is not provivided to such methods, they execute immediately. Without a command buffer the methods are only allowed to be called from the core thread.</p>
<dl class="section note"><dt>Note</dt><dd>Accessible on any thread for methods accepting a <a class="el" href="classbs_1_1ct_1_1_command_buffer.html" title="Contains a list of render API commands that can be queued for execution on the GPU. ">CommandBuffer</a>. Otherwise core thread unless specifically noted otherwise on per-method basis. </dd></dl>
</div>
<p>Inherits <a class="el" href="classbs_1_1_module.html">Module&lt; RenderAPI &gt;</a>.</p>

<p>Inherited by <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html">D3D11RenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html">GLRenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html">VulkanRenderAPI</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Methods</h2></td></tr>
<tr class="memitem:a293c9f17a04b517323dcab8d267ad62e"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classbs_1_1_string_i_d.html">StringID</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a293c9f17a04b517323dcab8d267ad62e">getName</a> () const =0</td></tr>
<tr class="memdesc:a293c9f17a04b517323dcab8d267ad62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the rendering system.  <a href="#a293c9f17a04b517323dcab8d267ad62e">More...</a><br /></td></tr>
<tr class="separator:a293c9f17a04b517323dcab8d267ad62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac882c9af0c546bd2405637a5373c0a99"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ac882c9af0c546bd2405637a5373c0a99">setGpuParams</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_gpu_params.html">GpuParams</a> &gt; &amp;gpuParams, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:ac882c9af0c546bd2405637a5373c0a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a set of parameters that control execution of all currently bound GPU programs.  <a href="#ac882c9af0c546bd2405637a5373c0a99">More...</a><br /></td></tr>
<tr class="separator:ac882c9af0c546bd2405637a5373c0a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1aae55785c78bfac4e1e8326d34413"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a7d1aae55785c78bfac4e1e8326d34413">setGraphicsPipeline</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_graphics_pipeline_state.html">GraphicsPipelineState</a> &gt; &amp;pipelineState, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:a7d1aae55785c78bfac4e1e8326d34413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a pipeline state that controls how will subsequent draw commands render primitives.  <a href="#a7d1aae55785c78bfac4e1e8326d34413">More...</a><br /></td></tr>
<tr class="separator:a7d1aae55785c78bfac4e1e8326d34413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1470f65f420f136d5b01f2a2b0df02c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#af1470f65f420f136d5b01f2a2b0df02c">setComputePipeline</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_compute_pipeline_state.html">ComputePipelineState</a> &gt; &amp;pipelineState, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:af1470f65f420f136d5b01f2a2b0df02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a pipeline state that controls how will subsequent dispatch commands execute.  <a href="#af1470f65f420f136d5b01f2a2b0df02c">More...</a><br /></td></tr>
<tr class="separator:af1470f65f420f136d5b01f2a2b0df02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7a3caf480306534477ca6b8ff4574f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#afd7a3caf480306534477ca6b8ff4574f">setViewport</a> (const <a class="el" href="classbs_1_1_rect2.html">Rect2</a> &amp;area, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:afd7a3caf480306534477ca6b8ff4574f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the active viewport that will be used for all render operations.  <a href="#afd7a3caf480306534477ca6b8ff4574f">More...</a><br /></td></tr>
<tr class="separator:afd7a3caf480306534477ca6b8ff4574f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ded76085d80d960bd82a190708ad0d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a9ded76085d80d960bd82a190708ad0d9">setScissorRect</a> (UINT32 left, UINT32 top, UINT32 right, UINT32 bottom, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:a9ded76085d80d960bd82a190708ad0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to set up a region in which rendering can take place.  <a href="#a9ded76085d80d960bd82a190708ad0d9">More...</a><br /></td></tr>
<tr class="separator:a9ded76085d80d960bd82a190708ad0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c3728748c7fd95e861d7d1fc54a482"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a42c3728748c7fd95e861d7d1fc54a482">setStencilRef</a> (UINT32 value, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:a42c3728748c7fd95e861d7d1fc54a482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a reference value that will be used for stencil compare operations.  <a href="#a42c3728748c7fd95e861d7d1fc54a482">More...</a><br /></td></tr>
<tr class="separator:a42c3728748c7fd95e861d7d1fc54a482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e37a2417121c9cd5af10c81dc334ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ab0e37a2417121c9cd5af10c81dc334ce">setVertexBuffers</a> (UINT32 index, <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vertex_buffer.html">VertexBuffer</a> &gt; *buffers, UINT32 numBuffers, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:ab0e37a2417121c9cd5af10c81dc334ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the provided vertex buffers starting at the specified source index.  <a href="#ab0e37a2417121c9cd5af10c81dc334ce">More...</a><br /></td></tr>
<tr class="separator:ab0e37a2417121c9cd5af10c81dc334ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c209ee82baae076db87065569a5b5b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ae5c209ee82baae076db87065569a5b5b">setIndexBuffer</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_index_buffer.html">IndexBuffer</a> &gt; &amp;buffer, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:ae5c209ee82baae076db87065569a5b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an index buffer to use when drawing.  <a href="#ae5c209ee82baae076db87065569a5b5b">More...</a><br /></td></tr>
<tr class="separator:ae5c209ee82baae076db87065569a5b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6be919aec953bca0fad3f824645d18"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a0e6be919aec953bca0fad3f824645d18">setVertexDeclaration</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vertex_declaration.html">VertexDeclaration</a> &gt; &amp;vertexDeclaration, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:a0e6be919aec953bca0fad3f824645d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex declaration to use when drawing.  <a href="#a0e6be919aec953bca0fad3f824645d18">More...</a><br /></td></tr>
<tr class="separator:a0e6be919aec953bca0fad3f824645d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70180438d34bfce5c147221ff1448ddf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a70180438d34bfce5c147221ff1448ddf">setDrawOperation</a> (<a class="el" href="group___utility-_core.html#ga0a43fbead35d1ad167d465731c5c4c53">DrawOperationType</a> op, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:a70180438d34bfce5c147221ff1448ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the draw operation that determines how to interpret the elements of the index or vertex buffers.  <a href="#a70180438d34bfce5c147221ff1448ddf">More...</a><br /></td></tr>
<tr class="separator:a70180438d34bfce5c147221ff1448ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc00f62de16b8141290d68cfe7b67a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a1cc00f62de16b8141290d68cfe7b67a4">draw</a> (UINT32 vertexOffset, UINT32 vertexCount, UINT32 instanceCount=0, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:a1cc00f62de16b8141290d68cfe7b67a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an object based on currently bound GPU programs, vertex declaration and vertex buffers.  <a href="#a1cc00f62de16b8141290d68cfe7b67a4">More...</a><br /></td></tr>
<tr class="separator:a1cc00f62de16b8141290d68cfe7b67a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f5b32d5f5e2f8016b5c9d5078d28e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ae7f5b32d5f5e2f8016b5c9d5078d28e4">drawIndexed</a> (UINT32 startIndex, UINT32 indexCount, UINT32 vertexOffset, UINT32 vertexCount, UINT32 instanceCount=0, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:ae7f5b32d5f5e2f8016b5c9d5078d28e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an object based on currently bound GPU programs, vertex declaration, vertex and index buffers.  <a href="#ae7f5b32d5f5e2f8016b5c9d5078d28e4">More...</a><br /></td></tr>
<tr class="separator:ae7f5b32d5f5e2f8016b5c9d5078d28e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c8eb09649871e3ea3de65fa79bdf12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a54c8eb09649871e3ea3de65fa79bdf12">dispatchCompute</a> (UINT32 numGroupsX, UINT32 numGroupsY=1, UINT32 numGroupsZ=1, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:a54c8eb09649871e3ea3de65fa79bdf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the currently bound compute shader.  <a href="#a54c8eb09649871e3ea3de65fa79bdf12">More...</a><br /></td></tr>
<tr class="separator:a54c8eb09649871e3ea3de65fa79bdf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d047892af237e2bc3c3d0a73e2bb888"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a0d047892af237e2bc3c3d0a73e2bb888">swapBuffers</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_target.html">RenderTarget</a> &gt; &amp;target, UINT32 syncMask=0xFFFFFFFF)=0</td></tr>
<tr class="memdesc:a0d047892af237e2bc3c3d0a73e2bb888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the front and back buffer of the specified render target.  <a href="#a0d047892af237e2bc3c3d0a73e2bb888">More...</a><br /></td></tr>
<tr class="separator:a0d047892af237e2bc3c3d0a73e2bb888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace358e66fbeec1253cbd3211bbf1e2d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ace358e66fbeec1253cbd3211bbf1e2d1">setRenderTarget</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_target.html">RenderTarget</a> &gt; &amp;target, UINT32 readOnlyFlags=0, <a class="el" href="classbs_1_1_flags.html">RenderSurfaceMask</a> loadMask=RT_NONE, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:ace358e66fbeec1253cbd3211bbf1e2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the render target into which we want to draw.  <a href="#ace358e66fbeec1253cbd3211bbf1e2d1">More...</a><br /></td></tr>
<tr class="separator:ace358e66fbeec1253cbd3211bbf1e2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa322bfe6a30f71ec423e6f08c8734458"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#aa322bfe6a30f71ec423e6f08c8734458">clearRenderTarget</a> (UINT32 buffers, const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;color=Color::Black, float depth=1.0f, UINT16 stencil=0, UINT8 targetMask=0xFF, const SPtr&lt; CommandBuffer &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:aa322bfe6a30f71ec423e6f08c8734458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the currently active render target.  <a href="#aa322bfe6a30f71ec423e6f08c8734458">More...</a><br /></td></tr>
<tr class="separator:aa322bfe6a30f71ec423e6f08c8734458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18d21e36f2474fa6a76b27ab85124b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#aa18d21e36f2474fa6a76b27ab85124b0">clearViewport</a> (UINT32 buffers, const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;color=Color::Black, float depth=1.0f, UINT16 stencil=0, UINT8 targetMask=0xFF, const SPtr&lt; CommandBuffer &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:aa18d21e36f2474fa6a76b27ab85124b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the currently active viewport (meaning it clears just a sub-area of a render-target that is covered by the viewport, as opposed to <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#aa322bfe6a30f71ec423e6f08c8734458" title="Clears the currently active render target. ">clearRenderTarget()</a> which always clears the entire render target).  <a href="#aa18d21e36f2474fa6a76b27ab85124b0">More...</a><br /></td></tr>
<tr class="separator:aa18d21e36f2474fa6a76b27ab85124b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100a6f2c03e04d56355177a848d811aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a100a6f2c03e04d56355177a848d811aa">addCommands</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;secondary)=0</td></tr>
<tr class="memdesc:a100a6f2c03e04d56355177a848d811aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all commands from the provided secondary command buffer into the primary command buffer.  <a href="#a100a6f2c03e04d56355177a848d811aa">More...</a><br /></td></tr>
<tr class="separator:a100a6f2c03e04d56355177a848d811aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bdd357983b845df4c0a070ed47669b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a86bdd357983b845df4c0a070ed47669b">submitCommandBuffer</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer, UINT32 syncMask=0xFFFFFFFF)=0</td></tr>
<tr class="memdesc:a86bdd357983b845df4c0a070ed47669b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes all commands in the provided command buffer.  <a href="#a86bdd357983b845df4c0a070ed47669b">More...</a><br /></td></tr>
<tr class="separator:a86bdd357983b845df4c0a070ed47669b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4391aff66b3a8a6b9fa9f318b1e0763"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbs_1_1_render_a_p_i_capabilities.html">RenderAPICapabilities</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#af4391aff66b3a8a6b9fa9f318b1e0763">getCapabilities</a> (UINT32 deviceIdx) const</td></tr>
<tr class="memdesc:af4391aff66b3a8a6b9fa9f318b1e0763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the capabilities of a specific GPU.  <a href="#af4391aff66b3a8a6b9fa9f318b1e0763">More...</a><br /></td></tr>
<tr class="separator:af4391aff66b3a8a6b9fa9f318b1e0763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa47621db2c7fa844fd178af921b8f2"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a2fa47621db2c7fa844fd178af921b8f2">getNumDevices</a> () const</td></tr>
<tr class="memdesc:a2fa47621db2c7fa844fd178af921b8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of devices supported by this render API.  <a href="#a2fa47621db2c7fa844fd178af921b8f2">More...</a><br /></td></tr>
<tr class="separator:a2fa47621db2c7fa844fd178af921b8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e037344fde0e4cdb31d343fa158e7d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbs_1_1_video_mode_info.html">VideoModeInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ad8e037344fde0e4cdb31d343fa158e7d">getVideoModeInfo</a> () const</td></tr>
<tr class="memdesc:ad8e037344fde0e4cdb31d343fa158e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about available output devices and their video modes.  <a href="#ad8e037344fde0e4cdb31d343fa158e7d">More...</a><br /></td></tr>
<tr class="separator:ad8e037344fde0e4cdb31d343fa158e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39286473640751160bdb8536c859f413"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a39286473640751160bdb8536c859f413">convertProjectionMatrix</a> (const <a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> &amp;matrix, <a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> &amp;dest)=0</td></tr>
<tr class="memdesc:a39286473640751160bdb8536c859f413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a default matrix into a matrix suitable for use by this specific render system.  <a href="#a39286473640751160bdb8536c859f413">More...</a><br /></td></tr>
<tr class="separator:a39286473640751160bdb8536c859f413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab54829757e2024801388a91d50c8fd"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classbs_1_1_render_a_p_i_info.html">RenderAPIInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a0ab54829757e2024801388a91d50c8fd">getAPIInfo</a> () const =0</td></tr>
<tr class="memdesc:a0ab54829757e2024801388a91d50c8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about the specific API implementation.  <a href="#a0ab54829757e2024801388a91d50c8fd">More...</a><br /></td></tr>
<tr class="separator:a0ab54829757e2024801388a91d50c8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9400792256a05759150326c41b6b4c20"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structbs_1_1_gpu_param_block_desc.html">GpuParamBlockDesc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a9400792256a05759150326c41b6b4c20">generateParamBlockDesc</a> (const <a class="el" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> &amp;name, <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="structbs_1_1_gpu_param_data_desc.html">GpuParamDataDesc</a> &gt; &amp;params)=0</td></tr>
<tr class="memdesc:a9400792256a05759150326c41b6b4c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a parameter block description and calculates per-parameter offsets for the provided gpu data parameters.  <a href="#a9400792256a05759150326c41b6b4c20">More...</a><br /></td></tr>
<tr class="separator:a9400792256a05759150326c41b6b4c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classbs_1_1_module"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classbs_1_1_module')"><img src="closed.png" alt="-"/>&#160;Static methods inherited from <a class="el" href="classbs_1_1_module.html">Module&lt; RenderAPI &gt;</a></td></tr>
<tr class="memitem:a359703743cd890f1e3df60b6b06a5724 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbs_1_1_render_a_p_i.html">RenderAPI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a359703743cd890f1e3df60b6b06a5724">instance</a> ()</td></tr>
<tr class="memdesc:a359703743cd890f1e3df60b6b06a5724 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the module instance.  <a href="classbs_1_1_module.html#a359703743cd890f1e3df60b6b06a5724">More...</a><br /></td></tr>
<tr class="separator:a359703743cd890f1e3df60b6b06a5724 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affac4ec5f49e5e5561a027e3116e6f73 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbs_1_1_render_a_p_i.html">RenderAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#affac4ec5f49e5e5561a027e3116e6f73">instancePtr</a> ()</td></tr>
<tr class="memdesc:affac4ec5f49e5e5561a027e3116e6f73 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the module instance.  <a href="classbs_1_1_module.html#affac4ec5f49e5e5561a027e3116e6f73">More...</a><br /></td></tr>
<tr class="separator:affac4ec5f49e5e5561a027e3116e6f73 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b9d091b1b64652c94d5dd3b1c5017a inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a02b9d091b1b64652c94d5dd3b1c5017a">startUp</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a02b9d091b1b64652c94d5dd3b1c5017a inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and starts the module using the specified parameters.  <a href="classbs_1_1_module.html#a02b9d091b1b64652c94d5dd3b1c5017a">More...</a><br /></td></tr>
<tr class="separator:a02b9d091b1b64652c94d5dd3b1c5017a inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1a58af7a42d68c1ae45e40fbe8cebb inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a4d1a58af7a42d68c1ae45e40fbe8cebb">startUp</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a4d1a58af7a42d68c1ae45e40fbe8cebb inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and starts a specialized type of the module.  <a href="classbs_1_1_module.html#a4d1a58af7a42d68c1ae45e40fbe8cebb">More...</a><br /></td></tr>
<tr class="separator:a4d1a58af7a42d68c1ae45e40fbe8cebb inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ea87e87e28686a619551382f541433 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#aa4ea87e87e28686a619551382f541433">shutDown</a> ()</td></tr>
<tr class="memdesc:aa4ea87e87e28686a619551382f541433 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down this module and frees any resources it is using.  <a href="classbs_1_1_module.html#aa4ea87e87e28686a619551382f541433">More...</a><br /></td></tr>
<tr class="separator:aa4ea87e87e28686a619551382f541433 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289734510f3022acd240087478b994d9 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a289734510f3022acd240087478b994d9">isStarted</a> ()</td></tr>
<tr class="memdesc:a289734510f3022acd240087478b994d9 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if the module has been started.  <a href="classbs_1_1_module.html#a289734510f3022acd240087478b994d9">More...</a><br /></td></tr>
<tr class="separator:a289734510f3022acd240087478b994d9 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Method documentation</h2>
<a id="a100a6f2c03e04d56355177a848d811aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100a6f2c03e04d56355177a848d811aa">&#9670;&nbsp;</a></span>addCommands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void addCommands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>secondary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all commands from the provided secondary command buffer into the primary command buffer. </p>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a657c493f81508905b613366918c48420">GLRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a657c493f81508905b613366918c48420">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a657c493f81508905b613366918c48420">VulkanRenderAPI</a>.</p>

</div>
</div>
<a id="aa322bfe6a30f71ec423e6f08c8734458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa322bfe6a30f71ec423e6f08c8734458">&#9670;&nbsp;</a></span>clearRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void clearRenderTarget </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em> = <code>Color::Black</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>stencil</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8&#160;</td>
          <td class="paramname"><em>targetMask</em> = <code>0xFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the currently active render target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>Combination of one or more elements of FrameBufferType denoting which buffers are to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to clear the color buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>The value to initialize the depth buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stencil</td><td>The value to initialize the stencil buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetMask</td><td>In case multiple render targets are bound, this allows you to control which ones to clear (0x01 first, 0x02 second, 0x04 third, etc., and combinations). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a91f0245bd3b64909cddab2a8f5d2ee80">GLRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a91f0245bd3b64909cddab2a8f5d2ee80">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a91f0245bd3b64909cddab2a8f5d2ee80">VulkanRenderAPI</a>.</p>

</div>
</div>
<a id="aa18d21e36f2474fa6a76b27ab85124b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18d21e36f2474fa6a76b27ab85124b0">&#9670;&nbsp;</a></span>clearViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void clearViewport </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em> = <code>Color::Black</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>stencil</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8&#160;</td>
          <td class="paramname"><em>targetMask</em> = <code>0xFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the currently active viewport (meaning it clears just a sub-area of a render-target that is covered by the viewport, as opposed to <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#aa322bfe6a30f71ec423e6f08c8734458" title="Clears the currently active render target. ">clearRenderTarget()</a> which always clears the entire render target). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>Combination of one or more elements of FrameBufferType denoting which buffers are to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to clear the color buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>The value to initialize the depth buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stencil</td><td>The value to initialize the stencil buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetMask</td><td>In case multiple render targets are bound, this allows you to control which ones to clear (0x01 first, 0x02 second, 0x04 third, etc., and combinations). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a5c11c7d446f639196adf69b56308a228">GLRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a5c11c7d446f639196adf69b56308a228">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a5c11c7d446f639196adf69b56308a228">VulkanRenderAPI</a>.</p>

</div>
</div>
<a id="a39286473640751160bdb8536c859f413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39286473640751160bdb8536c859f413">&#9670;&nbsp;</a></span>convertProjectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void convertProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains a default matrix into a matrix suitable for use by this specific render system. </p>
<dl class="section note"><dt>Note</dt><dd>Thread safe. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#af52623f1583db791bf9fc12692e2c477">GLRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#af52623f1583db791bf9fc12692e2c477">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#af52623f1583db791bf9fc12692e2c477">VulkanRenderAPI</a>.</p>

</div>
</div>
<a id="a3a80b6032f86a56bec74609034b3246f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a80b6032f86a56bec74609034b3246f">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shuts down the render API system and cleans up all resources. </p>
<dl class="section note"><dt>Note</dt><dd>Sim thread. </dd></dl>

</div>
</div>
<a id="a30aad4dcf6e2df219ea8d2eb6da62c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30aad4dcf6e2df219ea8d2eb6da62c9c">&#9670;&nbsp;</a></span>destroyCore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void destroyCore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs render API system shutdown on the core thread. </p>

<p>Reimplemented in <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#ac8cf325a37d7e7f96eed609f7d426bba">VulkanRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#ac8cf325a37d7e7f96eed609f7d426bba">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#ac8cf325a37d7e7f96eed609f7d426bba">GLRenderAPI</a>.</p>

</div>
</div>
<a id="a54c8eb09649871e3ea3de65fa79bdf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c8eb09649871e3ea3de65fa79bdf12">&#9670;&nbsp;</a></span>dispatchCompute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dispatchCompute </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numGroupsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numGroupsY</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numGroupsZ</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the currently bound compute shader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numGroupsX</td><td>Number of groups to start in the X direction. Must be in range [1, 65535]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numGroupsY</td><td>Number of groups to start in the Y direction. Must be in range [1, 65535]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numGroupsZ</td><td>Number of groups to start in the Z direction. Must be in range [1, 64]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support compute or graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a9634714c4d37ce1a794787eda55570b1">D3D11RenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a9634714c4d37ce1a794787eda55570b1">VulkanRenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a9634714c4d37ce1a794787eda55570b1">GLRenderAPI</a>.</p>

</div>
</div>
<a id="a1cc00f62de16b8141290d68cfe7b67a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc00f62de16b8141290d68cfe7b67a4">&#9670;&nbsp;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void draw </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>vertexOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>instanceCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw an object based on currently bound GPU programs, vertex declaration and vertex buffers. </p>
<p>Draws directly from the vertex buffer without using indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexOffset</td><td>Offset into the currently bound vertex buffer to start drawing from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexCount</td><td>Number of vertices to draw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">instanceCount</td><td>Number of times to draw the provided geometry, each time with an (optionally) separate per-instance data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a642b62982d6728d871bc8539be665c77">D3D11RenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a642b62982d6728d871bc8539be665c77">VulkanRenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a642b62982d6728d871bc8539be665c77">GLRenderAPI</a>.</p>

</div>
</div>
<a id="ae7f5b32d5f5e2f8016b5c9d5078d28e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f5b32d5f5e2f8016b5c9d5078d28e4">&#9670;&nbsp;</a></span>drawIndexed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void drawIndexed </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>indexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>vertexOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>instanceCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw an object based on currently bound GPU programs, vertex declaration, vertex and index buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>Offset into the currently bound index buffer to start drawing from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexCount</td><td>Number of indices to draw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexOffset</td><td>Offset to apply to each vertex index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexCount</td><td>Number of vertices to draw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">instanceCount</td><td>Number of times to draw the provided geometry, each time with an (optionally) separate per-instance data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a8eba64fc575bb70517d8c35f2b77f66a">D3D11RenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a8eba64fc575bb70517d8c35f2b77f66a">VulkanRenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a8eba64fc575bb70517d8c35f2b77f66a">GLRenderAPI</a>.</p>

</div>
</div>
<a id="a9400792256a05759150326c41b6b4c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9400792256a05759150326c41b6b4c20">&#9670;&nbsp;</a></span>generateParamBlockDesc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structbs_1_1_gpu_param_block_desc.html">GpuParamBlockDesc</a> generateParamBlockDesc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="structbs_1_1_gpu_param_data_desc.html">GpuParamDataDesc</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a parameter block description and calculates per-parameter offsets for the provided gpu data parameters. </p>
<p>The offsets are render API specific and correspond to std140 layout for OpenGL, and the default layout in DirectX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name to assign the parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>List of parameters in the parameter block. Only name, type and array size fields need to be populated, the rest will be populated when the method returns. If a parameter is a struct then the elementSize field needs to be populated with the size of the struct in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Descriptor for the parameter block holding the provided parameters as laid out by the default render API layout. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a9a111d30df3a3ccd22861e61207a31e1">GLRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a9a111d30df3a3ccd22861e61207a31e1">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a9a111d30df3a3ccd22861e61207a31e1">VulkanRenderAPI</a>.</p>

</div>
</div>
<a id="a0ab54829757e2024801388a91d50c8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab54829757e2024801388a91d50c8fd">&#9670;&nbsp;</a></span>getAPIInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classbs_1_1_render_a_p_i_info.html">RenderAPIInfo</a>&amp; getAPIInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns information about the specific API implementation. </p>
<dl class="section note"><dt>Note</dt><dd>Thread safe. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a35a90f56b153b7ff73d4171e675cd6ad">GLRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a35a90f56b153b7ff73d4171e675cd6ad">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a35a90f56b153b7ff73d4171e675cd6ad">VulkanRenderAPI</a>.</p>

</div>
</div>
<a id="af4391aff66b3a8a6b9fa9f318b1e0763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4391aff66b3a8a6b9fa9f318b1e0763">&#9670;&nbsp;</a></span>getCapabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbs_1_1_render_a_p_i_capabilities.html">RenderAPICapabilities</a>&amp; getCapabilities </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>deviceIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the capabilities of a specific GPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceIdx</td><td>Index of the device to get the capabilities for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread safe. </dd></dl>

</div>
</div>
<a id="a293c9f17a04b517323dcab8d267ad62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293c9f17a04b517323dcab8d267ad62e">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classbs_1_1_string_i_d.html">StringID</a>&amp; getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the rendering system. </p>
<dl class="section note"><dt>Note</dt><dd>Thread safe. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a5099169c5d5949d4a96279844ad545ad">GLRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a5099169c5d5949d4a96279844ad545ad">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a5099169c5d5949d4a96279844ad545ad">VulkanRenderAPI</a>.</p>

</div>
</div>
<a id="a2fa47621db2c7fa844fd178af921b8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa47621db2c7fa844fd178af921b8f2">&#9670;&nbsp;</a></span>getNumDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 getNumDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of devices supported by this render API. </p>

</div>
</div>
<a id="ad8e037344fde0e4cdb31d343fa158e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e037344fde0e4cdb31d343fa158e7d">&#9670;&nbsp;</a></span>getVideoModeInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbs_1_1_video_mode_info.html">VideoModeInfo</a>&amp; getVideoModeInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns information about available output devices and their video modes. </p>
<dl class="section note"><dt>Note</dt><dd>Thread safe. </dd></dl>

</div>
</div>
<a id="a3929cc1297669b5ae381704e87259667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3929cc1297669b5ae381704e87259667">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_render_window.html">bs::RenderWindow</a>&gt; initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbs_1_1_r_e_n_d_e_r___w_i_n_d_o_w___d_e_s_c.html">RENDER_WINDOW_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>primaryWindowDesc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the render API system and creates a primary render window. </p>
<dl class="section note"><dt>Note</dt><dd>Sim thread only. </dd></dl>

</div>
</div>
<a id="a6365dca5a7d8ddb694726a53b55a4c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6365dca5a7d8ddb694726a53b55a4c27">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the render API system. </p>
<p>Called before the primary render window is created. </p>

<p>Reimplemented in <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a371caef26098f2a15df9fbee047b58f2">VulkanRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a371caef26098f2a15df9fbee047b58f2">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a371caef26098f2a15df9fbee047b58f2">GLRenderAPI</a>.</p>

</div>
</div>
<a id="a4f1e854425d376ef7af76ed83a942c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1e854425d376ef7af76ed83a942c96">&#9670;&nbsp;</a></span>initializeWithWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void initializeWithWindow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_window.html">RenderWindow</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>primaryWindow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs (optional) secondary initialization of the render API system. </p>
<p>Called after the render window is created. </p>

<p>Reimplemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a9083c27929f2a6bd82ed2a0a2b85d6e8">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a9083c27929f2a6bd82ed2a0a2b85d6e8">GLRenderAPI</a>.</p>

</div>
</div>
<a id="af1470f65f420f136d5b01f2a2b0df02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1470f65f420f136d5b01f2a2b0df02c">&#9670;&nbsp;</a></span>setComputePipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setComputePipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_compute_pipeline_state.html">ComputePipelineState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pipelineState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a pipeline state that controls how will subsequent dispatch commands execute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pipelineState</td><td>Pipeline state to bind, or null to unbind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a5c3ee554197454cce52c13421779e3ac">GLRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a5c3ee554197454cce52c13421779e3ac">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a5c3ee554197454cce52c13421779e3ac">VulkanRenderAPI</a>.</p>

</div>
</div>
<a id="a70180438d34bfce5c147221ff1448ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70180438d34bfce5c147221ff1448ddf">&#9670;&nbsp;</a></span>setDrawOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setDrawOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga0a43fbead35d1ad167d465731c5c4c53">DrawOperationType</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the draw operation that determines how to interpret the elements of the index or vertex buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Draw operation to enable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a43ce409ebfc2b11c4844de7940492b5b">D3D11RenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a43ce409ebfc2b11c4844de7940492b5b">VulkanRenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a43ce409ebfc2b11c4844de7940492b5b">GLRenderAPI</a>.</p>

</div>
</div>
<a id="ac882c9af0c546bd2405637a5373c0a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac882c9af0c546bd2405637a5373c0a99">&#9670;&nbsp;</a></span>setGpuParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setGpuParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_gpu_params.html">GpuParams</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpuParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a set of parameters that control execution of all currently bound GPU programs. </p>
<p>These are the uniforms like textures, samplers, or uniform buffers. Caller is expected to ensure the provided parameters actually match the currently bound programs. </p>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#abb90fad9397c2bad313abb1efa523845">GLRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#abb90fad9397c2bad313abb1efa523845">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#abb90fad9397c2bad313abb1efa523845">VulkanRenderAPI</a>.</p>

</div>
</div>
<a id="a7d1aae55785c78bfac4e1e8326d34413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1aae55785c78bfac4e1e8326d34413">&#9670;&nbsp;</a></span>setGraphicsPipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_graphics_pipeline_state.html">GraphicsPipelineState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pipelineState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a pipeline state that controls how will subsequent draw commands render primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pipelineState</td><td>Pipeline state to bind, or null to unbind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbs_1_1ct_1_1_graphics_pipeline_state.html" title="Core thread version of a bs::GraphicsPipelineState. ">GraphicsPipelineState</a> </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a0d06bc7ba63d82065a37664ad3098434">GLRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a0d06bc7ba63d82065a37664ad3098434">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a0d06bc7ba63d82065a37664ad3098434">VulkanRenderAPI</a>.</p>

</div>
</div>
<a id="ae5c209ee82baae076db87065569a5b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c209ee82baae076db87065569a5b5b">&#9670;&nbsp;</a></span>setIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_index_buffer.html">IndexBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets an index buffer to use when drawing. </p>
<p>Indices in an index buffer reference vertices in the vertex buffer, which increases cache coherency and reduces the size of vertex buffers by eliminating duplicate data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Index buffer to bind, null to unbind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a631b9a35f09b7ba4135ce2d4fad24f2b">D3D11RenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a631b9a35f09b7ba4135ce2d4fad24f2b">VulkanRenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a631b9a35f09b7ba4135ce2d4fad24f2b">GLRenderAPI</a>.</p>

</div>
</div>
<a id="ace358e66fbeec1253cbd3211bbf1e2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace358e66fbeec1253cbd3211bbf1e2d1">&#9670;&nbsp;</a></span>setRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setRenderTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_target.html">RenderTarget</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>readOnlyFlags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbs_1_1_flags.html">RenderSurfaceMask</a>&#160;</td>
          <td class="paramname"><em>loadMask</em> = <code>RT_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the render target into which we want to draw. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Render target to draw to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">readOnlyFlags</td><td>Combination of one or more elements of FrameBufferType denoting which buffers will be bound for read-only operations. This is useful for depth or stencil buffers which need to be bound both for depth/stencil tests, as well as shader reads. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loadMask</td><td>Determines which render target surfaces will have their current contents preserved. By default when a render target is bound its contents will be lost. You might need to preserve contents if you need to perform blending or similar operations with the existing contents of the render target.</td></tr>
  </table>
  </dd>
</dl>
<p>Use the mask to select exactly which surfaces of the render target need their contents preserved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#af25e6df723f29a5647adced8b644e06d">GLRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a0e6206c59e80cf7017a13bd5ff0f9058">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#af25e6df723f29a5647adced8b644e06d">VulkanRenderAPI</a>.</p>

</div>
</div>
<a id="a9ded76085d80d960bd82a190708ad0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ded76085d80d960bd82a190708ad0d9">&#9670;&nbsp;</a></span>setScissorRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setScissorRect </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows you to set up a region in which rendering can take place. </p>
<p>Coordinates are in pixels. No rendering will be done to render target pixels outside of the provided region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>Left border of the scissor rectangle, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Top border of the scissor rectangle, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Right border of the scissor rectangle, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>Bottom border of the scissor rectangle, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#aedff3bdfd598d4200f81d7433ac27307">D3D11RenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#aedff3bdfd598d4200f81d7433ac27307">VulkanRenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#aedff3bdfd598d4200f81d7433ac27307">GLRenderAPI</a>.</p>

</div>
</div>
<a id="a42c3728748c7fd95e861d7d1fc54a482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c3728748c7fd95e861d7d1fc54a482">&#9670;&nbsp;</a></span>setStencilRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setStencilRef </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a reference value that will be used for stencil compare operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Reference value to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a4d8812da33be62834c28e7933735d279">D3D11RenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a4d8812da33be62834c28e7933735d279">VulkanRenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a4d8812da33be62834c28e7933735d279">GLRenderAPI</a>.</p>

</div>
</div>
<a id="ab0e37a2417121c9cd5af10c81dc334ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e37a2417121c9cd5af10c81dc334ce">&#9670;&nbsp;</a></span>setVertexBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setVertexBuffers </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vertex_buffer.html">VertexBuffer</a> &gt; *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the provided vertex buffers starting at the specified source index. </p>
<p>Set buffer to nullptr to clear the buffer at the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index at which to start binding the vertex buffers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>A list of buffers to bind to the pipeline. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBuffers</td><td>Number of buffers in the <code>buffers</code> list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#ac6fd1d924e30098801bdb8fc72df380b">D3D11RenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#ac6fd1d924e30098801bdb8fc72df380b">VulkanRenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#ac6fd1d924e30098801bdb8fc72df380b">GLRenderAPI</a>.</p>

</div>
</div>
<a id="a0e6be919aec953bca0fad3f824645d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6be919aec953bca0fad3f824645d18">&#9670;&nbsp;</a></span>setVertexDeclaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setVertexDeclaration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vertex_declaration.html">VertexDeclaration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the vertex declaration to use when drawing. </p>
<p>Vertex declaration is used to decode contents of a single vertex in a vertex buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexDeclaration</td><td>Vertex declaration to bind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#abc2f84b7fd7ec04c7de0073f923fcdb6">D3D11RenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#abc2f84b7fd7ec04c7de0073f923fcdb6">VulkanRenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#abc2f84b7fd7ec04c7de0073f923fcdb6">GLRenderAPI</a>.</p>

</div>
</div>
<a id="afd7a3caf480306534477ca6b8ff4574f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7a3caf480306534477ca6b8ff4574f">&#9670;&nbsp;</a></span>setViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setViewport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_rect2.html">Rect2</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the active viewport that will be used for all render operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Area of the viewport, in normalized ([0,1] range) coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#afc830dd83363d37c5d07f055b0e4b84f">D3D11RenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#afc830dd83363d37c5d07f055b0e4b84f">VulkanRenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#afc830dd83363d37c5d07f055b0e4b84f">GLRenderAPI</a>.</p>

</div>
</div>
<a id="a86bdd357983b845df4c0a070ed47669b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86bdd357983b845df4c0a070ed47669b">&#9670;&nbsp;</a></span>submitCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void submitCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>syncMask</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes all commands in the provided command buffer. </p>
<p>Command buffer cannot be secondary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Command buffer whose commands to execute. Set to null to submit the main command buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">syncMask</td><td>Optional synchronization mask that determines if the submitted command buffer depends on any other command buffers. Use the <a class="el" href="classbs_1_1ct_1_1_command_sync_mask.html" title="Mask that determines synchronization between command buffers executing on different hardware queues...">CommandSyncMask</a> class to generate a mask using existing command buffers.</td></tr>
  </table>
  </dd>
</dl>
<p>This mask is only relevant if your command buffers are executing on different hardware queues, and are somehow dependant. If they are executing on the same queue (default) then they will execute sequentially in the order they are submitted. Otherwise, if there is a dependency, you must make state it explicitly here.</p>
<dl class="section note"><dt>Note</dt><dd>Core thread only. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a4028d9ce0fd012246b961b6751a764b2">GLRenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a4028d9ce0fd012246b961b6751a764b2">D3D11RenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a4028d9ce0fd012246b961b6751a764b2">VulkanRenderAPI</a>.</p>

</div>
</div>
<a id="a0d047892af237e2bc3c3d0a73e2bb888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d047892af237e2bc3c3d0a73e2bb888">&#9670;&nbsp;</a></span>swapBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void swapBuffers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_target.html">RenderTarget</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>syncMask</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the front and back buffer of the specified render target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Render target to perform the buffer swap on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">syncMask</td><td>Optional synchronization mask that determines for which queues should the system wait before performing the swap buffer operation. By default the system waits for all queues. However if certain queues are performing non-rendering operations, or operations not related to the provided render target, you can exclude them from the sync mask for potentially better performance. You can use <a class="el" href="classbs_1_1ct_1_1_command_sync_mask.html" title="Mask that determines synchronization between command buffers executing on different hardware queues...">CommandSyncMask</a> to generate a valid sync mask. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_render_a_p_i.html#a45aa4fc19ef23ccacb2ad0de3b7d449e">D3D11RenderAPI</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a45aa4fc19ef23ccacb2ad0de3b7d449e">VulkanRenderAPI</a>, and <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a45aa4fc19ef23ccacb2ad0de3b7d449e">GLRenderAPI</a>.</p>

</div>
</div>
<a id="ac356610757c43d37b7f68c2fe7e56fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac356610757c43d37b7f68c2fe7e56fef">&#9670;&nbsp;</a></span>vertexCountToPrimCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 vertexCountToPrimCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga0a43fbead35d1ad167d465731c5c4c53">DrawOperationType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>elementCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the number of vertices to number of primitives based on the specified draw operation. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
