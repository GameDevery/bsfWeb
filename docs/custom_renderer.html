<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - Creating a renderer plugin</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='https://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Creating a renderer plugin </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#renderer_a">Components and the renderer</a></li>
<li class="level1"><a href="#renderer_b">Renderer plugin interface</a><ul><li class="level2"><a href="#renderer_b_a">Scene state notifications</a></li>
<li class="level2"><a href="#renderer_b_b">Rendering</a></li>
<li class="level2"><a href="#renderer_b_c">Name</a></li>
<li class="level2"><a href="#renderer_b_d">Extensions</a></li>
</ul>
</li>
<li class="level1"><a href="#renderer_c">Utilities</a><ul><li class="level2"><a href="#renderer_c_a">RendererUtility</a></li>
<li class="level2"><a href="#renderer_c_b">Render queue</a></li>
<li class="level2"><a href="#renderer_c_c">Renderer material</a><ul><li class="level3"><a href="#renderer_c_c_a">Variations</a></li>
<li class="level3"><a href="#renderer_c_c_b">Defines</a></li>
</ul>
</li>
<li class="level2"><a href="#renderer_c_d">Parameter blocks</a></li>
<li class="level2"><a href="#renderer_c_e">Renderer semantics</a></li>
<li class="level2"><a href="#renderer_c_f">GpuResourcePool</a></li>
<li class="level2"><a href="#renderer_c_g">Renderer options</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>If your project requires a very specific form of rendering you might decide you want to write your own renderer from scratch. In bs::f renderers are built as plugins, and this manual will show you how to create one. This manual can also be useful if trying to understand how the renderer works, even if you are not implementing your own.</p>
<h1><a class="anchor" id="renderer_a"></a>
Components and the renderer</h1>
<p>We've already shown how to render scene objects. You create a <b>SceneObject</b> on which you then attach components such as <b>CCamera</b>, <b>CRenderable</b> or <b>CLight</b>. These components will then register themselves with the renderer, when takes care of everything else rendering-wise.</p>
<p>Renderer isn't actually aware of scene objects and components, and instead operates on lower level objects owned by those components. For example <b>CCamera</b> component internally owns a <a class="el" href="classbs_1_1_camera.html">Camera</a> object, and <b>CRenderable</b> component internally owns a <a class="el" href="classbs_1_1_renderable.html">Renderable</a> object. As a general rule the non-component versions are named the same, without the "C" prefix. Their interface is very similar to their component versions.</p>
<p>All such lower level objects used by the renderer are also <b>CoreObject</b>s, meaning they have both a simulation and a core thread counterparts.</p>
<h1><a class="anchor" id="renderer_b"></a>
Renderer plugin interface</h1>
<p>To create your own renderer you must implement the <a class="el" href="classbs_1_1ct_1_1_renderer.html">ct::Renderer</a> interface. Renderer executes on the core thread, although there are a few simulation thread methods we'll note specifically.</p>
<h2><a class="anchor" id="renderer_b_a"></a>
Scene state notifications</h2>
<p>Majority of the renderer interface consists of methods that notify the renderer when certain objects are added, updated or removed from the scene. The types of objects that the renderer cares about are:</p><ul>
<li><a class="el" href="classbs_1_1_camera.html">Camera</a></li>
<li><a class="el" href="classbs_1_1_renderable.html">Renderable</a></li>
<li><a class="el" href="classbs_1_1_light.html">Light</a></li>
<li><a class="el" href="classbs_1_1_reflection_probe.html">ReflectionProbe</a></li>
<li><a class="el" href="classbs_1_1_skybox.html">Skybox</a></li>
<li><a class="el" href="classbs_1_1_light_probe_volume.html">LightProbeVolume</a></li>
</ul>
<p>Whenever such objects are created, destroyed or some property on them is updated, one of the following methods is called:</p><ul>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#ac5c37cf831b5951a833c949af61d8580">ct::Renderer::notifyCameraAdded()</a> - Called when a new <b>Camera</b> is created (e.g. when a <b>CCamera</b> component is added to the scene).</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#a08ee4db5b34bddbc8ca8bdff0d33fbb8">ct::Renderer::notifyCameraUpdated()</a> - Called when <b>Camera</b> position, rotation or scale changes.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#a776a5c722146df6f34b48123cc8ab300">ct::Renderer::notifyCameraRemoved()</a> - Called when a <b>Camera</b> is destroyed.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#ad0b2d12f66e3d982ea9ff91094b783d6">ct::Renderer::notifyRenderableAdded()</a> - Called when a new <b>Renderable</b> is created (e.g. when a <b>CRenderable</b> component is added to the scene).</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#a63ee590f7a8cf23e23be70bfc58be5d1">ct::Renderer::notifyRenderableUpdated()</a> - Called when <b>Renderable</b> position, rotation or scale changes.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#a8ae83c68b935022a6972c8d794f7d49d">ct::Renderer::notifyRenderableRemoved()</a> - Called when a <b>Renderable</b> is destroyed.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#a59dbc00b288b18804ae92fa9127a73d6">ct::Renderer::notifyLightAdded()</a> - Called when a new <b>Light</b> is created (e.g. when a <b>CLight</b> component is added to the scene).</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#a65836e2f93744c279a4399db0701ce2b">ct::Renderer::notifyLightUpdated()</a> - Called when <b>Light</b> position, rotation or scale changes.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#a5a98edf24ae0287f8fa4ff27634cbe57">ct::Renderer::notifyLightRemoved()</a> - Called when a <b>Light</b> is destroyed.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#aeac99d3307107e6f048373743b5c8ea1">ct::Renderer::notifyReflectionProbeAdded()</a> - Called when a new <b>ReflectionProbe</b> is created (e.g. when a <b>CReflectionProbe</b> component is added to the scene).</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#a5b047cc274cfcbeab1a6ade8d3e3ac34">ct::Renderer::notifyReflectionProbeUpdated()</a> - Called when <b>ReflectionProbe</b> position, rotation or scale changes.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#ad51d1f386f75ea7ad8fe6f5675879a2a">ct::Renderer::notifyReflectionProbeRemoved()</a> - Called when a <b>ReflectionProbe</b> is destroyed.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#a1486739d3eccaea0baf8e9b2c8e649d9">ct::Renderer::notifySkyboxAdded()</a> - Called when a new <b>Skybox</b> is created (e.g. when a <b>CSkybox</b> component is added to the scene).</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#ae522d132efd5b87f5e5e1fa2ace23e62">ct::Renderer::notifySkyboxRemoved()</a> - Called when a <b>Skybox</b> is destroyed.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#a1e4fca0a0a93bf5f3f0e2100b91046d7">ct::Renderer::notifyLightProbeVolumeAdded()</a> - Called when a new <b>LightProbeVolume</b> is created (e.g. when a <b>CLightProbeVolume</b> component is added to the scene).</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#adaf2d60bde47bcd80e5d52a1067b4b5f">ct::Renderer::notifyLightProbeVolumeUpdated()</a> - Called when probes are added or modified in a <b>LightProbeVolume</b>.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer.html#a5cb19186bba36f44a7dbe8368931c2e7">ct::Renderer::notifyLightProbeVolumeRemoved()</a> - Called when a <b>LightProbeVolume</b> is destroyed.</li>
</ul>
<p>Your renderer implementation can choose to implement some or all of those methods. By implementing these methods your renderer implementation is expected to keep track of the scene state, and then use that scene state for rendering. For example most renderers will at least need to keep track of all active cameras and renderable objects.</p>
<p>Note that *Added/*Removed methods don't only get called on object creation/destruction. If some major property of the object changes (e.g. a mesh or a material on a <b>Renderable</b>), the system will call <b>ct::Renderer::notifyRenderableRemoved()</b> followed by a call to <b>ct::Renderer::notifyRenderableAdded()</b>.</p>
<h2><a class="anchor" id="renderer_b_b"></a>
Rendering</h2>
<p>Aside from keeping track of the state of the scene your renderer must also implement <a class="el" href="classbs_1_1ct_1_1_renderer.html#acd06dab5f0b66565c8b014a37f629488">ct::Renderer::renderAll()</a>. This method will be called every frame and it is the starting point for all rendering. Note that this method gets called from the simulation thread, and you are expected to manually launch rendering on the core thread.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyRenderer : <span class="keyword">public</span> Renderer</div><div class="line">{</div><div class="line">    <span class="comment">// ... other renderer methods</span></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> renderAll() </div><div class="line">    {</div><div class="line">        <span class="comment">// ... do any sim thread operations if required ...</span></div><div class="line"></div><div class="line">        <span class="comment">// Queue rendering</span></div><div class="line">        <a class="code" href="group___core_thread-_internal.html#gaef7ed693951fb3ecc75209447cf4dc63">gCoreThread</a>().<a class="code" href="classbs_1_1_core_thread.html#a1ec463e396b7c6d278917a73202037ce">queueCommand</a>(std::bind(&amp;MyRenderer::renderAllCore, <span class="keyword">this</span>));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> renderAllCore()</div><div class="line">    {</div><div class="line">        <span class="comment">// ... iterate over all cameras and renderables, call RenderAPI and other low-level rendering methods to actually render something ...</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>The implementation of your rendering method should iterate over all renderable objects, cameras, lights or other provided objects (depending on what kind of rendering you wish to do). The rendering happens through the low-level rendering API as described in earlier manuals. At the end of rendering, every render target in every active camera should be filled with an image of the rendered scene. During rendering you should consider mesh and material set on renderable objects, and optionally apply lighting, special or post-processing effects as needed.</p>
<h2><a class="anchor" id="renderer_b_c"></a>
Name</h2>
<p>You are required to give your renderer a name by overriding <a class="el" href="classbs_1_1ct_1_1_renderer.html#a293c9f17a04b517323dcab8d267ad62e">ct::Renderer::getName()</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyRenderer : <span class="keyword">public</span> Renderer</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> StringID&amp; MyRenderer::getName()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keyword">static</span> StringID name = <span class="stringliteral">&quot;MyRenderer&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span> name;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// ... other renderer methods</span></div><div class="line">};</div></div><!-- fragment --><p>At this point your renderer is ready for use, but there is still various optional functionality to cover.</p>
<h2><a class="anchor" id="renderer_b_d"></a>
Extensions</h2>
<p>We talked about how to implement renderer extensions in the previous chapter. But if you are implementing your own renderer you need to process those extensions during the rendering process. You may also choose to ignore extensions and not render them at all.</p>
<p>All registered extensions are part of the <b>Renderer::mCallbacks</b> field. You can choose to iterate over them and execute them as needed.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyRenderer : <span class="keyword">public</span> Renderer</div><div class="line">{</div><div class="line">    <span class="comment">// ... other renderer methods</span></div><div class="line"></div><div class="line">    <span class="comment">// Performs rendering for a single camera, on the core thread</span></div><div class="line">    <span class="keywordtype">void</span> render(<span class="keyword">const</span> SPtr&lt;Camera&gt;&amp; camera)</div><div class="line">    {</div><div class="line">        <span class="comment">// Render pre-base pass extensions</span></div><div class="line">        <span class="keyword">auto</span> iter = mCallbacks.begin();</div><div class="line">        <span class="keywordflow">while</span> (iter != mCallbacks.end())</div><div class="line">        {</div><div class="line">            RendererExtension* extension = *iter;</div><div class="line">            <span class="keywordflow">if</span> (extension-&gt;getLocation() != RenderLocation::PreBasePass)</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (extension-&gt;check(*camera))</div><div class="line">                extension-&gt;render(*camera);</div><div class="line"></div><div class="line">            ++iter;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// ... do normal rendering and optionally call extensions registered for other locations ...</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><h1><a class="anchor" id="renderer_c"></a>
Utilities</h1>
<p>While what we have shown so far is enough to create a custom renderer, there are also a variety of utilities that can help out in the process. These systems aren't critical for renderer creation, but instead provide an easier way to perform commonly required functions.</p>
<h2><a class="anchor" id="renderer_c_a"></a>
RendererUtility</h2>
<p><a class="el" href="classbs_1_1ct_1_1_renderer_utility.html">ct::RendererUtility</a> provides some commonly required functionality for rendering. For the most part it provides methods that are wrappers around various <b>RenderAPI</b> methods described previously. It can be accessed globally through <a class="el" href="group___renderer-_engine-_internal.html#ga6580515aa43b883c40d15f1207618784">ct::gRendererUtility()</a> and the relevant methods are:</p><ul>
<li><a class="el" href="classbs_1_1ct_1_1_renderer_utility.html#a2bdc1aa82db4c8075246fb0e34e643e7">ct::RendererUtility::setPass()</a> - Binds a pass from a specific <b>Material</b> for rendering. Any further draw calls will be rendered using this pass.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer_utility.html#ac11986a742edb76d3de66ecd9fd5b0ec">ct::RendererUtility::setPassParams()</a> - Binds parameters (textures, samplers, etc.) from a <b>Material</b>, in the form of <b>GpuParamsSet</b>. Any further draw calls will be rendered using these parameters.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer_utility.html#a61f31136006238fc059438e92379d97b">ct::RendererUtility::draw()</a> - Draws a specific sub-mesh of the provided <b>ct::Mesh</b>, using the currently bound pass.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer_utility.html#a70e9add1b9fbe18088f9b839e2b3bbb1">ct::RendererUtility::blit()</a> - Copies the contents of the provided texture into the currently bound render target.</li>
<li><a class="el" href="classbs_1_1ct_1_1_renderer_utility.html#adcaaed632d7d017fdb21f0aa2829fbac">ct::RendererUtility::drawScreenQuad()</a> - Draws a quad covering the screen using the currently bound pass.</li>
</ul>
<div class="fragment"><div class="line">SPtr&lt;Material&gt; material = ...;</div><div class="line">SPtr&lt;Mesh&gt; mesh = ...;</div><div class="line">SPtr&lt;GpuParamsSet&gt; paramsSet = material-&gt;createParamsSet();</div><div class="line"></div><div class="line"><a class="code" href="group___renderer-_engine-_internal.html#ga6580515aa43b883c40d15f1207618784">gRendererUtility</a>().<a class="code" href="classbs_1_1ct_1_1_renderer_utility.html#a2bdc1aa82db4c8075246fb0e34e643e7">setPass</a>(material);</div><div class="line">... <span class="keyword">set</span> material parameters as normal ...</div><div class="line">gRendererUtility().setPassParams(paramsSet);</div><div class="line"><a class="code" href="group___renderer-_engine-_internal.html#ga6580515aa43b883c40d15f1207618784">gRendererUtility</a>().<a class="code" href="classbs_1_1ct_1_1_renderer_utility.html#a61f31136006238fc059438e92379d97b">draw</a>(mesh, mesh-&gt;getProperties().getSubMesh(0));</div></div><!-- fragment --><h2><a class="anchor" id="renderer_c_b"></a>
Render queue</h2>
<p><a class="el" href="classbs_1_1ct_1_1_render_queue.html">ct::RenderQueue</a> allows you to sort and group scene objects for rendering. For example transparent objects might need to be sorted back to front based on their distance from the camera. It is also often useful to group objects if they share the same material, to reduce state switching which can improve performance.</p>
<p>Use <a class="el" href="classbs_1_1ct_1_1_render_queue.html#a1ee7e181209962f742ec64f2d2768377">ct::RenderQueue::add()</a> to add new objects to the queue. It expects a <a class="el" href="classbs_1_1ct_1_1_renderable_element.html">ct::RenderableElement</a> which you can create from information provided by <b>Renderable</b> when <b>ct::Renderer::notifyRenderableAdded()</b> is called. Normally you wish to have a single <b>ct::RenderableElement</b> for each sub-mesh present in the renderable object's mesh.</p>
<p>Once all elements are in the queue, you can call <a class="el" href="classbs_1_1ct_1_1_render_queue.html#a0fff0459f3b9a2f1e3cad0549bc9c1cc">ct::RenderQueue::setStateReduction()</a> to select how to sort the objects:</p><ul>
<li><a class="el" href="group___renderer-_engine-_internal.html#gga63b53f91fc4a5dbba8e3266c305e9ca5a6adf97f83acf6453d4a6a4b1070f3754">ct::StateReduction::None</a> - Elements will be sorted by distance but no state reduction by material will occurr.</li>
<li><a class="el" href="group___renderer-_engine-_internal.html#gga63b53f91fc4a5dbba8e3266c305e9ca5ad92a8333dd3ccb895cc65f7455b71206">ct::StateReduction::Material</a> - Elements will be sorted by material first, then by distance.</li>
<li><a class="el" href="group___renderer-_engine-_internal.html#gga63b53f91fc4a5dbba8e3266c305e9ca5a0aa6f4210bf373c95eda00232e93cd98">ct::StateReduction::Distance</a> - Elements will be sorted by distance first, then by material.</li>
</ul>
<p>Once the state reduction mode is set call <a class="el" href="classbs_1_1ct_1_1_render_queue.html#aa484f63de36f7e9cb2727f5ffcdffd80">ct::RenderQueue::sort()</a>, and then <a class="el" href="classbs_1_1ct_1_1_render_queue.html#a713baa05cda8d8c5b1fa663f16b039f0">ct::RenderQueue::getSortedElements()</a> to retrieve a sorted list of render elements. The returned list contains a list of <a class="el" href="structbs_1_1ct_1_1_render_queue_element.html">ct::RenderQueueElement</a> which lets you know exactly which render element to render using which pass, and also tells you when a new pass needs to be applied.</p>
<p>For example: </p><div class="fragment"><div class="line">Vector&lt;RenderableElement*&gt; elements = ...; <span class="comment">// Fill this up from a list of renderables</span></div><div class="line"></div><div class="line">SPtr&lt;RenderQueue&gt; queue = bs_shared_ptr_new&lt;RenderQueue&gt;(StateReduction::Distance);</div><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; element : elements)</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> distance = ...; <span class="comment">// Calculate distance from element to camera, for sorting</span></div><div class="line">    queue-&gt;add(element, distance);</div><div class="line">}</div><div class="line"></div><div class="line">queue-&gt;sort();</div><div class="line"><span class="keyword">const</span> Vector&lt;RenderQueueElement&gt;&amp; sortedElements = queue-&gt;getSortedElements();</div><div class="line">... render sorted elements <span class="keyword">using</span> the low level rendering API ...</div></div><!-- fragment --><h2><a class="anchor" id="renderer_c_c"></a>
Renderer material</h2>
<p>Often the renderer needs to use special shaders for various effects (e.g. resolving lighting for a deferred renderer or post-processing effects like FXAA). Unlike shaders and materials used by renderable objects, these shaders are built into the engine. Since we know they'll always be there we can make it easier for the renderer to load and use them by implementing the <a class="el" href="classbs_1_1ct_1_1_renderer_material.html">ct::RendererMaterial&lt;T&gt;</a> interface.</p>
<p>The template parameter must be name of your material implementation class. The class must contain a <a class="el" href="group___renderer-_engine-_internal.html#ga123c43e083dd486ad5778e553788aafb">RMAT_DEF</a> macro which contains the filename of the shader the renderer material uses. The shader file should be present in the "Data/Raw/Engine/Shaders/" folder.</p>
<div class="fragment"><div class="line"><span class="comment">// Set up a post-processing material that downsamples some texture</span></div><div class="line"><span class="keyword">class </span>DownsampleMat : <span class="keyword">public</span> RendererMaterial&lt;DownsampleMat&gt;</div><div class="line">{</div><div class="line">    <span class="comment">// Required macro pointing to the shader file</span></div><div class="line">    <a class="code" href="group___renderer-_engine-_internal.html#ga123c43e083dd486ad5778e553788aafb">RMAT_DEF</a>(<span class="stringliteral">&quot;Downsample.bsl&quot;</span>);</div><div class="line">};</div></div><!-- fragment --><p>Once defined the renderer material can be accessed through the static <a class="el" href="classbs_1_1ct_1_1_renderer_material.html#a4bceffeb39618adbe625c9e48960aa11">ct::RendererMaterial::get&lt;T&gt;()</a> method.</p>
<div class="fragment"><div class="line">DownsampleMat* renderMat = DownsampleMat::get():</div></div><!-- fragment --><p>Once retrieved the object will contain the instance of the shader in the path you provided. Internally the material will provide you with a reference to either a graphics or compute pipeline state as <em>mGfxPipeline</em> and <em>mComputePipeline</em>, depending on the type of shader that was loaded. It will also provide you with <b>GpuParams</b> in the <em>mParams</em> field.</p>
<p>When the material is first created you will likely want to add a constructor in which you look up any necessary parameters the material might require, so they can be set more easily when rendering. </p><div class="fragment"><div class="line"><span class="keyword">class </span>DownsampleMat : <span class="keyword">public</span> RendererMaterial&lt;DownsampleMat&gt;</div><div class="line">{</div><div class="line">    <a class="code" href="group___renderer-_engine-_internal.html#ga123c43e083dd486ad5778e553788aafb">RMAT_DEF</a>(<span class="stringliteral">&quot;Downsample.bsl&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    DownsampleMat()</div><div class="line">    {</div><div class="line">        <span class="comment">// Retrieve material parameters, and optionally perform other set-up</span></div><div class="line">        mParams-&gt;getTextureParam(<a class="code" href="group___utility-_core.html#ggaf388801ddd39d30124c0da064556415aabc1cc2bb71a739e28f5787958adada1e">GPT_FRAGMENT_PROGRAM</a>, <span class="stringliteral">&quot;gInputTex&quot;</span>, mInputTexture);</div><div class="line">    }</div><div class="line"></div><div class="line">    GpuParamTexture mInputTexture;</div><div class="line">};</div></div><!-- fragment --><p>Often you can also create a method that binds the parameters, binds the material and executes the material all in one. This way external code doesn't need to do anything but to call it.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>DownsampleMat : <span class="keyword">public</span> RendererMaterial&lt;DownsampleMat&gt;</div><div class="line">{</div><div class="line">    <span class="comment">// ... other DownsampleMat code ...</span></div><div class="line"></div><div class="line">    <span class="comment">// Set up parameters and render a full screen quad using the material</span></div><div class="line">    <span class="keywordtype">void</span> execute(<span class="keyword">const</span> SPtr&lt;Texture&gt;&amp; input)</div><div class="line">    {</div><div class="line">        <span class="comment">// Assign parameters before rendering</span></div><div class="line">        mInputTexture.set(input);</div><div class="line"></div><div class="line">        bind();</div><div class="line">        <a class="code" href="group___renderer-_engine-_internal.html#ga6580515aa43b883c40d15f1207618784">gRendererUtility</a>().<a class="code" href="classbs_1_1ct_1_1_renderer_utility.html#adcaaed632d7d017fdb21f0aa2829fbac">drawScreenQuad</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// ... other DownsampleMat code ...</span></div><div class="line">};</div></div><!-- fragment --><p>Note that a helper method <a class="el" href="classbs_1_1ct_1_1_renderer_material.html#a1b454ff44ebcaab37f243b4f0de30105">ct::RendererMaterial::bind()</a> is provided, which will bind both the GPU pipeline and parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// External code wanting to run the material</span></div><div class="line">SPtr&lt;Texture&gt; inputTex = ...;</div><div class="line"></div><div class="line">DownsampleMat* renderMat = DownsampleMat::get():</div><div class="line">renderMat-&gt;execute(inputTex);</div></div><!-- fragment --><h3><a class="anchor" id="renderer_c_c_a"></a>
Variations</h3>
<p>If your BSL file contains shader variations, then you can call <a class="el" href="classbs_1_1ct_1_1_renderer_material.html#a095ba2457e49328778978a7741055e9d">ct::RendererMaterial::get&lt;T&gt;(const ShaderVariation&amp;)</a> to retrieve a specific variation. Variations were explained in more detail in the BSL manual.</p>
<div class="fragment"><div class="line"><span class="comment">// External code wanting to run a specific variation of the material</span></div><div class="line">SPtr&lt;Texture&gt; inputTex = ...;</div><div class="line"></div><div class="line"><span class="comment">// Get the variation that has HIGH_QUALITY define enabled</span></div><div class="line">ShaderVariation variation = ShaderVariation({</div><div class="line">    ShaderVariation::Param(<span class="stringliteral">&quot;HIGH_QUALITY&quot;</span>, <span class="keyword">true</span>)</div><div class="line">});</div><div class="line"></div><div class="line">DownsampleMat* renderMat = DownsampleMat::get(variation):</div><div class="line">renderMat-&gt;execute(inputTex);</div></div><!-- fragment --><p>Normally you will want to handle creation of various <a class="el" href="classbs_1_1_shader_variations.html">ShaderVariations</a> structures through a templated method, like so:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>DownsampleMat : <span class="keyword">public</span> RendererMaterial&lt;DownsampleMat&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> highQuality&gt;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> ShaderVariation&amp; getVariation()</div><div class="line">    {</div><div class="line">        <span class="keyword">static</span> ShaderVariation variation = ShaderVariation({</div><div class="line">            ShaderVariation::Param(<span class="stringliteral">&quot;HIGH_QUALITY&quot;</span>, highQuality)</div><div class="line">        });</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> variation;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// ... other DownsampleMat code ...</span></div><div class="line">};</div></div><!-- fragment --><p>Then you can also add a static <b>getVariation</b> method to hide these internals from the caller.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>DownsampleMat : <span class="keyword">public</span> RendererMaterial&lt;DownsampleMat&gt;</div><div class="line">{</div><div class="line">    <span class="comment">// ... other DownsampleMat code ...</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> DownsampleMat* getVariation(<span class="keywordtype">bool</span> highQuality)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span>(highQuality)</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">get</span>(getVariation&lt;true&gt;());</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">get</span>(getVariation&lt;false&gt;());</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Now the calling code can simply retrieve the variation it requires.</p>
<div class="fragment"><div class="line"><span class="comment">// External code wanting to run the high quality version of the material</span></div><div class="line">SPtr&lt;Texture&gt; inputTex = ...;</div><div class="line"></div><div class="line">DownsampleMat* renderMat = DownsampleMat::getVariation(<span class="keyword">true</span>):</div><div class="line">renderMat-&gt;execute(inputTex);</div></div><!-- fragment --><h3><a class="anchor" id="renderer_c_c_b"></a>
Defines</h3>
<p>Sometimes you wish to be able to dynamically control defines that are used to compile the shader code. This is particularily useful if you want to make sure your C++ code and shader code use the same value. To do this you need to create your material using the <a class="el" href="group___renderer-_engine-_internal.html#ga684d7a35a76a602f5e9271f87e2fcacc">RMAT_DEF_CUSTOMIZED</a> macro, instead of <b>RMAT_DEF</b>. It has the exact same signature as <b>RMAT_DEF</b> but it provides an *_initDefines* method you must implement.</p>
<p>The method receives a <a class="el" href="classbs_1_1_shader_defines.html">ShaderDefines</a> object which you can then populate with relevant values. Those values will then be used when compiling the shader.</p>
<div class="fragment"><div class="line">constxpr <span class="keyword">static</span> UINT32 TILE_WIDTH = 8;</div><div class="line">constxpr <span class="keyword">static</span> UINT32 TILE_HEIGHT = 8;</div><div class="line">constxpr <span class="keyword">static</span> UINT32 PIXELS_PER_THREAD = 4;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> IrradianceComputeSHMat::_initDefines(ShaderDefines&amp; defines)</div><div class="line">{</div><div class="line">    defines.set(<span class="stringliteral">&quot;TILE_WIDTH&quot;</span>, TILE_WIDTH);</div><div class="line">    defines.set(<span class="stringliteral">&quot;TILE_HEIGHT&quot;</span>, TILE_HEIGHT);</div><div class="line">    defines.set(<span class="stringliteral">&quot;PIXELS_PER_THREAD&quot;</span>, PIXELS_PER_THREAD);</div><div class="line">}</div></div><!-- fragment --><blockquote class="doxtable">
<p>All builtin shaders are cached. The system will automatically pick up any changes to shaders in <em>Data/Raw/Engine</em> folder and rebuild the cache when needed. However if you are changing defines as above you must manually force the system to rebuild by modifying the BSL file in <em>Data/Raw/Engine</em> folder. </p>
</blockquote>
<h2><a class="anchor" id="renderer_c_d"></a>
Parameter blocks</h2>
<p>In the <a class="el" href="gpu_programs.html">GPU programs</a> manual we talked about parameter block buffers, represented by <b>GpuParamBlockBuffer</b> class. These blocks are used for group data parameters (such as float, int or bool) into blocks that can then be efficiently bound to the pipeline. They are better known as uniform buffers in OpenGL/Vulkan, or constant buffers in DX11.</p>
<p>An example of such a buffer in HLSL looks like this: </p><div class="fragment"><div class="line"><span class="comment">// Contains various parameters specific to the current camera</span></div><div class="line">cbuffer PerCamera</div><div class="line">{</div><div class="line">    float3   gViewDir;</div><div class="line">    float3   gViewOrigin;</div><div class="line">    float4x4 gMatViewProj;</div><div class="line">    float4x4 gMatView;</div><div class="line">    float4x4 gMatProj;</div><div class="line">    float4x4 gMatInvProj;</div><div class="line">    float4x4 gMatInvViewProj;           </div><div class="line">}</div></div><!-- fragment --><p>Such parameter block buffers are primarily useful when you need to share the same data between multiple materials. Instead of accessing parametes individually through <b>Material</b> or <b>GpuParams</b>, you would instead create a <b>GpuParamBlockBuffer</b> object, populate it, and then bind to <b>Material</b> or <b>GpuParams</b>.</p>
<p>When we talked about them earlier we have shown how to manually create a <b>GpuParamBlockBuffer</b> object and write to it by reading the <b>GpuParamDesc</b> object of the <b>GpuProgram</b>. This is cumbersome and requires a lot of boilerplate code. A simpler way of creating and populating a parameter block is to use <a class="el" href="group___renderer-_internal.html#gaf5c357af5c921dcb11313ac4abbb0bd3">BS_PARAM_BLOCK_BEGIN</a>, <a class="el" href="group___renderer-_internal.html#gac3e84287768a037184a3f36f0206f85f">BS_PARAM_BLOCK_ENTRY</a> and <a class="el" href="group___renderer-_internal.html#ga95b07ed76685c320ac25d63c023aa0b1">BS_PARAM_BLOCK_END</a> macros. You simply define the parameter block structure using these macros in C++, to match the structure in HLSL/GLSL code.</p>
<div class="fragment"><div class="line"><a class="code" href="group___renderer-_internal.html#gaf5c357af5c921dcb11313ac4abbb0bd3">BS_PARAM_BLOCK_BEGIN</a>(PerCameraParamBlockDef)</div><div class="line">    <a class="code" href="group___renderer-_internal.html#gac3e84287768a037184a3f36f0206f85f">BS_PARAM_BLOCK_ENTRY</a>(Vector3, gViewDir)</div><div class="line">    <a class="code" href="group___renderer-_internal.html#gac3e84287768a037184a3f36f0206f85f">BS_PARAM_BLOCK_ENTRY</a>(Vector3, gViewOrigin)</div><div class="line">    <a class="code" href="group___renderer-_internal.html#gac3e84287768a037184a3f36f0206f85f">BS_PARAM_BLOCK_ENTRY</a>(Matrix4, gMatViewProj)</div><div class="line">    <a class="code" href="group___renderer-_internal.html#gac3e84287768a037184a3f36f0206f85f">BS_PARAM_BLOCK_ENTRY</a>(Matrix4, gMatView)</div><div class="line">    <a class="code" href="group___renderer-_internal.html#gac3e84287768a037184a3f36f0206f85f">BS_PARAM_BLOCK_ENTRY</a>(Matrix4, gMatProj)</div><div class="line">    <a class="code" href="group___renderer-_internal.html#gac3e84287768a037184a3f36f0206f85f">BS_PARAM_BLOCK_ENTRY</a>(Matrix4, gMatInvProj)</div><div class="line">    <a class="code" href="group___renderer-_internal.html#gac3e84287768a037184a3f36f0206f85f">BS_PARAM_BLOCK_ENTRY</a>(Matrix4, gMatInvViewProj)</div><div class="line"><a class="code" href="group___renderer-_internal.html#ga95b07ed76685c320ac25d63c023aa0b1">BS_PARAM_BLOCK_END</a></div></div><!-- fragment --><p>Once your parameter block definition is created, you can instantiate a parameter block buffer, assign values to it, and assign the blocks to materials, like so: </p><div class="fragment"><div class="line">PerCameraParamBlockDef def; <span class="comment">// Normally you want to make this global so it&#39;s instantiated only once</span></div><div class="line"></div><div class="line"><span class="comment">// Instantiates a new parameter block from the definition</span></div><div class="line">SPtr&lt;GpuParamBlockBuffer&gt; paramBlock = def.createBuffer(); </div><div class="line"></div><div class="line"><span class="comment">// Assign a value to the gViewDir parameter of the parameter block</span></div><div class="line">def.gViewDir.set(paramBlock, Vector3(0.707f, 0.707f, 0.0f));</div><div class="line">... <span class="keyword">set</span> other parameters in block ...</div><div class="line"></div><div class="line"><span class="comment">// Assign the parameter block to the material (optionally, assign to GpuParams if using them directly)</span></div><div class="line">SPtr&lt;<a class="code" href="group___renderer-_engine-_internal.html#gga63b53f91fc4a5dbba8e3266c305e9ca5ad92a8333dd3ccb895cc65f7455b71206">Material</a>&gt; material = ...;</div><div class="line">material-&gt;setParamBlockBuffer(<span class="stringliteral">&quot;PerCamera&quot;</span>, paramBlock);</div><div class="line"></div><div class="line">... render <span class="keyword">using</span> the material ...</div></div><!-- fragment --><p>Blocks are often used with renderer materials we described in the previous section, although we didn't use one in that example.</p>
<p>Note that by using this approach you lose all the error checking normally performed by <b>Material</b> or <b>GpuParams</b> when you are assigning parameters individually. You must make sure that the layout in C++ matches the layout in the GPU program. In case of GLSL you must also specify <code>layout(std140)</code> keyword to ensure its layout is compatible with C++ struct layout. You must also make sure that variable names match the names in the GPU program code.</p>
<h2><a class="anchor" id="renderer_c_e"></a>
Renderer semantics</h2>
<p>Renderer semantics allow user created shaders to request that certain parameters in a GPU program are populated by the renderer. They can be specified when defining shader parameters.</p>
<p>For example the user might request a "VP" semantic, which could be recognized by the renderer that the shader requests a view-projection matrix. Such a matrix is not something that the user should have to assign to the material himself. The renderer can choose to parse material parameters looking for supported semantics, and assign their values.</p>
<p>Ultimately whether the renderer chooses to parse the semantics or not is up to the renderer. Currently the default <em>RenderBeast</em> renderer does not make use of any semantics and instead maps parameters directly by using their name.</p>
<p>The semantics for each parameter can be accessed through the <b>Shader</b> object, which renderer needs to iterate through manually.</p>
<div class="fragment"><div class="line">StringID RPS_ViewProjTfrm = <span class="stringliteral">&quot;VP&quot;</span>; <span class="comment">// Define semantic identifier</span></div><div class="line"></div><div class="line">SPtr&lt;Material&gt; material = ...;</div><div class="line">SPtr&lt;Shader&gt; shader = material-&gt;getShader();</div><div class="line"><span class="keyword">auto</span>&amp; dataParams = shader-&gt;getDataParams();</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; entry : texParams)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (entry.second.rendererSemantic == RPS_ViewProjTfrm)</div><div class="line">    {</div><div class="line">        <span class="comment">// Found it, assign some value to the parameter</span></div><div class="line">        mMaterial-&gt;setMat4(entry.second.name, Matrix4::IDENTITY);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="renderer_c_f"></a>
GpuResourcePool</h2>
<p>Although you can create textures and buffers manually as described in the low level rendering API manual, <a class="el" href="classbs_1_1ct_1_1_gpu_resource_pool.html">ct::GpuResourcePool</a> provides a simpler and more efficient way of doing it. It will keep alive any referenced textures and buffers, so that other systems may re-use them if their size/formats match. This can improve performance when using many temporary/intermediary render textures (like in post-processing) or load-store buffers.</p>
<p>To request a render texture, first populate the <a class="el" href="structbs_1_1ct_1_1_p_o_o_l_e_d___r_e_n_d_e_r___t_e_x_t_u_r_e___d_e_s_c.html">ct::POOLED_RENDER_TEXTURE_DESC</a> descriptor, by calling any of <a class="el" href="structbs_1_1ct_1_1_p_o_o_l_e_d___r_e_n_d_e_r___t_e_x_t_u_r_e___d_e_s_c.html#a80c01b28905d5faf161a5fb5b84539a1">ct::POOLED_RENDER_TEXTURE_DESC::create2D()</a>, <a class="el" href="structbs_1_1ct_1_1_p_o_o_l_e_d___r_e_n_d_e_r___t_e_x_t_u_r_e___d_e_s_c.html#a77febc4501a6be4c7f4255834a272a93">ct::POOLED_RENDER_TEXTURE_DESC::create3D()</a> or <a class="el" href="structbs_1_1ct_1_1_p_o_o_l_e_d___r_e_n_d_e_r___t_e_x_t_u_r_e___d_e_s_c.html#a6556aaf60ef8f39d45e622d776710beb">ct::POOLED_RENDER_TEXTURE_DESC::createCube()</a>.</p>
<p>To request a buffer, populate the <a class="el" href="structbs_1_1ct_1_1_p_o_o_l_e_d___s_t_o_r_a_g_e___b_u_f_f_e_r___d_e_s_c.html">ct::POOLED_STORAGE_BUFFER_DESC</a> descriptor by calling either <a class="el" href="structbs_1_1ct_1_1_p_o_o_l_e_d___s_t_o_r_a_g_e___b_u_f_f_e_r___d_e_s_c.html#abc91f3daa1b2b01f670115d1603da7b3">ct::POOLED_STORAGE_BUFFER_DESC::createStandard()</a> or <a class="el" href="structbs_1_1ct_1_1_p_o_o_l_e_d___s_t_o_r_a_g_e___b_u_f_f_e_r___d_e_s_c.html#aae89c23a689fc0b751ec783adc47b7cb">ct::POOLED_STORAGE_BUFFER_DESC::createStructured()</a>.</p>
<p>Then call <a class="el" href="classbs_1_1ct_1_1_gpu_resource_pool.html#ae63bbc7991afb52ad16efc705532ca78">ct::GpuResourcePool::get()</a> with the provided descriptor. This will either create a new render texture/buffer, or return one from the pool. The returned object is <a class="el" href="structbs_1_1ct_1_1_pooled_render_texture.html">ct::PooledRenderTexture</a> for textures and <a class="el" href="structbs_1_1ct_1_1_pooled_storage_buffer.html">ct::PooledStorageBuffer</a> for buffers.</p>
<p>Once you are done using the texture or buffer, call <a class="el" href="classbs_1_1ct_1_1_gpu_resource_pool.html#a3f81579792bedbf0f84fece00f5f7eda">ct::GpuResourcePool::release()</a> to return the object to the pool, and make it available for other systems. If you plan on using this object again, make sure to keep a reference to the <b>ct::PooledRenderTexture</b> / <b>ct::PooledStorageBuffer</b> object. This will prevent the pool from fully destroying the object so it may be reused.</p>
<div class="fragment"><div class="line"><span class="comment">// An example creating a pooled render texture</span></div><div class="line">POOLED_RENDER_TEXTURE_DESC desc = POOLED_RENDER_TEXTURE_DESC::create2D(PF_R8G8B8A8, 1024, 1024, <a class="code" href="group___resources.html#ggac78ff90c8cbce819a61e65d1bb3d29f9a1451acea7839c632c5643bfe11fd1fc1">TU_RENDERTARGET</a>);</div><div class="line">SPtr&lt;PooledRenderTexture&gt; pooledRT = GpuResourcePool::instance().get(desc);</div><div class="line"></div><div class="line">RenderAPI::instance().setRenderTarget(pooledRT-&gt;renderTexture);</div><div class="line">... render to target ...</div><div class="line">GpuResourcePool::instance().release(pooledRT);</div><div class="line"><span class="comment">// Keep a reference to pooledRT if we plan on re-using it, then next time just call get() using the same descriptor</span></div></div><!-- fragment --><h2><a class="anchor" id="renderer_c_g"></a>
Renderer options</h2>
<p>You can customize your rendering at runtime by implementing the <a class="el" href="structbs_1_1ct_1_1_renderer_options.html">ct::RendererOptions</a> class. Your <b>ct::RendererOptions</b> implementation can then be assigned to the renderer by calling <a class="el" href="classbs_1_1ct_1_1_renderer.html#a303031c29552d85e55b8b0c971c5308e">ct::Renderer::setOptions()</a>, and accessed within the renderer via the <b>Renderer::mOptions</b> field. No default options are provided and it's up to your renderer to decide what it requires.</p>
<p>Be aware that options are set from the simulation thread, and if you want to use them on the core thread you need to either properly synchronize the access, or send a copy of the options to the core thread. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
