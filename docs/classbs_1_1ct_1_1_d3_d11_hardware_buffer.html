<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - D3D11HardwareBuffer Class Reference</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='https://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebs.html">bs</a></li><li class="navelem"><b>ct</b></li><li class="navelem"><a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html">D3D11HardwareBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Methods</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="classbs_1_1ct_1_1_d3_d11_hardware_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">D3D11HardwareBuffer Class Reference<div class="ingroups"><a class="el" href="group___plugins.html">Plugins</a> &raquo; <a class="el" href="group___d3_d11.html">BansheeD3D11RenderAPI</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Class containing common functionality for all DirectX 11 hardware buffers. </p>
</div>
<p>Inherits <a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Methods</h2></td></tr>
<tr class="memitem:af1a33b8328abf783ae742a16756f5fc3"><td class="memItemLeft" align="right" valign="top"><a id="af1a33b8328abf783ae742a16756f5fc3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>D3D11HardwareBuffer</b> (<a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#adf8e136713c0691010d2bec6ba63e9cf">BufferType</a> btype, <a class="el" href="group___utility-_core.html#ga5e1fc75453f659263ebfc0784abfdc57">GpuBufferUsage</a> usage, UINT32 elementCount, UINT32 elementSize, <a class="el" href="classbs_1_1ct_1_1_d3_d11_device.html">D3D11Device</a> &amp;device, bool systemMemory=false, bool streamOut=false, bool randomGpuWrite=false, bool useCounter=false)</td></tr>
<tr class="separator:af1a33b8328abf783ae742a16756f5fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e39463e9ce0f7d3875682503f0eb529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#a0e39463e9ce0f7d3875682503f0eb529">readData</a> (UINT32 offset, UINT32 length, void *dest, UINT32 deviceIdx=0, UINT32 queueIdx=0) override</td></tr>
<tr class="memdesc:a0e39463e9ce0f7d3875682503f0eb529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from a portion of the buffer and copies it to the destination buffer. <br />
  <a href="#a0e39463e9ce0f7d3875682503f0eb529">More...</a><br /></td></tr>
<tr class="separator:a0e39463e9ce0f7d3875682503f0eb529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ab1f124cb7354ab62b5453562f32a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#ac0ab1f124cb7354ab62b5453562f32a9">writeData</a> (UINT32 offset, UINT32 length, const void *source, <a class="el" href="group___utility-_core.html#gaa97ce01a8dbe96664979215009cc2c29">BufferWriteType</a> writeFlags=<a class="el" href="group___utility-_core.html#ggaa97ce01a8dbe96664979215009cc2c29ac9486c8284a168cdbce33184a6c34dff">BWT_NORMAL</a>, UINT32 queueIdx=0) override</td></tr>
<tr class="memdesc:ac0ab1f124cb7354ab62b5453562f32a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data into a portion of the buffer from the source memory. <br />
  <a href="#ac0ab1f124cb7354ab62b5453562f32a9">More...</a><br /></td></tr>
<tr class="separator:ac0ab1f124cb7354ab62b5453562f32a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e96b45491574ea98f700b18d8b0441"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#a94e96b45491574ea98f700b18d8b0441">copyData</a> (<a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;srcBuffer, UINT32 srcOffset, UINT32 dstOffset, UINT32 length, bool discardWholeBuffer=false, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a94e96b45491574ea98f700b18d8b0441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a specific portion of the source buffer into a specific portion of this buffer. <br />
  <a href="#a94e96b45491574ea98f700b18d8b0441">More...</a><br /></td></tr>
<tr class="separator:a94e96b45491574ea98f700b18d8b0441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b67b0d92dc422e154166fe3ba7dfc4c"><td class="memItemLeft" align="right" valign="top">ID3D11Buffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#a4b67b0d92dc422e154166fe3ba7dfc4c">getD3DBuffer</a> () const</td></tr>
<tr class="memdesc:a4b67b0d92dc422e154166fe3ba7dfc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal DX11 buffer object.  <a href="#a4b67b0d92dc422e154166fe3ba7dfc4c">More...</a><br /></td></tr>
<tr class="separator:a4b67b0d92dc422e154166fe3ba7dfc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classbs_1_1_hardware_buffer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classbs_1_1_hardware_buffer')"><img src="closed.png" alt="-"/>&#160;Methods inherited from <a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a></td></tr>
<tr class="memitem:a0cbc193b72c0af3780c5f354dd4c821f inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#a0cbc193b72c0af3780c5f354dd4c821f">lock</a> (UINT32 offset, UINT32 length, <a class="el" href="group___utility-_core.html#gab3f183d1c687b60796c72dda0073e2f3">GpuLockOptions</a> options, UINT32 deviceIdx=0, UINT32 queueIdx=0)</td></tr>
<tr class="memdesc:a0cbc193b72c0af3780c5f354dd4c821f inherit pub_methods_classbs_1_1_hardware_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks a portion of the buffer and returns pointer to the locked area.  <a href="classbs_1_1_hardware_buffer.html#a0cbc193b72c0af3780c5f354dd4c821f">More...</a><br /></td></tr>
<tr class="separator:a0cbc193b72c0af3780c5f354dd4c821f inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f10c4c910370528770f31eeb68937fe inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#a6f10c4c910370528770f31eeb68937fe">lock</a> (<a class="el" href="group___utility-_core.html#gab3f183d1c687b60796c72dda0073e2f3">GpuLockOptions</a> options, UINT32 deviceIdx=0, UINT32 queueIdx=0)</td></tr>
<tr class="memdesc:a6f10c4c910370528770f31eeb68937fe inherit pub_methods_classbs_1_1_hardware_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the entire buffer and returns pointer to the locked area.  <a href="classbs_1_1_hardware_buffer.html#a6f10c4c910370528770f31eeb68937fe">More...</a><br /></td></tr>
<tr class="separator:a6f10c4c910370528770f31eeb68937fe inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f018536d482152b993f522d8d2942d inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#ae6f018536d482152b993f522d8d2942d">unlock</a> ()</td></tr>
<tr class="memdesc:ae6f018536d482152b993f522d8d2942d inherit pub_methods_classbs_1_1_hardware_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on this buffer.  <a href="classbs_1_1_hardware_buffer.html#ae6f018536d482152b993f522d8d2942d">More...</a><br /></td></tr>
<tr class="separator:ae6f018536d482152b993f522d8d2942d inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2db96da569923dd85906763e9b92479 inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#af2db96da569923dd85906763e9b92479">copyData</a> (<a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;srcBuffer, UINT32 srcOffset, UINT32 dstOffset, UINT32 length, bool discardWholeBuffer=false, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">ct::CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:af2db96da569923dd85906763e9b92479 inherit pub_methods_classbs_1_1_hardware_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a specific portion of the source buffer into a specific portion of this buffer.  <a href="classbs_1_1_hardware_buffer.html#af2db96da569923dd85906763e9b92479">More...</a><br /></td></tr>
<tr class="separator:af2db96da569923dd85906763e9b92479 inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e45e589fe2a5541b6f0d410bb310fe8 inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#a5e45e589fe2a5541b6f0d410bb310fe8">copyData</a> (<a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;srcBuffer, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">ct::CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)</td></tr>
<tr class="memdesc:a5e45e589fe2a5541b6f0d410bb310fe8 inherit pub_methods_classbs_1_1_hardware_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the provided buffer into this buffer.  <a href="classbs_1_1_hardware_buffer.html#a5e45e589fe2a5541b6f0d410bb310fe8">More...</a><br /></td></tr>
<tr class="separator:a5e45e589fe2a5541b6f0d410bb310fe8 inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee07b35f394554713293253d46e4260d inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#aee07b35f394554713293253d46e4260d">getSize</a> () const</td></tr>
<tr class="memdesc:aee07b35f394554713293253d46e4260d inherit pub_methods_classbs_1_1_hardware_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of this buffer in bytes.  <a href="classbs_1_1_hardware_buffer.html#aee07b35f394554713293253d46e4260d">More...</a><br /></td></tr>
<tr class="separator:aee07b35f394554713293253d46e4260d inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43966e19963e4bcb7f7f9b5327ec732b inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#a43966e19963e4bcb7f7f9b5327ec732b">isLocked</a> () const</td></tr>
<tr class="memdesc:a43966e19963e4bcb7f7f9b5327ec732b inherit pub_methods_classbs_1_1_hardware_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this buffer is currently locked.  <a href="classbs_1_1_hardware_buffer.html#a43966e19963e4bcb7f7f9b5327ec732b">More...</a><br /></td></tr>
<tr class="separator:a43966e19963e4bcb7f7f9b5327ec732b inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adf8e136713c0691010d2bec6ba63e9cf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#adf8e136713c0691010d2bec6ba63e9cf">BufferType</a> { <br />
&#160;&#160;<a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#adf8e136713c0691010d2bec6ba63e9cfaa4dda2f5cdf01ff99ec40c19216ce277">BT_VERTEX</a> = 0x1, 
<a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#adf8e136713c0691010d2bec6ba63e9cfa8d0bf06210b11988167d266d10e66093">BT_INDEX</a> = 0x2, 
<a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#adf8e136713c0691010d2bec6ba63e9cfa7c691df89301c20c7f14aa5be63852dc">BT_CONSTANT</a> = 0x4, 
<a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#adf8e136713c0691010d2bec6ba63e9cfaf28e8e5c991dcc90109787327301d843">BT_GROUP_GENERIC</a> = 0x8, 
<br />
&#160;&#160;<a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#adf8e136713c0691010d2bec6ba63e9cfa367391c81639e6b5945bd04e3dab93b2">BT_STRUCTURED</a> = BT_GROUP_GENERIC | 0x10, 
<a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#adf8e136713c0691010d2bec6ba63e9cfa47a283db7221e69a7b11b86228e27dc2">BT_RAW</a> = BT_GROUP_GENERIC | 0x20, 
<a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#adf8e136713c0691010d2bec6ba63e9cfa483c00db75bb688e1b32cebe02fe52ef">BT_INDIRECTARGUMENT</a> = BT_GROUP_GENERIC | 0x40, 
<a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#adf8e136713c0691010d2bec6ba63e9cfae8445fa0bcaef0545675800748a486fc">BT_APPENDCONSUME</a> = BT_GROUP_GENERIC | 0x80, 
<br />
&#160;&#160;<a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#adf8e136713c0691010d2bec6ba63e9cfab40b3804deba72eb78b92cf77d3f3b64">BT_STANDARD</a> = BT_GROUP_GENERIC | 0x100
<br />
 }</td></tr>
<tr class="memdesc:adf8e136713c0691010d2bec6ba63e9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available types of DX11 buffers.  <a href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#adf8e136713c0691010d2bec6ba63e9cf">More...</a><br /></td></tr>
<tr class="separator:adf8e136713c0691010d2bec6ba63e9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Method documentation</h2>
<a id="a94e96b45491574ea98f700b18d8b0441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e96b45491574ea98f700b18d8b0441">&#9670;&nbsp;</a></span>copyData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>srcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>dstOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discardWholeBuffer</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a specific portion of the source buffer into a specific portion of this buffer. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBuffer</td><td>Buffer to copy from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcOffset</td><td>Offset into the source buffer to start copying from, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstOffset</td><td>Offset into this buffer to start copying to, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Size of the data to copy, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discardWholeBuffer</td><td>Specify true if the data in the current buffer can be entirely discarded. This may improve performance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Command buffer to queue the copy operation on. If null, main command buffer is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b67b0d92dc422e154166fe3ba7dfc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b67b0d92dc422e154166fe3ba7dfc4c">&#9670;&nbsp;</a></span>getD3DBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ID3D11Buffer* getD3DBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the internal DX11 buffer object. </p>

</div>
</div>
<a id="aa3e703d2f1b77e2483451a0950aff082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e703d2f1b77e2483451a0950aff082">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* map </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gab3f183d1c687b60796c72dda0073e2f3">GpuLockOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>deviceIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>queueIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks a portion of the buffer and returns pointer to the locked area. <br />
 <br />
 </p>
<p>You must call <a class="el" href="classbs_1_1_hardware_buffer.html#ae6f018536d482152b993f522d8d2942d" title="Releases the lock on this buffer. ">unlock()</a> when done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes from which to lock the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the area you want to lock, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Signifies what you want to do with the returned pointer. Caller must ensure not to do anything he hasn't requested (for example don't try to read from the buffer unless you requested it here). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceIdx</td><td>Index of the device whose memory to map. If the buffer doesn't exist on this device, the method returns null. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueIdx</td><td>Device queue to perform any read/write operations on. See <a class="el" href="queues_doc.html">Device queues</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classbs_1_1_hardware_buffer.html#afaf76c7aeec7b89f59488046d23e9253">HardwareBuffer</a>.</p>

</div>
</div>
<a id="a0e39463e9ce0f7d3875682503f0eb529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e39463e9ce0f7d3875682503f0eb529">&#9670;&nbsp;</a></span>readData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void readData </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>deviceIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>queueIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from a portion of the buffer and copies it to the destination buffer. <br />
 </p>
<p>Caller must ensure destination buffer is large enough.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes from which to copy the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the area you want to copy, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Destination buffer large enough to store the read data. Data is written from the start of the buffer (<code>offset</code> is only applied to the source). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceIdx</td><td>Index of the device whose memory to read. If the buffer doesn't exist on this device, no data will be read. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueIdx</td><td>Device queue to perform the read operation on. See <a class="el" href="queues_doc.html">Device queues</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1_hardware_buffer.html#a533ab13e635c42121fec740dc7b695cc">HardwareBuffer</a>.</p>

</div>
</div>
<a id="a7deff0e432f0883942948c55c12673d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7deff0e432f0883942948c55c12673d2">&#9670;&nbsp;</a></span>unmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unmap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock on this buffer. <br />
 <br />
 </p>

<p>Reimplemented from <a class="el" href="classbs_1_1_hardware_buffer.html#a4c528e19a2cbd1b9a315a3db6fdcacdc">HardwareBuffer</a>.</p>

</div>
</div>
<a id="ac0ab1f124cb7354ab62b5453562f32a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ab1f124cb7354ab62b5453562f32a9">&#9670;&nbsp;</a></span>writeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeData </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gaa97ce01a8dbe96664979215009cc2c29">BufferWriteType</a>&#160;</td>
          <td class="paramname"><em>writeFlags</em> = <code><a class="el" href="group___utility-_core.html#ggaa97ce01a8dbe96664979215009cc2c29ac9486c8284a168cdbce33184a6c34dff">BWT_NORMAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>queueIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data into a portion of the buffer from the source memory. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes from which to copy the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the area you want to copy, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source buffer containing the data to write. Data is read from the start of the buffer (<code>offset</code> is only applied to the destination). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">writeFlags</td><td>Optional write flags that may affect performance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueIdx</td><td>Device queue to perform the write operation on. See <a class="el" href="queues_doc.html">Device queues</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1_hardware_buffer.html#aed63b4da7c915f4b42e08824c4e60020">HardwareBuffer</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="adf8e136713c0691010d2bec6ba63e9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8e136713c0691010d2bec6ba63e9cf">&#9670;&nbsp;</a></span>BufferType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#adf8e136713c0691010d2bec6ba63e9cf">BufferType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available types of DX11 buffers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adf8e136713c0691010d2bec6ba63e9cfaa4dda2f5cdf01ff99ec40c19216ce277"></a>BT_VERTEX&#160;</td><td class="fielddoc"><p>Contains geometry vertices and their properties. </p>
</td></tr>
<tr><td class="fieldname"><a id="adf8e136713c0691010d2bec6ba63e9cfa8d0bf06210b11988167d266d10e66093"></a>BT_INDEX&#160;</td><td class="fielddoc"><p>Contains triangle to vertex mapping. </p>
</td></tr>
<tr><td class="fieldname"><a id="adf8e136713c0691010d2bec6ba63e9cfa7c691df89301c20c7f14aa5be63852dc"></a>BT_CONSTANT&#160;</td><td class="fielddoc"><p>Contains GPU program parameters. </p>
</td></tr>
<tr><td class="fieldname"><a id="adf8e136713c0691010d2bec6ba63e9cfaf28e8e5c991dcc90109787327301d843"></a>BT_GROUP_GENERIC&#160;</td><td class="fielddoc"><p>Special value signifying a buffer is of generic type. </p>
<p>Not an actual buffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="adf8e136713c0691010d2bec6ba63e9cfa367391c81639e6b5945bd04e3dab93b2"></a>BT_STRUCTURED&#160;</td><td class="fielddoc"><p>Generic buffer that holds one or more user-defined structures laid out sequentially. </p>
</td></tr>
<tr><td class="fieldname"><a id="adf8e136713c0691010d2bec6ba63e9cfa47a283db7221e69a7b11b86228e27dc2"></a>BT_RAW&#160;</td><td class="fielddoc"><p>Generic buffer that holds raw block of bytes with no defined structure. </p>
</td></tr>
<tr><td class="fieldname"><a id="adf8e136713c0691010d2bec6ba63e9cfa483c00db75bb688e1b32cebe02fe52ef"></a>BT_INDIRECTARGUMENT&#160;</td><td class="fielddoc"><p>Generic buffer that is used for holding parameters used for indirect rendering. </p>
</td></tr>
<tr><td class="fieldname"><a id="adf8e136713c0691010d2bec6ba63e9cfae8445fa0bcaef0545675800748a486fc"></a>BT_APPENDCONSUME&#160;</td><td class="fielddoc"><p>Generic buffer that allows the GPU program to use append/consume functionality. </p>
</td></tr>
<tr><td class="fieldname"><a id="adf8e136713c0691010d2bec6ba63e9cfab40b3804deba72eb78b92cf77d3f3b64"></a>BT_STANDARD&#160;</td><td class="fielddoc"><p>Generic buffer that contains primitive types. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
