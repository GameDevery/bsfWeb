<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - Physics Class Reference</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='http://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="../SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="../SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebs.html">bs</a></li><li class="navelem"><a class="el" href="classbs_1_1_physics.html">Physics</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Methods</a> &#124;
<a href="#pub-static-attribs">Static fields</a> &#124;
<a href="classbs_1_1_physics-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Physics Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___layers.html">Layers</a> &raquo; <a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___physics.html">Physics</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Provides global physics settings, factory methods for physics objects and scene queries. </p>
</div>
<p>Inherits <a class="el" href="classbs_1_1_module.html">Module&lt; Physics &gt;</a>.</p>

<p>Inherited by <a class="el" href="classbs_1_1_phys_x.html">PhysX</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Methods</h2></td></tr>
<tr class="memitem:a4922c406790f63ea55fb290063b2937b"><td class="memItemLeft" align="right" valign="top"><a id="a4922c406790f63ea55fb290063b2937b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Physics</b> (const <a class="el" href="structbs_1_1_p_h_y_s_i_c_s___i_n_i_t___d_e_s_c.html">PHYSICS_INIT_DESC</a> &amp;init)</td></tr>
<tr class="separator:a4922c406790f63ea55fb290063b2937b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332ecaffb2c30182194598e779c655af"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a332ecaffb2c30182194598e779c655af">rayCast</a> (const <a class="el" href="classbs_1_1_ray.html">Ray</a> &amp;ray, <a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;hit, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const</td></tr>
<tr class="memdesc:a332ecaffb2c30182194598e779c655af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a ray into the scene and returns the closest found hit, if any.  <a href="#a332ecaffb2c30182194598e779c655af">More...</a><br /></td></tr>
<tr class="separator:a332ecaffb2c30182194598e779c655af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f37047d0e9c940fe952665cb232623c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a9f37047d0e9c940fe952665cb232623c">rayCast</a> (const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;origin, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, <a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;hit, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:a9f37047d0e9c940fe952665cb232623c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a ray into the scene and returns the closest found hit, if any.  <a href="#a9f37047d0e9c940fe952665cb232623c">More...</a><br /></td></tr>
<tr class="separator:a9f37047d0e9c940fe952665cb232623c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65530fa7f84c8433c97c6156508a393c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a65530fa7f84c8433c97c6156508a393c">boxCast</a> (const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;box, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, <a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;hit, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:a65530fa7f84c8433c97c6156508a393c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep into the scene using a box and returns the closest found hit, if any.  <a href="#a65530fa7f84c8433c97c6156508a393c">More...</a><br /></td></tr>
<tr class="separator:a65530fa7f84c8433c97c6156508a393c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fde7a33afd071121717a00618dd78d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a52fde7a33afd071121717a00618dd78d">sphereCast</a> (const <a class="el" href="classbs_1_1_sphere.html">Sphere</a> &amp;sphere, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, <a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;hit, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:a52fde7a33afd071121717a00618dd78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep into the scene using a sphere and returns the closest found hit, if any.  <a href="#a52fde7a33afd071121717a00618dd78d">More...</a><br /></td></tr>
<tr class="separator:a52fde7a33afd071121717a00618dd78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84333aa0e3c3d4ceea244811a5475a7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#ae84333aa0e3c3d4ceea244811a5475a7">capsuleCast</a> (const <a class="el" href="classbs_1_1_capsule.html">Capsule</a> &amp;capsule, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, <a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;hit, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:ae84333aa0e3c3d4ceea244811a5475a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep into the scene using a capsule and returns the closest found hit, if any.  <a href="#ae84333aa0e3c3d4ceea244811a5475a7">More...</a><br /></td></tr>
<tr class="separator:ae84333aa0e3c3d4ceea244811a5475a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fadc40665d13a887c0999d1ed3bf71"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a45fadc40665d13a887c0999d1ed3bf71">convexCast</a> (const <a class="el" href="classbs_1_1_t_resource_handle.html">HPhysicsMesh</a> &amp;mesh, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;position, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, <a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;hit, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:a45fadc40665d13a887c0999d1ed3bf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep into the scene using a convex mesh and returns the closest found hit, if any.  <a href="#a45fadc40665d13a887c0999d1ed3bf71">More...</a><br /></td></tr>
<tr class="separator:a45fadc40665d13a887c0999d1ed3bf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66788e208459a45aa4a0bc3731a3b851"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a66788e208459a45aa4a0bc3731a3b851">rayCastAll</a> (const <a class="el" href="classbs_1_1_ray.html">Ray</a> &amp;ray, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const</td></tr>
<tr class="memdesc:a66788e208459a45aa4a0bc3731a3b851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a ray into the scene and returns all found hits.  <a href="#a66788e208459a45aa4a0bc3731a3b851">More...</a><br /></td></tr>
<tr class="separator:a66788e208459a45aa4a0bc3731a3b851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c8acc7645a9ca3bc9092a077d8200d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#ab9c8acc7645a9ca3bc9092a077d8200d">rayCastAll</a> (const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;origin, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:ab9c8acc7645a9ca3bc9092a077d8200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a ray into the scene and returns all found hits.  <a href="#ab9c8acc7645a9ca3bc9092a077d8200d">More...</a><br /></td></tr>
<tr class="separator:ab9c8acc7645a9ca3bc9092a077d8200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fbd0def22d8d9862fc9f27bcf6fbb5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a73fbd0def22d8d9862fc9f27bcf6fbb5">boxCastAll</a> (const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;box, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:a73fbd0def22d8d9862fc9f27bcf6fbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep into the scene using a box and returns all found hits.  <a href="#a73fbd0def22d8d9862fc9f27bcf6fbb5">More...</a><br /></td></tr>
<tr class="separator:a73fbd0def22d8d9862fc9f27bcf6fbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eef3c95d40f83a5b654f134f4155d49"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a1eef3c95d40f83a5b654f134f4155d49">sphereCastAll</a> (const <a class="el" href="classbs_1_1_sphere.html">Sphere</a> &amp;sphere, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:a1eef3c95d40f83a5b654f134f4155d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep into the scene using a sphere and returns all found hits.  <a href="#a1eef3c95d40f83a5b654f134f4155d49">More...</a><br /></td></tr>
<tr class="separator:a1eef3c95d40f83a5b654f134f4155d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad277e707642b7b121d47743232ff3431"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#ad277e707642b7b121d47743232ff3431">capsuleCastAll</a> (const <a class="el" href="classbs_1_1_capsule.html">Capsule</a> &amp;capsule, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:ad277e707642b7b121d47743232ff3431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep into the scene using a capsule and returns all found hits.  <a href="#ad277e707642b7b121d47743232ff3431">More...</a><br /></td></tr>
<tr class="separator:ad277e707642b7b121d47743232ff3431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad688c1691481352edacd4942dfd1ce88"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#ad688c1691481352edacd4942dfd1ce88">convexCastAll</a> (const <a class="el" href="classbs_1_1_t_resource_handle.html">HPhysicsMesh</a> &amp;mesh, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;position, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:ad688c1691481352edacd4942dfd1ce88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep into the scene using a convex mesh and returns all found hits.  <a href="#ad688c1691481352edacd4942dfd1ce88">More...</a><br /></td></tr>
<tr class="separator:ad688c1691481352edacd4942dfd1ce88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe88ffedf2b09aea3919b3ea298cdd09"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#abe88ffedf2b09aea3919b3ea298cdd09">rayCastAny</a> (const <a class="el" href="classbs_1_1_ray.html">Ray</a> &amp;ray, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const</td></tr>
<tr class="memdesc:abe88ffedf2b09aea3919b3ea298cdd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a ray into the scene and checks if it has hit anything.  <a href="#abe88ffedf2b09aea3919b3ea298cdd09">More...</a><br /></td></tr>
<tr class="separator:abe88ffedf2b09aea3919b3ea298cdd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3faea625c226566c616cb598353339e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#af3faea625c226566c616cb598353339e">rayCastAny</a> (const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;origin, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:af3faea625c226566c616cb598353339e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a ray into the scene and checks if it has hit anything.  <a href="#af3faea625c226566c616cb598353339e">More...</a><br /></td></tr>
<tr class="separator:af3faea625c226566c616cb598353339e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f66d1eb091d363b506b463c94025148"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a1f66d1eb091d363b506b463c94025148">boxCastAny</a> (const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;box, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:a1f66d1eb091d363b506b463c94025148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep into the scene using a box and checks if it has hit anything.  <a href="#a1f66d1eb091d363b506b463c94025148">More...</a><br /></td></tr>
<tr class="separator:a1f66d1eb091d363b506b463c94025148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade83fa0108f9c49443d424331c3d8c5c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#ade83fa0108f9c49443d424331c3d8c5c">sphereCastAny</a> (const <a class="el" href="classbs_1_1_sphere.html">Sphere</a> &amp;sphere, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:ade83fa0108f9c49443d424331c3d8c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep into the scene using a sphere and checks if it has hit anything.  <a href="#ade83fa0108f9c49443d424331c3d8c5c">More...</a><br /></td></tr>
<tr class="separator:ade83fa0108f9c49443d424331c3d8c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c35c2e9c7e83fe5a6c285b7f351cd6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#af4c35c2e9c7e83fe5a6c285b7f351cd6">capsuleCastAny</a> (const <a class="el" href="classbs_1_1_capsule.html">Capsule</a> &amp;capsule, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:af4c35c2e9c7e83fe5a6c285b7f351cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep into the scene using a capsule and checks if it has hit anything.  <a href="#af4c35c2e9c7e83fe5a6c285b7f351cd6">More...</a><br /></td></tr>
<tr class="separator:af4c35c2e9c7e83fe5a6c285b7f351cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f613170168aef099a6f3d78245be2d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#aa5f613170168aef099a6f3d78245be2d">convexCastAny</a> (const <a class="el" href="classbs_1_1_t_resource_handle.html">HPhysicsMesh</a> &amp;mesh, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;position, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, UINT64 layer=BS_ALL_LAYERS, float max=FLT_MAX) const =0</td></tr>
<tr class="memdesc:aa5f613170168aef099a6f3d78245be2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep into the scene using a convex mesh and checks if it has hit anything.  <a href="#aa5f613170168aef099a6f3d78245be2d">More...</a><br /></td></tr>
<tr class="separator:aa5f613170168aef099a6f3d78245be2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e6a082d48e472b24ef38519aee09dd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="classbs_1_1_game_object_handle.html">HCollider</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#af2e6a082d48e472b24ef38519aee09dd">boxOverlap</a> (const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;box, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, UINT64 layer=BS_ALL_LAYERS) const</td></tr>
<tr class="memdesc:af2e6a082d48e472b24ef38519aee09dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all colliders in the scene that overlap the provided box.  <a href="#af2e6a082d48e472b24ef38519aee09dd">More...</a><br /></td></tr>
<tr class="separator:af2e6a082d48e472b24ef38519aee09dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae1d4a3faf490edc8351722b76f118a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="classbs_1_1_game_object_handle.html">HCollider</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a6ae1d4a3faf490edc8351722b76f118a">sphereOverlap</a> (const <a class="el" href="classbs_1_1_sphere.html">Sphere</a> &amp;sphere, UINT64 layer=BS_ALL_LAYERS) const</td></tr>
<tr class="memdesc:a6ae1d4a3faf490edc8351722b76f118a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all colliders in the scene that overlap the provided sphere.  <a href="#a6ae1d4a3faf490edc8351722b76f118a">More...</a><br /></td></tr>
<tr class="separator:a6ae1d4a3faf490edc8351722b76f118a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadb60a9aeb173dd42b9bb1cbb42ddd8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="classbs_1_1_game_object_handle.html">HCollider</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#adadb60a9aeb173dd42b9bb1cbb42ddd8">capsuleOverlap</a> (const <a class="el" href="classbs_1_1_capsule.html">Capsule</a> &amp;capsule, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, UINT64 layer=BS_ALL_LAYERS) const</td></tr>
<tr class="memdesc:adadb60a9aeb173dd42b9bb1cbb42ddd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all colliders in the scene that overlap the provided capsule.  <a href="#adadb60a9aeb173dd42b9bb1cbb42ddd8">More...</a><br /></td></tr>
<tr class="separator:adadb60a9aeb173dd42b9bb1cbb42ddd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2110a60a7ea75eef3d084252aaf2b735"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="classbs_1_1_game_object_handle.html">HCollider</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a2110a60a7ea75eef3d084252aaf2b735">convexOverlap</a> (const <a class="el" href="classbs_1_1_t_resource_handle.html">HPhysicsMesh</a> &amp;mesh, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;position, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, UINT64 layer=BS_ALL_LAYERS) const</td></tr>
<tr class="memdesc:a2110a60a7ea75eef3d084252aaf2b735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all colliders in the scene that overlap the provided convex mesh.  <a href="#a2110a60a7ea75eef3d084252aaf2b735">More...</a><br /></td></tr>
<tr class="separator:a2110a60a7ea75eef3d084252aaf2b735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad18711703dc86a4c935d57f5fde022a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#aad18711703dc86a4c935d57f5fde022a">boxOverlapAny</a> (const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;box, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, UINT64 layer=BS_ALL_LAYERS) const =0</td></tr>
<tr class="memdesc:aad18711703dc86a4c935d57f5fde022a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the provided box overlaps any other collider in the scene.  <a href="#aad18711703dc86a4c935d57f5fde022a">More...</a><br /></td></tr>
<tr class="separator:aad18711703dc86a4c935d57f5fde022a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3a76fd922627ee3febb46e61c0846b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#adf3a76fd922627ee3febb46e61c0846b">sphereOverlapAny</a> (const <a class="el" href="classbs_1_1_sphere.html">Sphere</a> &amp;sphere, UINT64 layer=BS_ALL_LAYERS) const =0</td></tr>
<tr class="memdesc:adf3a76fd922627ee3febb46e61c0846b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the provided sphere overlaps any other collider in the scene.  <a href="#adf3a76fd922627ee3febb46e61c0846b">More...</a><br /></td></tr>
<tr class="separator:adf3a76fd922627ee3febb46e61c0846b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2c4b890b28fac8899e3f464a79ac3c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a1d2c4b890b28fac8899e3f464a79ac3c">capsuleOverlapAny</a> (const <a class="el" href="classbs_1_1_capsule.html">Capsule</a> &amp;capsule, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, UINT64 layer=BS_ALL_LAYERS) const =0</td></tr>
<tr class="memdesc:a1d2c4b890b28fac8899e3f464a79ac3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the provided capsule overlaps any other collider in the scene.  <a href="#a1d2c4b890b28fac8899e3f464a79ac3c">More...</a><br /></td></tr>
<tr class="separator:a1d2c4b890b28fac8899e3f464a79ac3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1a4b6bf62ac1d4cd9c1906c0396ed5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a7b1a4b6bf62ac1d4cd9c1906c0396ed5">convexOverlapAny</a> (const <a class="el" href="classbs_1_1_t_resource_handle.html">HPhysicsMesh</a> &amp;mesh, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;position, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, UINT64 layer=BS_ALL_LAYERS) const =0</td></tr>
<tr class="memdesc:a7b1a4b6bf62ac1d4cd9c1906c0396ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the provided convex mesh overlaps any other collider in the scene.  <a href="#a7b1a4b6bf62ac1d4cd9c1906c0396ed5">More...</a><br /></td></tr>
<tr class="separator:a7b1a4b6bf62ac1d4cd9c1906c0396ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac294ce4e004a3b4552f2702dd292ed58"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#ac294ce4e004a3b4552f2702dd292ed58">hasFlag</a> (<a class="el" href="group___physics.html#gae72c96e4649f01355a55f2a0fed8130b">PhysicsFlags</a> flag) const</td></tr>
<tr class="memdesc:ac294ce4e004a3b4552f2702dd292ed58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks is a specific physics option enabled.  <a href="#ac294ce4e004a3b4552f2702dd292ed58">More...</a><br /></td></tr>
<tr class="separator:ac294ce4e004a3b4552f2702dd292ed58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694211b1f4b92ea58b740b9414b06fa0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a694211b1f4b92ea58b740b9414b06fa0">setFlag</a> (<a class="el" href="group___physics.html#gae72c96e4649f01355a55f2a0fed8130b">PhysicsFlags</a> flag, bool enabled)</td></tr>
<tr class="memdesc:a694211b1f4b92ea58b740b9414b06fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disabled a specific physics option.  <a href="#a694211b1f4b92ea58b740b9414b06fa0">More...</a><br /></td></tr>
<tr class="separator:a694211b1f4b92ea58b740b9414b06fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d4efe0f5f57583c8645fae1752df75"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a15d4efe0f5f57583c8645fae1752df75">setPaused</a> (bool paused)=0</td></tr>
<tr class="memdesc:a15d4efe0f5f57583c8645fae1752df75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses or resumes the physics simulation.  <a href="#a15d4efe0f5f57583c8645fae1752df75">More...</a><br /></td></tr>
<tr class="separator:a15d4efe0f5f57583c8645fae1752df75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0f023b0bf3dddbf5cbac5ab7976372"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbs_1_1_vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a3c0f023b0bf3dddbf5cbac5ab7976372">getGravity</a> () const =0</td></tr>
<tr class="memdesc:a3c0f023b0bf3dddbf5cbac5ab7976372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the global gravity value for all objects in the scene. <br />
  <a href="#a3c0f023b0bf3dddbf5cbac5ab7976372">More...</a><br /></td></tr>
<tr class="separator:a3c0f023b0bf3dddbf5cbac5ab7976372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242340b62a1818031fdf3e6a1fdcaf8a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a242340b62a1818031fdf3e6a1fdcaf8a">setGravity</a> (const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;gravity)=0</td></tr>
<tr class="memdesc:a242340b62a1818031fdf3e6a1fdcaf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the global gravity value for all objects in the scene.  <a href="#a242340b62a1818031fdf3e6a1fdcaf8a">More...</a><br /></td></tr>
<tr class="separator:a242340b62a1818031fdf3e6a1fdcaf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03be05c9f1f7e43a5c83e4a6d57f8306"><td class="memItemLeft" align="right" valign="top">virtual UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a03be05c9f1f7e43a5c83e4a6d57f8306">addBroadPhaseRegion</a> (const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;region)=0</td></tr>
<tr class="memdesc:a03be05c9f1f7e43a5c83e4a6d57f8306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new physics region.  <a href="#a03be05c9f1f7e43a5c83e4a6d57f8306">More...</a><br /></td></tr>
<tr class="separator:a03be05c9f1f7e43a5c83e4a6d57f8306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d8c44eb5208b2d0d45322d9c957a27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a33d8c44eb5208b2d0d45322d9c957a27">removeBroadPhaseRegion</a> (UINT32 handle)=0</td></tr>
<tr class="memdesc:a33d8c44eb5208b2d0d45322d9c957a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a physics region.  <a href="#a33d8c44eb5208b2d0d45322d9c957a27">More...</a><br /></td></tr>
<tr class="separator:a33d8c44eb5208b2d0d45322d9c957a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7dab8efb540f38b05f221584fc2039d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#aa7dab8efb540f38b05f221584fc2039d">clearBroadPhaseRegions</a> ()=0</td></tr>
<tr class="memdesc:aa7dab8efb540f38b05f221584fc2039d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all physics regions.  <a href="#aa7dab8efb540f38b05f221584fc2039d">More...</a><br /></td></tr>
<tr class="separator:aa7dab8efb540f38b05f221584fc2039d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4352200326182bd30adc7f30c43ecf8"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#aa4352200326182bd30adc7f30c43ecf8">getMaxTesselationEdgeLength</a> () const =0</td></tr>
<tr class="memdesc:aa4352200326182bd30adc7f30c43ecf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a maximum edge length before a triangle is tesselated.  <a href="#aa4352200326182bd30adc7f30c43ecf8">More...</a><br /></td></tr>
<tr class="separator:aa4352200326182bd30adc7f30c43ecf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151ad0c614a6f671a7025b7e52237c3d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a151ad0c614a6f671a7025b7e52237c3d">setMaxTesselationEdgeLength</a> (float length)=0</td></tr>
<tr class="memdesc:a151ad0c614a6f671a7025b7e52237c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a maximum edge length before a triangle is tesselated.  <a href="#a151ad0c614a6f671a7025b7e52237c3d">More...</a><br /></td></tr>
<tr class="separator:a151ad0c614a6f671a7025b7e52237c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0646438909bd1e980a851687f9eafe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#acd0646438909bd1e980a851687f9eafe">toggleCollision</a> (UINT64 groupA, UINT64 groupB, bool enabled)</td></tr>
<tr class="memdesc:acd0646438909bd1e980a851687f9eafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables collision between two layers.  <a href="#acd0646438909bd1e980a851687f9eafe">More...</a><br /></td></tr>
<tr class="separator:acd0646438909bd1e980a851687f9eafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056beedb629920135d1b04bfe969d56e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a056beedb629920135d1b04bfe969d56e">isCollisionEnabled</a> (UINT64 groupA, UINT64 groupB) const</td></tr>
<tr class="memdesc:a056beedb629920135d1b04bfe969d56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two collision layers are allowed to interact.  <a href="#a056beedb629920135d1b04bfe969d56e">More...</a><br /></td></tr>
<tr class="separator:a056beedb629920135d1b04bfe969d56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Internal</div></td></tr>
<tr class="memitem:a42f97ec4c1b11c160ac29f0b0116e33b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_physics_material.html">PhysicsMaterial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a42f97ec4c1b11c160ac29f0b0116e33b">createMaterial</a> (float staticFriction, float dynamicFriction, float restitution)=0</td></tr>
<tr class="memdesc:a42f97ec4c1b11c160ac29f0b0116e33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new physics material. <br />
  <a href="#a42f97ec4c1b11c160ac29f0b0116e33b">More...</a><br /></td></tr>
<tr class="separator:a42f97ec4c1b11c160ac29f0b0116e33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd3fc78303d8c8e289b045039986310"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_physics_mesh.html">PhysicsMesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a7cd3fc78303d8c8e289b045039986310">createMesh</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_mesh_data.html">MeshData</a> &gt; &amp;meshData, <a class="el" href="group___utility-_core.html#gae0141accd6cb1ad18ea671b709515fb8">PhysicsMeshType</a> type)=0</td></tr>
<tr class="memdesc:a7cd3fc78303d8c8e289b045039986310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new physics mesh. <br />
  <a href="#a7cd3fc78303d8c8e289b045039986310">More...</a><br /></td></tr>
<tr class="separator:a7cd3fc78303d8c8e289b045039986310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff196fc0d15900cc84f4689b2767c77"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_rigidbody.html">Rigidbody</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#aeff196fc0d15900cc84f4689b2767c77">createRigidbody</a> (const <a class="el" href="classbs_1_1_game_object_handle.html">HSceneObject</a> &amp;linkedSO)=0</td></tr>
<tr class="memdesc:aeff196fc0d15900cc84f4689b2767c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new rigidbody. <br />
  <a href="#aeff196fc0d15900cc84f4689b2767c77">More...</a><br /></td></tr>
<tr class="separator:aeff196fc0d15900cc84f4689b2767c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1627ddd7cce8400be87da970f9a336"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_box_collider.html">BoxCollider</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a8e1627ddd7cce8400be87da970f9a336">createBoxCollider</a> (const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;extents, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;position, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation)=0</td></tr>
<tr class="memdesc:a8e1627ddd7cce8400be87da970f9a336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new box collider. <br />
  <a href="#a8e1627ddd7cce8400be87da970f9a336">More...</a><br /></td></tr>
<tr class="separator:a8e1627ddd7cce8400be87da970f9a336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e3daabadc8543a8c54bf6831aad6ab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_sphere_collider.html">SphereCollider</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#af3e3daabadc8543a8c54bf6831aad6ab">createSphereCollider</a> (float radius, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;position, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation)=0</td></tr>
<tr class="memdesc:af3e3daabadc8543a8c54bf6831aad6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new sphere collider. <br />
  <a href="#af3e3daabadc8543a8c54bf6831aad6ab">More...</a><br /></td></tr>
<tr class="separator:af3e3daabadc8543a8c54bf6831aad6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13308a17632070c150a474711b03d7c9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_plane_collider.html">PlaneCollider</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a13308a17632070c150a474711b03d7c9">createPlaneCollider</a> (const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;position, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation)=0</td></tr>
<tr class="memdesc:a13308a17632070c150a474711b03d7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new plane collider. <br />
  <a href="#a13308a17632070c150a474711b03d7c9">More...</a><br /></td></tr>
<tr class="separator:a13308a17632070c150a474711b03d7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e25bd18d94d41a5328f554d7e2da40c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_capsule_collider.html">CapsuleCollider</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a9e25bd18d94d41a5328f554d7e2da40c">createCapsuleCollider</a> (float radius, float halfHeight, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;position, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation)=0</td></tr>
<tr class="memdesc:a9e25bd18d94d41a5328f554d7e2da40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new capsule collider. <br />
  <a href="#a9e25bd18d94d41a5328f554d7e2da40c">More...</a><br /></td></tr>
<tr class="separator:a9e25bd18d94d41a5328f554d7e2da40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead381a0393c837b2b16930d654fad56"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_mesh_collider.html">MeshCollider</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#aead381a0393c837b2b16930d654fad56">createMeshCollider</a> (const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;position, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation)=0</td></tr>
<tr class="memdesc:aead381a0393c837b2b16930d654fad56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mesh collider. <br />
  <a href="#aead381a0393c837b2b16930d654fad56">More...</a><br /></td></tr>
<tr class="separator:aead381a0393c837b2b16930d654fad56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0156430088ca72cd7213a3d3ab74d919"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_fixed_joint.html">FixedJoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a0156430088ca72cd7213a3d3ab74d919">createFixedJoint</a> (const <a class="el" href="structbs_1_1_f_i_x_e_d___j_o_i_n_t___d_e_s_c.html">FIXED_JOINT_DESC</a> &amp;desc)=0</td></tr>
<tr class="memdesc:a0156430088ca72cd7213a3d3ab74d919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new fixed joint. <br />
  <a href="#a0156430088ca72cd7213a3d3ab74d919">More...</a><br /></td></tr>
<tr class="separator:a0156430088ca72cd7213a3d3ab74d919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea94111b288a0c69b7a805176c68a52"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_distance_joint.html">DistanceJoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#abea94111b288a0c69b7a805176c68a52">createDistanceJoint</a> (const <a class="el" href="structbs_1_1_d_i_s_t_a_n_c_e___j_o_i_n_t___d_e_s_c.html">DISTANCE_JOINT_DESC</a> &amp;desc)=0</td></tr>
<tr class="memdesc:abea94111b288a0c69b7a805176c68a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new distance joint. <br />
  <a href="#abea94111b288a0c69b7a805176c68a52">More...</a><br /></td></tr>
<tr class="separator:abea94111b288a0c69b7a805176c68a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18499f270c38011d20054c6ae5a58ff6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_hinge_joint.html">HingeJoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a18499f270c38011d20054c6ae5a58ff6">createHingeJoint</a> (const <a class="el" href="structbs_1_1_h_i_n_g_e___j_o_i_n_t___d_e_s_c.html">HINGE_JOINT_DESC</a> &amp;desc)=0</td></tr>
<tr class="memdesc:a18499f270c38011d20054c6ae5a58ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new hinge joint. <br />
  <a href="#a18499f270c38011d20054c6ae5a58ff6">More...</a><br /></td></tr>
<tr class="separator:a18499f270c38011d20054c6ae5a58ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc675f216b7682af26ce17b0ff794c4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_spherical_joint.html">SphericalJoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#aedc675f216b7682af26ce17b0ff794c4">createSphericalJoint</a> (const <a class="el" href="structbs_1_1_s_p_h_e_r_i_c_a_l___j_o_i_n_t___d_e_s_c.html">SPHERICAL_JOINT_DESC</a> &amp;desc)=0</td></tr>
<tr class="memdesc:aedc675f216b7682af26ce17b0ff794c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new spherical joint. <br />
  <a href="#aedc675f216b7682af26ce17b0ff794c4">More...</a><br /></td></tr>
<tr class="separator:aedc675f216b7682af26ce17b0ff794c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775659a23fa2ff7aa0ff0dce503fcec8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_slider_joint.html">SliderJoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a775659a23fa2ff7aa0ff0dce503fcec8">createSliderJoint</a> (const <a class="el" href="structbs_1_1_s_l_i_d_e_r___j_o_i_n_t___d_e_s_c.html">SLIDER_JOINT_DESC</a> &amp;desc)=0</td></tr>
<tr class="memdesc:a775659a23fa2ff7aa0ff0dce503fcec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new spherical joint. <br />
  <a href="#a775659a23fa2ff7aa0ff0dce503fcec8">More...</a><br /></td></tr>
<tr class="separator:a775659a23fa2ff7aa0ff0dce503fcec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9008a2e46231078a057fc46f89de5ed3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_d6_joint.html">D6Joint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a9008a2e46231078a057fc46f89de5ed3">createD6Joint</a> (const <a class="el" href="structbs_1_1_d6___j_o_i_n_t___d_e_s_c.html">D6_JOINT_DESC</a> &amp;desc)=0</td></tr>
<tr class="memdesc:a9008a2e46231078a057fc46f89de5ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new D6 joint. <br />
  <a href="#a9008a2e46231078a057fc46f89de5ed3">More...</a><br /></td></tr>
<tr class="separator:a9008a2e46231078a057fc46f89de5ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5b7d33f95a942ad6b216044f840e81"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_character_controller.html">CharacterController</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a3d5b7d33f95a942ad6b216044f840e81">createCharacterController</a> (const <a class="el" href="structbs_1_1_c_h_a_r___c_o_n_t_r_o_l_l_e_r___d_e_s_c.html">CHAR_CONTROLLER_DESC</a> &amp;desc)=0</td></tr>
<tr class="memdesc:a3d5b7d33f95a942ad6b216044f840e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new character controller. <br />
  <a href="#a3d5b7d33f95a942ad6b216044f840e81">More...</a><br /></td></tr>
<tr class="separator:a3d5b7d33f95a942ad6b216044f840e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28232cf9ffb3e783028ce434f313998f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a28232cf9ffb3e783028ce434f313998f">fixedUpdate</a> (float step)=0</td></tr>
<tr class="memdesc:a28232cf9ffb3e783028ce434f313998f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the physics simulation.  <a href="#a28232cf9ffb3e783028ce434f313998f">More...</a><br /></td></tr>
<tr class="separator:a28232cf9ffb3e783028ce434f313998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd36d7881ea8503d5c5824e7a5ad6c7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#acd36d7881ea8503d5c5824e7a5ad6c7e">update</a> ()</td></tr>
<tr class="memdesc:acd36d7881ea8503d5c5824e7a5ad6c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs any physics operations that arent tied to the fixed update interval.  <a href="#acd36d7881ea8503d5c5824e7a5ad6c7e">More...</a><br /></td></tr>
<tr class="separator:acd36d7881ea8503d5c5824e7a5ad6c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae172da0caec5be0499c738551ed62da3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="classbs_1_1_collider.html">Collider</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#ae172da0caec5be0499c738551ed62da3">_boxOverlap</a> (const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;box, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, UINT64 layer=BS_ALL_LAYERS) const =0</td></tr>
<tr class="memdesc:ae172da0caec5be0499c738551ed62da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all colliders in the scene that overlap the provided box. <br />
  <a href="#ae172da0caec5be0499c738551ed62da3">More...</a><br /></td></tr>
<tr class="separator:ae172da0caec5be0499c738551ed62da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe4ee5634d39150894f5311eb2b6d56"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="classbs_1_1_collider.html">Collider</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#abbe4ee5634d39150894f5311eb2b6d56">_sphereOverlap</a> (const <a class="el" href="classbs_1_1_sphere.html">Sphere</a> &amp;sphere, UINT64 layer=BS_ALL_LAYERS) const =0</td></tr>
<tr class="memdesc:abbe4ee5634d39150894f5311eb2b6d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all colliders in the scene that overlap the provided sphere. <br />
  <a href="#abbe4ee5634d39150894f5311eb2b6d56">More...</a><br /></td></tr>
<tr class="separator:abbe4ee5634d39150894f5311eb2b6d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72214a0aa3f9cfe1aeb04320b9d0bfd0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="classbs_1_1_collider.html">Collider</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a72214a0aa3f9cfe1aeb04320b9d0bfd0">_capsuleOverlap</a> (const <a class="el" href="classbs_1_1_capsule.html">Capsule</a> &amp;capsule, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, UINT64 layer=BS_ALL_LAYERS) const =0</td></tr>
<tr class="memdesc:a72214a0aa3f9cfe1aeb04320b9d0bfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all colliders in the scene that overlap the provided capsule. <br />
  <a href="#a72214a0aa3f9cfe1aeb04320b9d0bfd0">More...</a><br /></td></tr>
<tr class="separator:a72214a0aa3f9cfe1aeb04320b9d0bfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774d79e8cdcb2d509b6723e02644d19f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="classbs_1_1_collider.html">Collider</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a774d79e8cdcb2d509b6723e02644d19f">_convexOverlap</a> (const <a class="el" href="classbs_1_1_t_resource_handle.html">HPhysicsMesh</a> &amp;mesh, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;position, const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;rotation, UINT64 layer=BS_ALL_LAYERS) const =0</td></tr>
<tr class="memdesc:a774d79e8cdcb2d509b6723e02644d19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all colliders in the scene that overlap the provided convex mesh. <br />
  <a href="#a774d79e8cdcb2d509b6723e02644d19f">More...</a><br /></td></tr>
<tr class="separator:a774d79e8cdcb2d509b6723e02644d19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd17e372ed87ea27c2682dee76a1f69"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#abbd17e372ed87ea27c2682dee76a1f69">_rayCast</a> (const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;origin, const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;unitDir, const <a class="el" href="classbs_1_1_collider.html">Collider</a> &amp;collider, <a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;hit, float maxDist=FLT_MAX) const =0</td></tr>
<tr class="memdesc:abbd17e372ed87ea27c2682dee76a1f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks does the ray hit the provided collider.  <a href="#abbd17e372ed87ea27c2682dee76a1f69">More...</a><br /></td></tr>
<tr class="separator:abbd17e372ed87ea27c2682dee76a1f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aeb8d5c7f6c1e40d9cc5c71ec0877d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_physics.html#a9aeb8d5c7f6c1e40d9cc5c71ec0877d4">_isUpdateInProgress</a> () const</td></tr>
<tr class="memdesc:a9aeb8d5c7f6c1e40d9cc5c71ec0877d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks is the physics simulation update currently in progress.  <a href="#a9aeb8d5c7f6c1e40d9cc5c71ec0877d4">More...</a><br /></td></tr>
<tr class="separator:a9aeb8d5c7f6c1e40d9cc5c71ec0877d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static fields</h2></td></tr>
<tr class="memitem:a6c5ab6d37735674ae24cf0ce4c281763"><td class="memItemLeft" align="right" valign="top"><a id="a6c5ab6d37735674ae24cf0ce4c281763"></a>
static const UINT64&#160;</td><td class="memItemRight" valign="bottom"><b>CollisionMapSize</b> = 64</td></tr>
<tr class="separator:a6c5ab6d37735674ae24cf0ce4c281763"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classbs_1_1_module"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classbs_1_1_module')"><img src="closed.png" alt="-"/>&#160;Static methods inherited from <a class="el" href="classbs_1_1_module.html">Module&lt; Physics &gt;</a></td></tr>
<tr class="memitem:a359703743cd890f1e3df60b6b06a5724 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbs_1_1_physics.html">Physics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a359703743cd890f1e3df60b6b06a5724">instance</a> ()</td></tr>
<tr class="memdesc:a359703743cd890f1e3df60b6b06a5724 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the module instance.  <a href="classbs_1_1_module.html#a359703743cd890f1e3df60b6b06a5724">More...</a><br /></td></tr>
<tr class="separator:a359703743cd890f1e3df60b6b06a5724 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affac4ec5f49e5e5561a027e3116e6f73 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbs_1_1_physics.html">Physics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#affac4ec5f49e5e5561a027e3116e6f73">instancePtr</a> ()</td></tr>
<tr class="memdesc:affac4ec5f49e5e5561a027e3116e6f73 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the module instance.  <a href="classbs_1_1_module.html#affac4ec5f49e5e5561a027e3116e6f73">More...</a><br /></td></tr>
<tr class="separator:affac4ec5f49e5e5561a027e3116e6f73 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b9d091b1b64652c94d5dd3b1c5017a inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a02b9d091b1b64652c94d5dd3b1c5017a">startUp</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a02b9d091b1b64652c94d5dd3b1c5017a inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and starts the module using the specified parameters.  <a href="classbs_1_1_module.html#a02b9d091b1b64652c94d5dd3b1c5017a">More...</a><br /></td></tr>
<tr class="separator:a02b9d091b1b64652c94d5dd3b1c5017a inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1a58af7a42d68c1ae45e40fbe8cebb inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a4d1a58af7a42d68c1ae45e40fbe8cebb">startUp</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a4d1a58af7a42d68c1ae45e40fbe8cebb inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and starts a specialized type of the module.  <a href="classbs_1_1_module.html#a4d1a58af7a42d68c1ae45e40fbe8cebb">More...</a><br /></td></tr>
<tr class="separator:a4d1a58af7a42d68c1ae45e40fbe8cebb inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ea87e87e28686a619551382f541433 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#aa4ea87e87e28686a619551382f541433">shutDown</a> ()</td></tr>
<tr class="memdesc:aa4ea87e87e28686a619551382f541433 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down this module and frees any resources it is using.  <a href="classbs_1_1_module.html#aa4ea87e87e28686a619551382f541433">More...</a><br /></td></tr>
<tr class="separator:aa4ea87e87e28686a619551382f541433 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289734510f3022acd240087478b994d9 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a289734510f3022acd240087478b994d9">isStarted</a> ()</td></tr>
<tr class="memdesc:a289734510f3022acd240087478b994d9 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if the module has been started.  <a href="classbs_1_1_module.html#a289734510f3022acd240087478b994d9">More...</a><br /></td></tr>
<tr class="separator:a289734510f3022acd240087478b994d9 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Method documentation</h2>
<a id="ae172da0caec5be0499c738551ed62da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae172da0caec5be0499c738551ed62da3">&#9670;&nbsp;</a></span>_boxOverlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="classbs_1_1_collider.html">Collider</a>*&gt; _boxOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all colliders in the scene that overlap the provided box. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>Box to check for overlap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all colliders that overlap the box. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a60f40522f3931509a1cd965d517632f4">PhysX</a>.</p>

</div>
</div>
<a id="a72214a0aa3f9cfe1aeb04320b9d0bfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72214a0aa3f9cfe1aeb04320b9d0bfd0">&#9670;&nbsp;</a></span>_capsuleOverlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="classbs_1_1_collider.html">Collider</a>*&gt; _capsuleOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_capsule.html">Capsule</a> &amp;&#160;</td>
          <td class="paramname"><em>capsule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all colliders in the scene that overlap the provided capsule. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capsule</td><td><a class="el" href="classbs_1_1_capsule.html" title="Represents a capsule with a line segment and a radius. ">Capsule</a> to check for overlap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the capsule. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all colliders that overlap the capsule. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#aa247a39bd0eddf0a62bbb55dd914a6f6">PhysX</a>.</p>

</div>
</div>
<a id="a774d79e8cdcb2d509b6723e02644d19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774d79e8cdcb2d509b6723e02644d19f">&#9670;&nbsp;</a></span>_convexOverlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="classbs_1_1_collider.html">Collider</a>*&gt; _convexOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_t_resource_handle.html">HPhysicsMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all colliders in the scene that overlap the provided convex mesh. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classbs_1_1_mesh.html" title="Primary class for holding geometry. ">Mesh</a> to check for overlap. Must be convex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all colliders that overlap the mesh. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a4dbe11439a032ca19149b7b8f801f3dc">PhysX</a>.</p>

</div>
</div>
<a id="a9aeb8d5c7f6c1e40d9cc5c71ec0877d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aeb8d5c7f6c1e40d9cc5c71ec0877d4">&#9670;&nbsp;</a></span>_isUpdateInProgress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _isUpdateInProgress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks is the physics simulation update currently in progress. </p>

</div>
</div>
<a id="abbd17e372ed87ea27c2682dee76a1f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd17e372ed87ea27c2682dee76a1f69">&#9670;&nbsp;</a></span>_rayCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool _rayCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_collider.html">Collider</a> &amp;&#160;</td>
          <td class="paramname"><em>collider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;&#160;</td>
          <td class="paramname"><em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxDist</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks does the ray hit the provided collider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>Origin of the ray to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction of the ray to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collider</td><td><a class="el" href="classbs_1_1_collider.html" title="Collider represents physics geometry that can be in multiple states: ">Collider</a> to check for hit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hit</td><td>Information about the hit. Valid only if the method returns true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDist</td><td>Maximum distance from the ray origin to search for hits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the ray has hit the collider. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#aacdbd38d50f07ec9ad19552b70f294d3">PhysX</a>.</p>

</div>
</div>
<a id="abbe4ee5634d39150894f5311eb2b6d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe4ee5634d39150894f5311eb2b6d56">&#9670;&nbsp;</a></span>_sphereOverlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="classbs_1_1_collider.html">Collider</a>*&gt; _sphereOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all colliders in the scene that overlap the provided sphere. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td><a class="el" href="classbs_1_1_sphere.html" title="A sphere represented by a center point and a radius. ">Sphere</a> to check for overlap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all colliders that overlap the sphere. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#ac07328b41c574f4bc1437b66cd28a683">PhysX</a>.</p>

</div>
</div>
<a id="a03be05c9f1f7e43a5c83e4a6d57f8306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03be05c9f1f7e43a5c83e4a6d57f8306">&#9670;&nbsp;</a></span>addBroadPhaseRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual UINT32 addBroadPhaseRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new physics region. </p>
<p>Certain physics options require you to set up regions in which physics objects are allowed to be in, and objects outside of these regions will not be handled by physics. You do not need to set up these regions by default. </p>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a01dd65794a351a1703d72a90d406f33a">PhysX</a>.</p>

</div>
</div>
<a id="a65530fa7f84c8433c97c6156508a393c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65530fa7f84c8433c97c6156508a393c">&#9670;&nbsp;</a></span>boxCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool boxCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;&#160;</td>
          <td class="paramname"><em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep into the scene using a box and returns the closest found hit, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>Box to sweep through the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction towards which to perform the sweep. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hit</td><td>Information recorded about a hit. Only valid if method returns true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if something was hit, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#af042e72fba751162f89c2b61b4b57bf6">PhysX</a>.</p>

</div>
</div>
<a id="a73fbd0def22d8d9862fc9f27bcf6fbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fbd0def22d8d9862fc9f27bcf6fbb5">&#9670;&nbsp;</a></span>boxCastAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a>&gt; boxCastAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep into the scene using a box and returns all found hits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>Box to sweep through the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction towards which to perform the sweep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all detected hits. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a253874bc7da19a4885d1956eb9fbbdaa">PhysX</a>.</p>

</div>
</div>
<a id="a1f66d1eb091d363b506b463c94025148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f66d1eb091d363b506b463c94025148">&#9670;&nbsp;</a></span>boxCastAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool boxCastAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep into the scene using a box and checks if it has hit anything. </p>
<p>This can be significantly more efficient than other types of cast* calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>Box to sweep through the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction towards which to perform the sweep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if something was hit, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a4b01bb389b021136c61f678a1f20747d">PhysX</a>.</p>

</div>
</div>
<a id="af2e6a082d48e472b24ef38519aee09dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e6a082d48e472b24ef38519aee09dd">&#9670;&nbsp;</a></span>boxOverlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="classbs_1_1_game_object_handle.html">HCollider</a>&gt; boxOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all colliders in the scene that overlap the provided box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>Box to check for overlap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all colliders that overlap the box. </dd></dl>

</div>
</div>
<a id="aad18711703dc86a4c935d57f5fde022a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad18711703dc86a4c935d57f5fde022a">&#9670;&nbsp;</a></span>boxOverlapAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool boxOverlapAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_a_a_box.html">AABox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the provided box overlaps any other collider in the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>Box to check for overlap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is overlap with another object, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a7a62c115dcf2bfd79c49f4201ff77e79">PhysX</a>.</p>

</div>
</div>
<a id="ae84333aa0e3c3d4ceea244811a5475a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84333aa0e3c3d4ceea244811a5475a7">&#9670;&nbsp;</a></span>capsuleCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool capsuleCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_capsule.html">Capsule</a> &amp;&#160;</td>
          <td class="paramname"><em>capsule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;&#160;</td>
          <td class="paramname"><em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep into the scene using a capsule and returns the closest found hit, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capsule</td><td><a class="el" href="classbs_1_1_capsule.html" title="Represents a capsule with a line segment and a radius. ">Capsule</a> to sweep through the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the capsule. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction towards which to perform the sweep. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hit</td><td>Information recorded about a hit. Only valid if method returns true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if something was hit, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#abba58a15ef231553a05b8fb0015b3a56">PhysX</a>.</p>

</div>
</div>
<a id="ad277e707642b7b121d47743232ff3431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad277e707642b7b121d47743232ff3431">&#9670;&nbsp;</a></span>capsuleCastAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a>&gt; capsuleCastAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_capsule.html">Capsule</a> &amp;&#160;</td>
          <td class="paramname"><em>capsule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep into the scene using a capsule and returns all found hits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capsule</td><td><a class="el" href="classbs_1_1_capsule.html" title="Represents a capsule with a line segment and a radius. ">Capsule</a> to sweep through the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the capsule. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction towards which to perform the sweep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all detected hits. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a11fa1b16e6aaa97226a58dc563a5d7c7">PhysX</a>.</p>

</div>
</div>
<a id="af4c35c2e9c7e83fe5a6c285b7f351cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c35c2e9c7e83fe5a6c285b7f351cd6">&#9670;&nbsp;</a></span>capsuleCastAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool capsuleCastAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_capsule.html">Capsule</a> &amp;&#160;</td>
          <td class="paramname"><em>capsule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep into the scene using a capsule and checks if it has hit anything. </p>
<p>This can be significantly more efficient than other types of cast* calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capsule</td><td><a class="el" href="classbs_1_1_capsule.html" title="Represents a capsule with a line segment and a radius. ">Capsule</a> to sweep through the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the capsule. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction towards which to perform the sweep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if something was hit, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a9ea68cda670a5cf6450fed25b772c63e">PhysX</a>.</p>

</div>
</div>
<a id="adadb60a9aeb173dd42b9bb1cbb42ddd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adadb60a9aeb173dd42b9bb1cbb42ddd8">&#9670;&nbsp;</a></span>capsuleOverlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="classbs_1_1_game_object_handle.html">HCollider</a>&gt; capsuleOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_capsule.html">Capsule</a> &amp;&#160;</td>
          <td class="paramname"><em>capsule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all colliders in the scene that overlap the provided capsule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capsule</td><td><a class="el" href="classbs_1_1_capsule.html" title="Represents a capsule with a line segment and a radius. ">Capsule</a> to check for overlap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the capsule. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all colliders that overlap the capsule. </dd></dl>

</div>
</div>
<a id="a1d2c4b890b28fac8899e3f464a79ac3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2c4b890b28fac8899e3f464a79ac3c">&#9670;&nbsp;</a></span>capsuleOverlapAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool capsuleOverlapAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_capsule.html">Capsule</a> &amp;&#160;</td>
          <td class="paramname"><em>capsule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the provided capsule overlaps any other collider in the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capsule</td><td><a class="el" href="classbs_1_1_capsule.html" title="Represents a capsule with a line segment and a radius. ">Capsule</a> to check for overlap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the capsule. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is overlap with another object, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a4e9ad1fa431921e867a8ce91c83e501d">PhysX</a>.</p>

</div>
</div>
<a id="aa7dab8efb540f38b05f221584fc2039d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7dab8efb540f38b05f221584fc2039d">&#9670;&nbsp;</a></span>clearBroadPhaseRegions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void clearBroadPhaseRegions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all physics regions. </p>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a53df6ed1b39aa7d1fa1993f9c62cc5aa">PhysX</a>.</p>

</div>
</div>
<a id="a45fadc40665d13a887c0999d1ed3bf71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fadc40665d13a887c0999d1ed3bf71">&#9670;&nbsp;</a></span>convexCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool convexCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_t_resource_handle.html">HPhysicsMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;&#160;</td>
          <td class="paramname"><em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep into the scene using a convex mesh and returns the closest found hit, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classbs_1_1_mesh.html" title="Primary class for holding geometry. ">Mesh</a> to sweep through the scene. Must be convex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Starting position of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction towards which to perform the sweep. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hit</td><td>Information recorded about a hit. Only valid if method returns true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if something was hit, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a3d67b359845ccfc140a243005dfae806">PhysX</a>.</p>

</div>
</div>
<a id="ad688c1691481352edacd4942dfd1ce88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad688c1691481352edacd4942dfd1ce88">&#9670;&nbsp;</a></span>convexCastAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a>&gt; convexCastAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_t_resource_handle.html">HPhysicsMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep into the scene using a convex mesh and returns all found hits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classbs_1_1_mesh.html" title="Primary class for holding geometry. ">Mesh</a> to sweep through the scene. Must be convex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Starting position of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction towards which to perform the sweep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all detected hits. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a3ef95b90155d9086d5244f99b7fdc532">PhysX</a>.</p>

</div>
</div>
<a id="aa5f613170168aef099a6f3d78245be2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f613170168aef099a6f3d78245be2d">&#9670;&nbsp;</a></span>convexCastAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool convexCastAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_t_resource_handle.html">HPhysicsMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep into the scene using a convex mesh and checks if it has hit anything. </p>
<p>This can be significantly more efficient than other types of cast* calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classbs_1_1_mesh.html" title="Primary class for holding geometry. ">Mesh</a> to sweep through the scene. Must be convex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Starting position of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction towards which to perform the sweep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if something was hit, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a134fa5f4ed7a657bd2a96622ff2cb2d6">PhysX</a>.</p>

</div>
</div>
<a id="a2110a60a7ea75eef3d084252aaf2b735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2110a60a7ea75eef3d084252aaf2b735">&#9670;&nbsp;</a></span>convexOverlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="classbs_1_1_game_object_handle.html">HCollider</a>&gt; convexOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_t_resource_handle.html">HPhysicsMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all colliders in the scene that overlap the provided convex mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classbs_1_1_mesh.html" title="Primary class for holding geometry. ">Mesh</a> to check for overlap. Must be convex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all colliders that overlap the mesh. </dd></dl>

</div>
</div>
<a id="a7b1a4b6bf62ac1d4cd9c1906c0396ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1a4b6bf62ac1d4cd9c1906c0396ed5">&#9670;&nbsp;</a></span>convexOverlapAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool convexOverlapAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_t_resource_handle.html">HPhysicsMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the provided convex mesh overlaps any other collider in the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classbs_1_1_mesh.html" title="Primary class for holding geometry. ">Mesh</a> to check for overlap. Must be convex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Orientation of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is overlap with another object, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#af9f979e213d4b9fa0fe3d986ed3a0b37">PhysX</a>.</p>

</div>
</div>
<a id="a8e1627ddd7cce8400be87da970f9a336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1627ddd7cce8400be87da970f9a336">&#9670;&nbsp;</a></span>createBoxCollider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_box_collider.html">BoxCollider</a>&gt; createBoxCollider </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new box collider. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extents</td><td>Extents (half size) of the box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Center of the box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Rotation of the box. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a9d32ec9d29f4c432348a34a264fe2712">PhysX</a>.</p>

</div>
</div>
<a id="a9e25bd18d94d41a5328f554d7e2da40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e25bd18d94d41a5328f554d7e2da40c">&#9670;&nbsp;</a></span>createCapsuleCollider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_capsule_collider.html">CapsuleCollider</a>&gt; createCapsuleCollider </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new capsule collider. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>Radius of the capsule. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">halfHeight</td><td>Half height of the capsule, from the origin to one of the hemispherical centers, along the normal vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Center of the box. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Rotation of the box. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a51b945d8f61aa5ec23ad7bd02dd530f0">PhysX</a>.</p>

</div>
</div>
<a id="a3d5b7d33f95a942ad6b216044f840e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5b7d33f95a942ad6b216044f840e81">&#9670;&nbsp;</a></span>createCharacterController()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_character_controller.html">CharacterController</a>&gt; createCharacterController </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbs_1_1_c_h_a_r___c_o_n_t_r_o_l_l_e_r___d_e_s_c.html">CHAR_CONTROLLER_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new character controller. <br />
 </p>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a918abca1d641f879b4e8f4720f092e11">PhysX</a>.</p>

</div>
</div>
<a id="a9008a2e46231078a057fc46f89de5ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9008a2e46231078a057fc46f89de5ed3">&#9670;&nbsp;</a></span>createD6Joint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_d6_joint.html">D6Joint</a>&gt; createD6Joint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbs_1_1_d6___j_o_i_n_t___d_e_s_c.html">D6_JOINT_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new D6 joint. <br />
 </p>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#ab94ff4af9dfe2abf5b390abae0f7845a">PhysX</a>.</p>

</div>
</div>
<a id="abea94111b288a0c69b7a805176c68a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea94111b288a0c69b7a805176c68a52">&#9670;&nbsp;</a></span>createDistanceJoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_distance_joint.html">DistanceJoint</a>&gt; createDistanceJoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbs_1_1_d_i_s_t_a_n_c_e___j_o_i_n_t___d_e_s_c.html">DISTANCE_JOINT_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new distance joint. <br />
 </p>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a99d0b2846787460674eb7af44ac662a2">PhysX</a>.</p>

</div>
</div>
<a id="a0156430088ca72cd7213a3d3ab74d919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0156430088ca72cd7213a3d3ab74d919">&#9670;&nbsp;</a></span>createFixedJoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_fixed_joint.html">FixedJoint</a>&gt; createFixedJoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbs_1_1_f_i_x_e_d___j_o_i_n_t___d_e_s_c.html">FIXED_JOINT_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new fixed joint. <br />
 </p>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#afc785599d4b802e1edb3906d67089634">PhysX</a>.</p>

</div>
</div>
<a id="a18499f270c38011d20054c6ae5a58ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18499f270c38011d20054c6ae5a58ff6">&#9670;&nbsp;</a></span>createHingeJoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_hinge_joint.html">HingeJoint</a>&gt; createHingeJoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbs_1_1_h_i_n_g_e___j_o_i_n_t___d_e_s_c.html">HINGE_JOINT_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new hinge joint. <br />
 </p>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a25395aea1f2b0ee493ad2fc5696ab5a8">PhysX</a>.</p>

</div>
</div>
<a id="a42f97ec4c1b11c160ac29f0b0116e33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f97ec4c1b11c160ac29f0b0116e33b">&#9670;&nbsp;</a></span>createMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_physics_material.html">PhysicsMaterial</a>&gt; createMaterial </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>staticFriction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dynamicFriction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>restitution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new physics material. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">staticFriction</td><td>Controls friction when two in-contact objects are not moving lateral to each other (for example how difficult is to get an object moving from a static state while it is in contact other object(s)). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dynamicFriction</td><td>Sets dynamic friction of the material. Controls friction when two in-contact objects are moving lateral to each other (for example how quickly does an object slow down when sliding along another object). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">restitution</td><td>Controls "bounciness" of an object during a collision. Value of 1 means the collision is elastic, and value of 0 means the value is inelastic. Must be in [0, 1] range. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a3dcb977b9f5fc56dd15f3466e1d0ad0f">PhysX</a>.</p>

</div>
</div>
<a id="a7cd3fc78303d8c8e289b045039986310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd3fc78303d8c8e289b045039986310">&#9670;&nbsp;</a></span>createMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_physics_mesh.html">PhysicsMesh</a>&gt; createMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_mesh_data.html">MeshData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gae0141accd6cb1ad18ea671b709515fb8">PhysicsMeshType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new physics mesh. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshData</td><td>Index and vertices of the mesh data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of the mesh. If convex the provided mesh geometry will be converted into a convex mesh (that might not be the same as the provided mesh data). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a32cc4103dc21b05f52fbaaba70d38e05">PhysX</a>.</p>

</div>
</div>
<a id="aead381a0393c837b2b16930d654fad56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead381a0393c837b2b16930d654fad56">&#9670;&nbsp;</a></span>createMeshCollider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_mesh_collider.html">MeshCollider</a>&gt; createMeshCollider </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new mesh collider. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position of the collider. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Rotation of the collider. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#aea16079a8cdb4360ad1507f78c02c651">PhysX</a>.</p>

</div>
</div>
<a id="a13308a17632070c150a474711b03d7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13308a17632070c150a474711b03d7c9">&#9670;&nbsp;</a></span>createPlaneCollider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_plane_collider.html">PlaneCollider</a>&gt; createPlaneCollider </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new plane collider. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position of the collider. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Rotation of the collider. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a863221bd16896b4167ebc7af579f37ec">PhysX</a>.</p>

</div>
</div>
<a id="aeff196fc0d15900cc84f4689b2767c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff196fc0d15900cc84f4689b2767c77">&#9670;&nbsp;</a></span>createRigidbody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_rigidbody.html">Rigidbody</a>&gt; createRigidbody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_game_object_handle.html">HSceneObject</a> &amp;&#160;</td>
          <td class="paramname"><em>linkedSO</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new rigidbody. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">linkedSO</td><td>Scene object that owns this rigidbody. All physics updates applied to this object will be transfered to this scene object (the movement/rotation resulting from those updates). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a481392708509e5f94467bcc9dda07c12">PhysX</a>.</p>

</div>
</div>
<a id="a775659a23fa2ff7aa0ff0dce503fcec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775659a23fa2ff7aa0ff0dce503fcec8">&#9670;&nbsp;</a></span>createSliderJoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_slider_joint.html">SliderJoint</a>&gt; createSliderJoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbs_1_1_s_l_i_d_e_r___j_o_i_n_t___d_e_s_c.html">SLIDER_JOINT_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new spherical joint. <br />
 </p>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a8cba144bb4444e547b6d55040465df01">PhysX</a>.</p>

</div>
</div>
<a id="af3e3daabadc8543a8c54bf6831aad6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e3daabadc8543a8c54bf6831aad6ab">&#9670;&nbsp;</a></span>createSphereCollider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_sphere_collider.html">SphereCollider</a>&gt; createSphereCollider </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new sphere collider. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>Radius of the sphere geometry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>Position of the collider. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Rotation of the collider. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#aa8ae09c6df3e05b7ab71f1dd9edecf15">PhysX</a>.</p>

</div>
</div>
<a id="aedc675f216b7682af26ce17b0ff794c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc675f216b7682af26ce17b0ff794c4">&#9670;&nbsp;</a></span>createSphericalJoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_spherical_joint.html">SphericalJoint</a>&gt; createSphericalJoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbs_1_1_s_p_h_e_r_i_c_a_l___j_o_i_n_t___d_e_s_c.html">SPHERICAL_JOINT_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new spherical joint. <br />
 </p>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a742f59c2c2825f51b8a2996904ac9e46">PhysX</a>.</p>

</div>
</div>
<a id="a28232cf9ffb3e783028ce434f313998f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28232cf9ffb3e783028ce434f313998f">&#9670;&nbsp;</a></span>fixedUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void fixedUpdate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>step</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the physics simulation. </p>
<p>In order to maintain stability of the physics calculations this method should be called at fixed intervals (e.g. 60 times a second).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td><a class="el" href="classbs_1_1_time.html" title="Manages all time related functionality. ">Time</a> delta to advance the physics simulation by, in seconds. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a1a24f3033d8a62b52d2fd19b91f59c45">PhysX</a>.</p>

</div>
</div>
<a id="a3c0f023b0bf3dddbf5cbac5ab7976372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0f023b0bf3dddbf5cbac5ab7976372">&#9670;&nbsp;</a></span>getGravity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbs_1_1_vector3.html">Vector3</a> getGravity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the global gravity value for all objects in the scene. <br />
 </p>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#addffeee2e0d456ce93d51f33f439bbb9">PhysX</a>.</p>

</div>
</div>
<a id="aa4352200326182bd30adc7f30c43ecf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4352200326182bd30adc7f30c43ecf8">&#9670;&nbsp;</a></span>getMaxTesselationEdgeLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float getMaxTesselationEdgeLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a maximum edge length before a triangle is tesselated. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___physics.html#gga00d6141cb1860ee641ff72e91d46274ea6fabacbf8aac62d08794a4b547fe446a" title="Large triangles can cause problems with character controller collision. ">PhysicsFlags::CCT_Tesselation</a> </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a1eb0d626e5b3d510ac324a505b863607">PhysX</a>.</p>

</div>
</div>
<a id="ac294ce4e004a3b4552f2702dd292ed58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac294ce4e004a3b4552f2702dd292ed58">&#9670;&nbsp;</a></span>hasFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool hasFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___physics.html#gae72c96e4649f01355a55f2a0fed8130b">PhysicsFlags</a>&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks is a specific physics option enabled. </p>

</div>
</div>
<a id="a056beedb629920135d1b04bfe969d56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056beedb629920135d1b04bfe969d56e">&#9670;&nbsp;</a></span>isCollisionEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isCollisionEnabled </td>
          <td>(</td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>groupA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>groupB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two collision layers are allowed to interact. </p>

</div>
</div>
<a id="a332ecaffb2c30182194598e779c655af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332ecaffb2c30182194598e779c655af">&#9670;&nbsp;</a></span>rayCast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rayCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;&#160;</td>
          <td class="paramname"><em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a ray into the scene and returns the closest found hit, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td><a class="el" href="classbs_1_1_ray.html" title="A ray in 3D space represented with an origin and direction. ">Ray</a> to cast into the scene. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hit</td><td>Information recorded about a hit. Only valid if method returns true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if something was hit, false otherwise. </dd></dl>

</div>
</div>
<a id="a9f37047d0e9c940fe952665cb232623c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f37047d0e9c940fe952665cb232623c">&#9670;&nbsp;</a></span>rayCast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rayCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;&#160;</td>
          <td class="paramname"><em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a ray into the scene and returns the closest found hit, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>Origin of the ray to cast into the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction of the ray to cast into the scene. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hit</td><td>Information recorded about a hit. Only valid if method returns true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if something was hit, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#aabeaa85e3aa8184945f552664fce2544">PhysX</a>.</p>

</div>
</div>
<a id="a66788e208459a45aa4a0bc3731a3b851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66788e208459a45aa4a0bc3731a3b851">&#9670;&nbsp;</a></span>rayCastAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a>&gt; rayCastAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a ray into the scene and returns all found hits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td><a class="el" href="classbs_1_1_ray.html" title="A ray in 3D space represented with an origin and direction. ">Ray</a> to cast into the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all detected hits. </dd></dl>

</div>
</div>
<a id="ab9c8acc7645a9ca3bc9092a077d8200d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c8acc7645a9ca3bc9092a077d8200d">&#9670;&nbsp;</a></span>rayCastAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a>&gt; rayCastAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a ray into the scene and returns all found hits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>Origin of the ray to cast into the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction of the ray to cast into the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all detected hits. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a98ddb6a5e57e86865b4a284f3fd97f0d">PhysX</a>.</p>

</div>
</div>
<a id="abe88ffedf2b09aea3919b3ea298cdd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe88ffedf2b09aea3919b3ea298cdd09">&#9670;&nbsp;</a></span>rayCastAny() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rayCastAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a ray into the scene and checks if it has hit anything. </p>
<p>This can be significantly more efficient than other types of cast* calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td><a class="el" href="classbs_1_1_ray.html" title="A ray in 3D space represented with an origin and direction. ">Ray</a> to cast into the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if something was hit, false otherwise. </dd></dl>

</div>
</div>
<a id="af3faea625c226566c616cb598353339e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3faea625c226566c616cb598353339e">&#9670;&nbsp;</a></span>rayCastAny() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rayCastAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a ray into the scene and checks if it has hit anything. </p>
<p>This can be significantly more efficient than other types of cast* calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>Origin of the ray to cast into the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction of the ray to cast into the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if something was hit, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a46e952c3f128ea2667ec0f4714b28ce6">PhysX</a>.</p>

</div>
</div>
<a id="a33d8c44eb5208b2d0d45322d9c957a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d8c44eb5208b2d0d45322d9c957a27">&#9670;&nbsp;</a></span>removeBroadPhaseRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void removeBroadPhaseRegion </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a physics region. </p>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#aeb8fb3020a3ee1a29bd353f8d28070fe">PhysX</a>.</p>

</div>
</div>
<a id="a694211b1f4b92ea58b740b9414b06fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694211b1f4b92ea58b740b9414b06fa0">&#9670;&nbsp;</a></span>setFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___physics.html#gae72c96e4649f01355a55f2a0fed8130b">PhysicsFlags</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disabled a specific physics option. </p>

<p>Reimplemented in <a class="el" href="classbs_1_1_phys_x.html#a44e0f808593514b491bda58674e4cf7d">PhysX</a>.</p>

</div>
</div>
<a id="a242340b62a1818031fdf3e6a1fdcaf8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242340b62a1818031fdf3e6a1fdcaf8a">&#9670;&nbsp;</a></span>setGravity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setGravity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>gravity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the global gravity value for all objects in the scene. </p>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#ac78fbac0f9b9da0aebb951a4d287c2a8">PhysX</a>.</p>

</div>
</div>
<a id="a151ad0c614a6f671a7025b7e52237c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151ad0c614a6f671a7025b7e52237c3d">&#9670;&nbsp;</a></span>setMaxTesselationEdgeLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setMaxTesselationEdgeLength </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a maximum edge length before a triangle is tesselated. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___physics.html#gga00d6141cb1860ee641ff72e91d46274ea6fabacbf8aac62d08794a4b547fe446a" title="Large triangles can cause problems with character controller collision. ">PhysicsFlags::CCT_Tesselation</a> </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a12ef7cb18ee4f1c999848f1299c9e188">PhysX</a>.</p>

</div>
</div>
<a id="a15d4efe0f5f57583c8645fae1752df75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d4efe0f5f57583c8645fae1752df75">&#9670;&nbsp;</a></span>setPaused()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setPaused </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pauses or resumes the physics simulation. </p>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a141c2914799e0cafa3434dd9f71e7cce">PhysX</a>.</p>

</div>
</div>
<a id="a52fde7a33afd071121717a00618dd78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fde7a33afd071121717a00618dd78d">&#9670;&nbsp;</a></span>sphereCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sphereCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a> &amp;&#160;</td>
          <td class="paramname"><em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep into the scene using a sphere and returns the closest found hit, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td><a class="el" href="classbs_1_1_sphere.html" title="A sphere represented by a center point and a radius. ">Sphere</a> to sweep through the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction towards which to perform the sweep. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hit</td><td>Information recorded about a hit. Only valid if method returns true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if something was hit, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#acb6917858daf4dbeea4e60bf8bb19fa3">PhysX</a>.</p>

</div>
</div>
<a id="a1eef3c95d40f83a5b654f134f4155d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eef3c95d40f83a5b654f134f4155d49">&#9670;&nbsp;</a></span>sphereCastAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="structbs_1_1_physics_query_hit.html">PhysicsQueryHit</a>&gt; sphereCastAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep into the scene using a sphere and returns all found hits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td><a class="el" href="classbs_1_1_sphere.html" title="A sphere represented by a center point and a radius. ">Sphere</a> to sweep through the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction towards which to perform the sweep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all detected hits. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#aa430dfb1a1dc48043c976dadbb9d2257">PhysX</a>.</p>

</div>
</div>
<a id="ade83fa0108f9c49443d424331c3d8c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade83fa0108f9c49443d424331c3d8c5c">&#9670;&nbsp;</a></span>sphereCastAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sphereCastAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em> = <code>FLT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep into the scene using a sphere and checks if it has hit anything. </p>
<p>This can be significantly more efficient than other types of cast* calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td><a class="el" href="classbs_1_1_sphere.html" title="A sphere represented by a center point and a radius. ">Sphere</a> to sweep through the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Unit direction towards which to perform the sweep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>Maximum distance at which to perform the query. Hits past this distance will not be detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if something was hit, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#a3b4547634032fe5554c5e7d7566e789b">PhysX</a>.</p>

</div>
</div>
<a id="a6ae1d4a3faf490edc8351722b76f118a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae1d4a3faf490edc8351722b76f118a">&#9670;&nbsp;</a></span>sphereOverlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="classbs_1_1_game_object_handle.html">HCollider</a>&gt; sphereOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all colliders in the scene that overlap the provided sphere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td><a class="el" href="classbs_1_1_sphere.html" title="A sphere represented by a center point and a radius. ">Sphere</a> to check for overlap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all colliders that overlap the sphere. </dd></dl>

</div>
</div>
<a id="adf3a76fd922627ee3febb46e61c0846b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3a76fd922627ee3febb46e61c0846b">&#9670;&nbsp;</a></span>sphereOverlapAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sphereOverlapAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_sphere.html">Sphere</a> &amp;&#160;</td>
          <td class="paramname"><em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>layer</em> = <code>BS_ALL_LAYERS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the provided sphere overlaps any other collider in the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sphere</td><td><a class="el" href="classbs_1_1_sphere.html" title="A sphere represented by a center point and a radius. ">Sphere</a> to check for overlap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>Layers to consider for the query. This allows you to ignore certain groups of objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is overlap with another object, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classbs_1_1_phys_x.html#ae5efa9e4c6f4bba12fb604cc7e524d23">PhysX</a>.</p>

</div>
</div>
<a id="acd0646438909bd1e980a851687f9eafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0646438909bd1e980a851687f9eafe">&#9670;&nbsp;</a></span>toggleCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void toggleCollision </td>
          <td>(</td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>groupA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>groupB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables collision between two layers. </p>
<p>Each physics object can be assigned a specific layer, and here you can determine which layers can interact with each other. </p>

</div>
</div>
<a id="acd36d7881ea8503d5c5824e7a5ad6c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd36d7881ea8503d5c5824e7a5ad6c7e">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs any physics operations that arent tied to the fixed update interval. </p>
<p>Should be called once per frame. </p>

<p>Reimplemented in <a class="el" href="classbs_1_1_phys_x.html#a44137bb65de2396875934e48a6ee5099">PhysX</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
