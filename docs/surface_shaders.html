<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-120676613-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-120676613-1');
</script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - Surface &amp; lighting shaders</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='https://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Surface &amp; lighting shaders </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#surfaceShaders_a">Vertex</a></li>
<li class="level1"><a href="#surfaceShaders_b">Deferred pipeline</a><ul><li class="level2"><a href="#surfaceShaders_b_a">Surface</a></li>
<li class="level2"><a href="#surfaceShaders_b_b">Lighting</a><ul><li class="level3"><a href="#surfaceShaders_b_b_a">Overriding the BRDF</a></li>
<li class="level3"><a href="#surfaceShaders_b_b_b">Overriding luminance calculations</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#surfaceShaders_c">Forward</a></li>
</ul>
</div>
<div class="textblock"><p>So far we have shown how to create BSL shaders from scratch. This is useful when using the low-level rendering API and you have full control over rendering. But if you wish to create shaders to customize the behaviour of the default renderer (i.e. for use in <b>Renderable</b>) you must make sure those shaders comply to a set of rules that are expected by the renderer. Luckily bsf doesn't expect you to handle all those details by yourself, and instead allows you to easily override relevant parts of those shaders, keeping all the complex details hidden from the normal user.</p>
<p>Shader aspects that can be overriden can be split into different categories:</p><ul>
<li>Vertex shaders - They control how are vertices of the rendered mesh transformed before being rasterized.</li>
<li>Surface shaders - They allow you to control what kind of information gets sent to the lighting evaluation methods, including the albedo color, normal, roughness, metalness, and others. You get to control various surface details but the lighting that evaluates them remains fixed.</li>
<li>Lighting shaders - They allow you to control how is surface BRDF evaluated, as well as completely override how is lighting evaluated. This allows you to fully control the rendering, creating stylized or otherwise different lighting models.</li>
</ul>
<p>bsf internally uses two separate render pipelines: forward and deferred. The way shaders are handled for both of those pipelines are different, and therefore we will split this manual into two sections, one for each pipeline. When creating your shader you get to pick which pipeline you want to use for your material (deferred being the default).</p>
<p>Vertex shaders are handled the same regardless of the pipeline, so we will cover them first before continuing with pipeline specific shaders.</p>
<h1><a class="anchor" id="surfaceShaders_a"></a>
Vertex</h1>
<p>Vertex shaders allow you to transform object geometry before an object is rasterized. Its entry point must have the following signature:</p><ul>
<li><code>VStoFS vsmain(VertexInput input)</code></li>
</ul>
<p>Where:</p><ul>
<li><em>input</em> - Contains position of the vertex, UV coordinates, a normal and a tangent. If the rendered mesh is animated via skinning it will also include skinning weights and indices. If the renderer mesh is animated via morph shapes it will include delta position and normal.</li>
<li>Method returns a <b>VStoFS</b> structure that you will need to populate. The contents of the structure are displayed below.</li>
</ul>
<div class="fragment"><div class="line">struct VStoFS</div><div class="line">{</div><div class="line">    // Position in clip space (multiplied by world-view-projection matrix)</div><div class="line">    float4 position : SV_Position;</div><div class="line"></div><div class="line">    // Texture coordinates</div><div class="line">    float2 uv0 : TEXCOORD0;</div><div class="line"></div><div class="line">    // Position in world space (multiplied by the world matrix)</div><div class="line">    float3 worldPosition : TEXCOORD1;</div><div class="line"></div><div class="line">    // World space normal</div><div class="line">    float3 tangentToWorldZ : NORMAL;</div><div class="line"></div><div class="line">    // World space tangent, where w component represents tangent sign</div><div class="line">    float4 tangentToWorldX : TANGENT;</div><div class="line">};</div></div><!-- fragment --><p>It must include the following mixins:</p><ul>
<li><b>VertexInput</b> (from <code>VertexInput.bslinc</code>) - Contains a set of helper methods useful for transforming vertex inputs into outputs.</li>
<li><b>PerCameraData</b> (from <code>PerCameraData.bslinc</code>) - Provides a variety of camera parameters, including the view-projection matrix, view direction and origin. Check the contents of <code>PerCameraData.bslinc</code> to see all the provided properties.</li>
<li><b>PerObjectData</b> (from <code>PerObjectData.bslinc</code>) - Provides a variety of per-object paramters, including the world transform, and the world-view-projection matrix. Check the contents of <code>PerObjectData.bslinc</code> to see all the provided properties.</li>
</ul>
<div class="fragment"><div class="line">#include &quot;$ENGINE$\PerCameraData.bslinc&quot;</div><div class="line">#include &quot;$ENGINE$\PerObjectData.bslinc&quot;</div><div class="line">#include &quot;$ENGINE$\VertexInput.bslinc&quot;</div><div class="line"></div><div class="line">shader VertexTransform</div><div class="line">{</div><div class="line">    mixin PerCameraData;</div><div class="line">    mixin PerObjectData;</div><div class="line">    mixin VertexInput;</div><div class="line"></div><div class="line">    code</div><div class="line">    {</div><div class="line">        VStoFS vsmain(VertexInput input)</div><div class="line">        {</div><div class="line">            // ..</div><div class="line">        }</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>When populating <b>VStoFS</b> output structure you can use the following helper methods to make the job easier:</p><ul>
<li><code>VertexIntermediate getVertexIntermediate(VertexInput input)</code> - Calculates world space normal/tangent, as well as potentially other properties required for animation. Normally you do not need to read the returned value directly, it is instead provided to the methods below.</li>
<li><code>float4 getVertexWorldPosition(VertexInput input, VertexIntermediate intermediate)</code> - Calculates the world space position of the vertex. It is preferable to call this method instead of calculating the world position yourself because the method will automatically account for any potential animation (skinned or morph).</li>
<li><code>void populateVertexOutput(VertexInput input, VertexIntermediate intermediate, inout VStoFS result)</code> - Populates the UV and normal/tangent fields of the <b>VStoFS</b> structure.</li>
</ul>
<p>You are of course not forced to use any of the methods above, as long as you properly populate the <b>VStoFS</b> structure. An example shader making use of these methods would look like so:</p>
<div class="fragment"><div class="line">#include &quot;$ENGINE$\PerCameraData.bslinc&quot;</div><div class="line">#include &quot;$ENGINE$\PerObjectData.bslinc&quot;</div><div class="line">#include &quot;$ENGINE$\VertexInput.bslinc&quot;</div><div class="line"></div><div class="line">shader VertexTransform</div><div class="line">{</div><div class="line">    mixin PerCameraData;</div><div class="line">    mixin PerObjectData;</div><div class="line">    mixin VertexInput;</div><div class="line"></div><div class="line">    code</div><div class="line">    {</div><div class="line">        VStoFS vsmain(VertexInput input)</div><div class="line">        {</div><div class="line">            VStoFS output;</div><div class="line"></div><div class="line">            VertexIntermediate intermediate = getVertexIntermediate(input);</div><div class="line">            float4 worldPosition = getVertexWorldPosition(input, intermediate);</div><div class="line"></div><div class="line">            output.worldPosition = worldPosition.xyz;</div><div class="line">            output.position = mul(gMatViewProj, worldPosition);</div><div class="line">            populateVertexOutput(input, intermediate, output);</div><div class="line"></div><div class="line">            return output;</div><div class="line">        }</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>Once the shader is created, it can be used for creating a <b>Material</b>, which can then be assigned to a <b>Renderable</b> as normal.</p>
<h1><a class="anchor" id="surfaceShaders_b"></a>
Deferred pipeline</h1>
<p>This is the pipeline used by the <em>Standard</em> material, and is generally the preferable pipeline to use as it is usually faster, and supports a wider variety of features than the forward pipeline.</p>
<p>Deferred pipeline splits the rendering process and the lighting process. When an object is rendered, all the relevant data is output to a set of intermediate textures called the GBuffer. These textures contain all the information required for lighting, like the albedo color or the normal vectors. Lighting is then performed after all the objects have been rendered to the GBuffer.</p>
<p>Due to the way its rendering works, this pipeline is incompatible with transparent materials and can only be used for rendering opaque objects.</p>
<h2><a class="anchor" id="surfaceShaders_b_a"></a>
Surface</h2>
<p>This shader is responsible for writing the surface data into the GBuffer. Its entry point must have the following signature:</p><ul>
<li><code>void fsmain(in VStoFS input, out float4 OutGBufferA : SV_Target0, out float4 OutGBufferB : SV_Target1, out float2 OutGBufferC : SV_Target2)</code></li>
</ul>
<p>Where:</p><ul>
<li><em>input</em> - <b>VSToFS</b> structure that gets output from the vertex shader.</li>
<li><em>OutGBufferA</em>, <em>OutGBufferB</em>, <em>OutGBufferC</em> - Textures that make up the GBuffer. this is where the shader outputs will be written.</li>
</ul>
<p>The shader needs to include the following mixins:</p><ul>
<li><b>BasePass</b> (from <code>BasePass.bslinc</code>) - Performs the default per-vertex transformations and outputs data in the <b>VStoFS</b> structure. Optionally you can provide your own vertex evaluation code, as described earlier.</li>
<li><b>GBufferOutput</b> (from <code>GBufferOutput.bslinc</code>) - Provides a helper structure and method for populating the GBuffer.</li>
</ul>
<div class="fragment"><div class="line">#include &quot;$ENGINE$\BasePass.bslinc&quot;</div><div class="line">#include &quot;$ENGINE$\GBufferOutput.bslinc&quot;</div><div class="line"></div><div class="line">shader Surface</div><div class="line">{</div><div class="line">    mixin BasePass;</div><div class="line">    mixin GBufferOutput;</div><div class="line"></div><div class="line">    code</div><div class="line">    {</div><div class="line">        void fsmain(</div><div class="line">            in VStoFS input, </div><div class="line">            out float4 OutGBufferA : SV_Target0,</div><div class="line">            out float4 OutGBufferB : SV_Target1,</div><div class="line">            out float2 OutGBufferC : SV_Target2)</div><div class="line">        {</div><div class="line">            // ...</div><div class="line">        }   </div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>In the shader you'll want to populate the <b>SurfaceData</b> structure, which has the following structure: </p><div class="fragment"><div class="line">// Note that the &#39;depth&#39; field doesn&#39;t need to be populated explicitly.</div><div class="line">struct SurfaceData</div><div class="line">{</div><div class="line">    float4 albedo;</div><div class="line">    float4 worldNormal;</div><div class="line">    float depth;</div><div class="line">    float roughness;</div><div class="line">    float metalness;</div><div class="line">};</div></div><!-- fragment --><p>Once populated, you call <b>encodeGBuffer</b> method with the <b>SurfaceData</b> object, and the GBuffer textures to write the output to. The method then transfers the data written to <b>SurfaceData</b> into the GBuffer textures.</p>
<p>A complete example looks like below. For simplicity the shader only evaluates albedo from the texture, while it assumes the rest of the surface data parameters are constant.</p>
<div class="fragment"><div class="line">#include &quot;$ENGINE$\BasePass.bslinc&quot;</div><div class="line">#include &quot;$ENGINE$\GBufferOutput.bslinc&quot;</div><div class="line"></div><div class="line">shader Surface</div><div class="line">{</div><div class="line">    mixin BasePass;</div><div class="line">    mixin GBufferOutput;</div><div class="line"></div><div class="line">    code</div><div class="line">    {</div><div class="line">        SamplerState gAlbedoSamp;</div><div class="line">        Texture2D gAlbedoTex;</div><div class="line"></div><div class="line">        void fsmain(</div><div class="line">            in VStoFS input, </div><div class="line">            out float4 OutGBufferA : SV_Target0,</div><div class="line">            out float4 OutGBufferB : SV_Target1,</div><div class="line">            out float2 OutGBufferC : SV_Target2)</div><div class="line">        {</div><div class="line">            SurfaceData surfaceData;</div><div class="line">            surfaceData.albedo = gAlbedoTex.Sample(gAlbedoSamp, input.uv0);</div><div class="line">            surfaceData.worldNormal.xyz = float3(0, 1, 0);</div><div class="line">            surfaceData.roughness = 1.0f;</div><div class="line">            surfaceData.metalness = 0.0f;</div><div class="line"></div><div class="line">            encodeGBuffer(surfaceData, OutGBufferA, OutGBufferB, OutGBufferC);</div><div class="line">        }   </div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>Once the shader is created, it can be used for creating a <b>Material</b>, which can then be assigned to a <b>Renderable</b> as normal.</p>
<h2><a class="anchor" id="surfaceShaders_b_b"></a>
Lighting</h2>
<p>This type of shader allows you to override how the renderer evaluates lighting. It involves creating a set of mixins that override the existing lighting functionality. For this purpose we use the concept of subshaders, which we explained earlier in the BSL manual.</p>
<p>In order to override lighting you must implement the <b>DeferredDirectLighting</b> sub-shader, and then override one or multiple of the following mixins:</p><ul>
<li><b>StandardBRDF</b> (from <code>DirectLighting.bslinc</code>) - This mixin allows you to change how is incoming light reflected off a point using the bidirectional reflectance distribution function (BRDF). In most cases when modifying the lighting model, this is the only mixin you will want to override.</li>
<li><b>LuminanceRadial</b>, <b>LuminanceSpot</b>, <b>LuminanceDirectional</b> (from <code>DirectLighting.bslinc</code>) - This set of mixins allows you to evaluate how is lighting evaluated for radial, spot and directional lights, respectively. This is even more general than overriding the <b>StandardBRDF</b> mixin, as it allows you to control how is the lighting information evaluated before being passed along to the BRDF.</li>
</ul>
<h3><a class="anchor" id="surfaceShaders_b_b_a"></a>
Overriding the BRDF</h3>
<p><b>StandardBRDF</b> mixin contains a single method you must implement:</p><ul>
<li><code>float3 evaluateStandardBRDF(float3 V, float3 L, float specLobeEnergy, SurfaceData surfaceData)</code></li>
</ul>
<p>Where:</p><ul>
<li><em>V</em> - Normalized vector from the point being shaded, to the view origin.</li>
<li><em>L</em> - Normalized vector from the point being shaded, to the light.</li>
<li><em>specLobeEnergy</em> - Scaling factor to apply to the specular component of the BRDF.</li>
<li><em>surfaceData</em> - Information about the surface point being shaded.</li>
<li>The method returns the color of the surface. This color will be multiplied with light color and intensity to generate the final color.</li>
</ul>
<div class="fragment"><div class="line">subshader DeferredDirectLighting</div><div class="line">{</div><div class="line">    // An example shader that implements the basic Lambert BRDF</div><div class="line">    mixin StandardBRDF</div><div class="line">    {</div><div class="line">        code</div><div class="line">        {   </div><div class="line">            float3 evaluateStandardBRDF(float3 V, float3 L, float specLobeEnergy, SurfaceData surfaceData)</div><div class="line">            {</div><div class="line">                return surfaceData.albedo.rgb / 3.14f;</div><div class="line">            }</div><div class="line">        };</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="surfaceShaders_b_b_b"></a>
Overriding luminance calculations</h3>
<p><b>LuminanceRadial</b> mixin requires you to implement a single method with a following signature:</p><ul>
<li><code>float3 getLuminanceRadial(LightData lightData, float3 worldPos, float3 V, float3 R, float roughness2, SurfaceData surfaceData)</code></li>
</ul>
<p>Where:</p><ul>
<li><em>lightData</em> - A structure containing information about the light we're calculating luminance for. See below for its structure.</li>
<li><em>worldPos</em> - World position of the point being shaded.</li>
<li><em>V</em> - Normalized vector from the point being shaded, to the view origin.</li>
<li><em>R</em> - Normalized vector from the point being shaded, to the point at which specular reflections should be evaluated.</li>
<li><em>roughness2</em> - surfaceData.roughness * surfaceData.roughness</li>
<li><em>surfaceData</em> - Information about the surface point being shaded.</li>
<li>This method returns the final color of the surface after direct lighting is applied.</li>
</ul>
<div class="fragment"><div class="line">struct LightData</div><div class="line">{</div><div class="line">    // Position of the light in world space</div><div class="line">    float3 position;</div><div class="line"></div><div class="line">    // Radius at which the light should attenuate</div><div class="line">    float attRadius;</div><div class="line"></div><div class="line">    // Normalized direction of the light</div><div class="line">    float3 direction;</div><div class="line"></div><div class="line">    // Luminance (intensity) of the light</div><div class="line">    float luminance;</div><div class="line"></div><div class="line">    // x - Spot-light angle in radians</div><div class="line">    // y - Cosine of the spot-light angle</div><div class="line">    // z - 1 / (cos(spotFalloffAngle) - cos(spotAngle))</div><div class="line">    float3 spotAngles;</div><div class="line"></div><div class="line">    // 1 / (attRadius*attRadius)</div><div class="line">    float attRadiusSqrdInv;</div><div class="line"></div><div class="line">    // Color of the light</div><div class="line">    float3 color;</div><div class="line"></div><div class="line">    // Source radius if it&#39;s an area light</div><div class="line">    float srcRadius;</div><div class="line"></div><div class="line">    // Shifted position used for evaluating spot area lights</div><div class="line">    float3 shiftedLightPosition;</div><div class="line"></div><div class="line">    // Unused</div><div class="line">    float padding;</div><div class="line">};</div></div><!-- fragment --><p>An example implementation: </p><div class="fragment"><div class="line">subshader DeferredDirectLighting</div><div class="line">{</div><div class="line">    mixin LuminanceRadial</div><div class="line">    {</div><div class="line">        code</div><div class="line">        {</div><div class="line">            float3 getLuminanceRadial(LightData lightData, float3 worldPos, float3 V, float3 R, float roughness2, SurfaceData surfaceData)</div><div class="line">            {</div><div class="line">                float3 N = surfaceData.worldNormal.xyz;</div><div class="line">                float3 toLight = lightData.position - worldPos;</div><div class="line">                float distToLightSqrd = dot(toLight, toLight);</div><div class="line">                float invDistToLight = rsqrt(distToLightSqrd);</div><div class="line"></div><div class="line">                float3 L = toLight * invDistToLight;</div><div class="line">                float NoL = saturate(dot(N, L));</div><div class="line"></div><div class="line">                float illuminance = (lightData.luminance * NoL) / max(distToLightSqrd, 0.01f*0.01f);</div><div class="line">                float attenuation = distToLightSqrd * lightData.attRadiusSqrdInv;</div><div class="line">                float3 surfaceShading = evaluateStandardBRDF(V, L, 1.0f, surfaceData);</div><div class="line"></div><div class="line">                return lightData.color * illuminance * attenuation * surfaceShading;</div><div class="line">            }</div><div class="line">        };</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p><b>LuminanceSpot</b> similarily requires you to implement a single method with the following signature:</p><ul>
<li><code>float3 getLuminanceSpot(LightData lightData, float3 worldPos, float3 V, float3 R, float roughness2, SurfaceData surfaceData)</code></li>
</ul>
<p><b>LuminanceDirectional</b> also requires a single method with the following signature:</p><ul>
<li><code>float3 getLuminanceDirectional(LightData lightData, float3 worldPos, float3 V, float3 R, SurfaceData surfaceData)</code></li>
</ul>
<p>The meaning of the parametes is the same across all three functions, and they can be implemented similarily to <b>getLuminanceRadial</b>.</p>
<p>Once the shader is created you need to apply it for rendering. Because the deferred pipeline performs lighting in a separate stage from normal rendering, you cannot simply assign this material to a <b>Renderable</b>. The shader must instead be applied by calling <a class="el" href="classbs_1_1ct_1_1_renderer.html#a88d57654dc343b9772e44c6f63c36f8f">Renderer::setGlobalShaderOverride()</a>. As the name implies this will apply the shader globally, meaning it will effect lighting of all objects using the deferred pipeline.</p>
<div class="fragment"><div class="line">SPtr&lt;Shader&gt; customShader = ...; // Import the shader we created above</div><div class="line"></div><div class="line">// Apply the shader</div><div class="line">gRenderer().setGlobalShaderOverride(customShader);</div></div><!-- fragment --><h1><a class="anchor" id="surfaceShaders_c"></a>
Forward</h1>
<p>When it comes to the forward pipeline, vertex, surface and lighting aspects are all handled in the same shader. Its entry point must have the following signature:</p><ul>
<li><code>float4 fsmain(in VStoFS input) : SV_Target0</code></li>
</ul>
<p>Where:</p><ul>
<li><em>input</em> - <b>VStoFS</b> structure that was output from the vertex shader.</li>
<li>Returns the final color of the rendered pixel.</li>
</ul>
<p>The shader needs to include the following mixins:</p><ul>
<li><b>BasePass</b> (from <code>BasePass.bslinc</code>) - Performs the default per-vertex transformations and outputs data in the <b>VStoFS</b> structure. Optionally you can provide your own vertex evaluation code, as described earlier.</li>
<li><b>ForwardLighting</b> (from <code>ForwardLighting.bslinc</code>) - Contains all relevant lighting evaluation and calculation functionality. Also tells the renderer that the material will be using the forward rendering pipeline.</li>
</ul>
<div class="fragment"><div class="line">#include &quot;$ENGINE$\BasePass.bslinc&quot;</div><div class="line">#include &quot;$ENGINE$\ForwardLighting.bslinc&quot;</div><div class="line"></div><div class="line">shader Forward</div><div class="line">{</div><div class="line">    mixin BasePass;</div><div class="line">    mixin ForwardLighting;</div><div class="line"></div><div class="line">    code</div><div class="line">    {</div><div class="line">        float4 fsmain(in VStoFS input) : SV_Target0</div><div class="line">        {</div><div class="line">        {</div><div class="line">            // ...</div><div class="line">        }   </div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>Your shader then needs to populate the <b>SurfaceData</b> structure. This is the same structure as when we talked about deferred pipeline surface shaders. This structure should then be passed to the following method:</p><ul>
<li><code>float3 calcLighting(float3 worldPosition, float3 screenPosition, float2 uv, SurfaceData surfaceData)</code></li>
</ul>
<p>Where:</p><ul>
<li><em>worldPosition</em> - World position of the point being shaded.</li>
<li><em>screenPosition</em> - Screen position (in pixels) of the point being shaded. z component must contain the depth in [0, 1] range.</li>
<li><em>uv</em> - UV coordinates of the point being shaded.</li>
<li><em>surfaceData</em> - Populated <b>SurfaceData</b> structure.</li>
<li>Returns the final pixel color.</li>
</ul>
<div class="fragment"><div class="line">#include &quot;$ENGINE$\BasePass.bslinc&quot;</div><div class="line">#include &quot;$ENGINE$\ForwardLighting.bslinc&quot;</div><div class="line"></div><div class="line">shader Surface</div><div class="line">{</div><div class="line">    mixin BasePass;</div><div class="line">    mixin ForwardLighting;</div><div class="line"></div><div class="line">    code</div><div class="line">    {</div><div class="line">        SamplerState gAlbedoSamp;</div><div class="line">        Texture2D gAlbedoTex;</div><div class="line"></div><div class="line">        float4 fsmain(in VStoFS input) : SV_Target0</div><div class="line">        {</div><div class="line">            // For simplicity we only read the albedo from the texture, and assume other properties are constant</div><div class="line">            SurfaceData surfaceData;</div><div class="line">            surfaceData.albedo = gAlbedoTex.Sample(gAlbedoSamp, input.uv0);</div><div class="line">            surfaceData.worldNormal.xyz = float3(0, 1, 0);</div><div class="line">            surfaceData.roughness = 1.0f;</div><div class="line">            surfaceData.metalness = 0.0f;</div><div class="line"></div><div class="line">            float3 lighting = calcLighting(input.worldPosition.xyz, input.position, input.uv0, surfaceData);</div><div class="line">            return float4(lighting, 1.0f);</div><div class="line">        }   </div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>In order to override BRDF and luminance functions, you simply override the same mixins as for the deferred pipeline. Note that in this case we don't need to use subshaders, we just override the mixins directly.</p>
<div class="fragment"><div class="line">#include &quot;$ENGINE$\BasePass.bslinc&quot;</div><div class="line">#include &quot;$ENGINE$\ForwardLighting.bslinc&quot;</div><div class="line"></div><div class="line">shader Surface</div><div class="line">{</div><div class="line">    mixin BasePass;</div><div class="line">    mixin ForwardLighting;</div><div class="line"></div><div class="line">    code</div><div class="line">    {</div><div class="line">        // Code omitted for brevity</div><div class="line">    };</div><div class="line">};</div><div class="line"></div><div class="line">// Override the BRDF with a basic Lambert BRDF</div><div class="line">mixin StandardBRDF</div><div class="line">{</div><div class="line">    code</div><div class="line">    {</div><div class="line">        float3 evaluateStandardBRDF(float3 V, float3 L, float specLobeEnergy, SurfaceData surfaceData)</div><div class="line">        {</div><div class="line">            return surfaceData.albedo.rgb / 3.14f;</div><div class="line">        }</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>Once the shader is created, it can be used for creating a <b>Material</b>, which can then be assigned to a <b>Renderable</b> as normal. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
