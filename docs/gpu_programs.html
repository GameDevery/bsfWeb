<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - GPU programs</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='http://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="../SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="../SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">GPU programs </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#gpuPrograms_a">Creating GPU programs</a></li>
<li class="level1"><a href="#gpuPrograms_b">Using GPU programs for rendering</a></li>
<li class="level1"><a href="#gpuPrograms_c">GPU program parameters</a><ul><li class="level2"><a href="#gpuPrograms_c_a">GpuParams</a></li>
<li class="level2"><a href="#gpuPrograms_c_b">Parameter blocks</a></li>
<li class="level2"><a href="#gpuPrograms_c_c">Binding GPU params</a></li>
</ul>
</li>
<li class="level1"><a href="#gpuPrograms_d">Vertex input</a></li>
<li class="level1"><a href="#gpuPrograms_e">GLSL specifics</a></li>
</ul>
</div>
<div class="textblock"><p>GPU programs are programmable parts of the GPU pipeline, in other literature often called shaders (bs::f uses the word shader for a higher level concept, so we won't call them that). They are core objects, meaning they can be used on both sim and core threads. We'll focus on the core thread version and note the differences between the two where relevant.</p>
<p>In bs::f they are represented with the <a class="el" href="classbs_1_1ct_1_1_gpu_program.html">ct::GpuProgram</a> class. There are six types of GPU programs: vertex, hull (tesselation control), domain (tesselation evaluation), geometry, fragment (pixel) and compute programs. Each is used for a different purpose but has the same interface. We assume the user is familiar with the GPU pipeline and what the different program types do.</p>
<blockquote class="doxtable">
<p>Note that if you are using bs::f Shading Language you do not need to create GPU programs manually - any shaders you import and materials created from those shaders will have GPU programs created internally, but they will be hidden from the normal user. </p>
</blockquote>
<h1><a class="anchor" id="gpuPrograms_a"></a>
Creating GPU programs</h1>
<p>To create a GPU program call <a class="el" href="classbs_1_1ct_1_1_gpu_program.html#a9b31b2c85b57d910ba07e417686efcb2">ct::GpuProgram::create()</a> with a <a class="el" href="structbs_1_1_g_p_u___p_r_o_g_r_a_m___d_e_s_c.html">GPU_PROGRAM_DESC</a> structure. The structure needs to have the following fields populated:</p><ul>
<li><a class="el" href="structbs_1_1_g_p_u___p_r_o_g_r_a_m___d_e_s_c.html#a00baeba9d13a88ce01098a02d1e570d5">GPU_PROGRAM_DESC::source</a> - Source code of the GPU program. This should be in a language supported by the current render API (e.g. HLSL for DirectX, GLSL for OpenGL/Vulkan).</li>
<li><a class="el" href="structbs_1_1_g_p_u___p_r_o_g_r_a_m___d_e_s_c.html#a1c1daca03e1a36ae14d9adddb21f564c">GPU_PROGRAM_DESC::entryPoint</a> - Name of the entry point into the GPU program. This is the name of the function that will be called when the program is ran. Must be "main" for OpenGL &amp; Vulkan.</li>
<li><a class="el" href="structbs_1_1_g_p_u___p_r_o_g_r_a_m___d_e_s_c.html#a65c620cdd26dfb60f2a97d803919f07d">GPU_PROGRAM_DESC::language</a> - Language the source code is written in. This can be "hlsl", "glsl" or "vksl".</li>
<li><a class="el" href="structbs_1_1_g_p_u___p_r_o_g_r_a_m___d_e_s_c.html#abbcb7202f175551b69e64d29724946ba">GPU_PROGRAM_DESC::type</a> - <a class="el" href="group___utility-_core.html#gaf388801ddd39d30124c0da064556415a">GpuProgramType</a> of the GPU program (vertex, fragment, etc.).</li>
</ul>
<p>For example if we wanted to create a HLSL fragment program (HLSL source not shown): </p><div class="fragment"><div class="line"><a class="code" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> hlslSource = <span class="stringliteral">&quot;...&quot;</span>;</div><div class="line"></div><div class="line">GPU_PROGRAM_DESC desc;</div><div class="line">desc.type = <a class="code" href="group___utility-_core.html#ggaf388801ddd39d30124c0da064556415aabc1cc2bb71a739e28f5787958adada1e">GPT_FRAGMENT_PROGRAM</a>;</div><div class="line">desc.source = hlslSource;</div><div class="line">desc.entryPoint = <span class="stringliteral">&quot;main&quot;</span>;</div><div class="line">desc.language = <span class="stringliteral">&quot;hlsl&quot;</span>;</div><div class="line"></div><div class="line">SPtr&lt;GpuProgram&gt; myProgram = GpuProgram::create(desc);</div></div><!-- fragment --><p>Once the GPU program has been created it is not guaranteed to be usable. The compilation of the provided source code could have failed, which you can check by calling <a class="el" href="classbs_1_1ct_1_1_gpu_program.html#a4417b912777c7f45a0c24dc5800b75a0">ct::GpuProgram::isCompiled()</a>, and retrieve the error message by calling <a class="el" href="classbs_1_1ct_1_1_gpu_program.html#a5b4ff7ff9335320bd6ff76dfe2e633db">ct::GpuProgram::getCompileErrorMessage()</a>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(!myProgram-&gt;isCompiled())</div><div class="line">    <a class="code" href="group___debug.html#ga3d2df36e0b331304f012c778c43d86a9">gDebug</a>().<a class="code" href="classbs_1_1_debug.html#a1e5d08aa7b21855df0dd700049e73f65">logError</a>(<span class="stringliteral">&quot;GPU program compilation failed with error: &quot;</span> + myProgram-&gt;getCompileErrorMessage());</div></div><!-- fragment --><p>Be aware that shader compilation happens on the core thread. Therefore if calling these methods on the sim thread GPU program, you must first ensure the GPU program is initialized by calling <b>CoreThread::submit()</b> with <code>blockUntilComplete</code> parameter set to true, or use the core-object-specific method <a class="el" href="classbs_1_1_core_object.html#adb4ce196b1df089d67cbcca776bb1e94">GpuProgram::blockUntilCoreInitialized()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// If program is used on sim thread</span></div><div class="line">myProgram-&gt;blockUntilCoreInitialized();</div><div class="line"></div><div class="line"><span class="keywordflow">if</span>(!myProgram-&gt;isCompiled())</div><div class="line">    <a class="code" href="group___debug.html#ga3d2df36e0b331304f012c778c43d86a9">gDebug</a>().<a class="code" href="classbs_1_1_debug.html#a1e5d08aa7b21855df0dd700049e73f65">logError</a>(<span class="stringliteral">&quot;GPU program compilation failed with error: &quot;</span> + myProgram-&gt;getCompileErrorMessage());</div></div><!-- fragment --><h1><a class="anchor" id="gpuPrograms_b"></a>
Using GPU programs for rendering</h1>
<p>To use a GPU program in a draw or dispatch call, you must first create a GPU pipeline object using the relevant GPU programs. There are two types of pipeline states:</p><ul>
<li><a class="el" href="classbs_1_1ct_1_1_graphics_pipeline_state.html">ct::GraphicsPipelineState</a> - Supports vertex, hull, domain, geometry and fragment programs. At minimum requires a vertex program, while most pipelines will use vertex &amp; fragment programs.</li>
<li><a class="el" href="classbs_1_1ct_1_1_compute_pipeline_state.html">ct::ComputePipelineState</a> - Supports only the compute GPU program type.</li>
</ul>
<p>To create a graphics pipeline you need to fill out the <a class="el" href="structbs_1_1ct_1_1_p_i_p_e_l_i_n_e___s_t_a_t_e___d_e_s_c.html">ct::PIPELINE_STATE_DESC</a> structure with references to relevant GPU programs, followed by a call to <a class="el" href="classbs_1_1ct_1_1_graphics_pipeline_state.html#aaa948e95db70e260621b88b876dfcc0c">ct::GraphicsPipelineState::create()</a>.</p>
<div class="fragment"><div class="line">PIPELINE_STATE_DESC desc;</div><div class="line">desc.vertexProgram = ...;</div><div class="line">desc.fragmentProgram = myProgram; <span class="comment">// Program we created in the example above</span></div><div class="line">desc.geometryProgram = ...;</div><div class="line">desc.hullProgram = ...;</div><div class="line">desc.domainProgram = ...;</div><div class="line"></div><div class="line">SPtr&lt;GraphicsPipelineState&gt; graphicsPipeline = GraphicsPipelineState::create(desc);</div></div><!-- fragment --><blockquote class="doxtable">
<p>Note that graphics pipelines also support a set of fixed (non-programmable) states we'll discuss later. </p>
</blockquote>
<p>Compute pipeline states are simpler, accepting just a single compute GPU program as a parameter to their <a class="el" href="classbs_1_1ct_1_1_compute_pipeline_state.html#a7eaba4a10da984a005bd90f007c1a953">ct::ComputePipelineState::create()</a> method.</p>
<div class="fragment"><div class="line">SPtr&lt;GpuProgram&gt; computeProgram = ...;</div><div class="line">SPtr&lt;ComputePipelineState&gt; computePipeline = ComputePipelineState::create(computeProgram);</div></div><!-- fragment --><p>Once created pipelines can be bound for rendering through the globally accessible <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html">ct::RenderAPI</a> interface. This interface is the primary entry point in the low-level rendering API and it will be used for most low-level rendering operations, as we'll see throughout this set of manuals.</p>
<p>Call <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a7d1aae55785c78bfac4e1e8326d34413">ct::RenderAPI::setGraphicsPipeline()</a> or <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#af1470f65f420f136d5b01f2a2b0df02c">ct::RenderAPI::setComputePipeline()</a> to bind a graphics or a compute pipeline state, respectively.</p>
<div class="fragment"><div class="line"><span class="comment">// Bind pipeline for use</span></div><div class="line"></div><div class="line">RenderAPI&amp; rapi = RenderAPI::instance();</div><div class="line">rapi.setGraphicsPipeline(graphicsPipeline);</div><div class="line"><span class="comment">// Or: rapi.setComputePipeline(computePipeline);</span></div></div><!-- fragment --><p>Once bound any <em>draw</em> or <em>dispatch</em> calls will be executed using the bound pipeline states. Draw/dispatch calls are explained in more detail later on.</p>
<h1><a class="anchor" id="gpuPrograms_c"></a>
GPU program parameters</h1>
<p>Although you can use a GPU program without any parameters, most will require some additional data in order to perform their operations. Program parameters represent data that is static throughout a single GPU program execution (a draw/dispatch call). For example, when drawing a 3D object you will usually want to provide a projection matrix that transforms the object from 3D to 2D, according to the camera the user is viewing the object through.</p>
<p>You can access information about GPU program parameters by calling <a class="el" href="classbs_1_1ct_1_1_gpu_program.html#a94a3b5bcf361e073582a44c7013e92e7">ct::GpuProgram::getParamDesc()</a>. This will return a <a class="el" href="structbs_1_1_gpu_param_desc.html">GpuParamDesc</a> structure containing information about all GPU parameters used by that GPU program. This includes primitives (int, float, etc.), textures, samplers, buffers and parameter buffers (constant/uniform buffers in DirectX/OpenGL lingo).</p>
<p>You generally don't need to use this information directly. It is instead automatically parsed when you create a GPU pipeline. Once you have a pipeline you can use it to create a <a class="el" href="classbs_1_1ct_1_1_gpu_params.html">ct::GpuParams</a> object that allows you to assign values to all parameters of a specific pipeline.</p>
<h2><a class="anchor" id="gpuPrograms_c_a"></a>
GpuParams</h2>
<p><b>GpuParams</b> is a container for all parameters required by a single GPU pipeline (graphics or compute). It allows you to set primitive/texture/sampler/buffer parameters used by the GPU programs, which it stores in an internal buffer. You can then bind it to a <b>RenderAPI</b> similar to how you bind the pipeline themselves. Assigned parameter will then be used with the current pipeline in any following <em>draw</em> or <em>dispatch</em> calls.</p>
<p>To create a <b>GpuParams</b> object call <a class="el" href="classbs_1_1ct_1_1_gpu_params.html#ab6acd1559fe301889613e355e55f6efa">ct::GpuParams::create()</a> with either a graphics or a compute pipeline state as a parameter.</p>
<div class="fragment"><div class="line">SPtr&lt;GraphicsPipelineState&gt; graphicsPipeline = ...;</div><div class="line">SPtr&lt;GpuParams&gt; params = GpuParams::create(graphicsPipeline);</div></div><!-- fragment --><p>Once created you can assign values to parameter by calling any of the following methods (depending on parameter type):</p><ul>
<li><a class="el" href="classbs_1_1_t_gpu_params.html#a11d2c8fcce8b8eaf518712bdd9aa729b">ct::GpuParams::setTexture()</a> - Assigns a read-only (sampled) texture to a GPU program.</li>
<li><a class="el" href="classbs_1_1_t_gpu_params.html#a7046d12ede8b1e8e450b874f054dd2c0">ct::GpuParams::setLoadStoreTexture()</a> - Assign a load-store (writable) texture to a GPU program.</li>
<li><a class="el" href="classbs_1_1_t_gpu_params.html#a3cf68e9e77db88112370f95e3ebc4ede">ct::GpuParams::setBuffer()</a> - Assigns a buffer (either read-only or read-write) to a GPU program.</li>
<li><a class="el" href="classbs_1_1_t_gpu_params.html#a2ada463c262489265b0a615c7fee22f3">ct::GpuParams::setSamplerState()</a> - Assigns a sampler state that determines how is a sampled texture read by the shader.</li>
<li><a class="el" href="classbs_1_1_t_gpu_params.html#a0e0ab733ece5a8331730605e862036d7">ct::GpuParams::setParam()</a> - Assigns a primitive type like <em>float</em>, <em>int</em>, <b>Vector3</b>, <b>Matrix4</b> or others. Supported primitive types are:<ul>
<li><em>float</em></li>
<li><b>Vector2</b></li>
<li><b>Vector3</b></li>
<li><b>Vector4</b></li>
<li><em>int</em></li>
<li><b>Vector2I</b></li>
<li><b>Vector3I</b></li>
<li><b>Vector4I</b></li>
<li><b>Matrix3</b></li>
<li><b>Matrix4</b></li>
<li><b>Color</b> (maps to 4-component float in GPU program, same as <b>Vector4</b>)</li>
</ul>
</li>
</ul>
<p>Each of the methods accepts a <b>GpuProgramType</b> of the program whose parameter to assign, name of the parameter (as specified in the GPU program code) and a value of the parameter.</p>
<div class="fragment"><div class="line">Matrix4 viewProjMat = ...;</div><div class="line">params-&gt;setParam(<a class="code" href="group___utility-_core.html#ggaf388801ddd39d30124c0da064556415aa5893d873cc4995f47e0b988c8c67e427">GPT_VERTEX_PROGRAM</a>, <span class="stringliteral">&quot;vertProjMatrix&quot;</span>, viewProjMat);</div><div class="line"></div><div class="line">SPtr&lt;Texture&gt; someTexture = ...;</div><div class="line">params-&gt;setTexture(<a class="code" href="group___utility-_core.html#ggaf388801ddd39d30124c0da064556415aabc1cc2bb71a739e28f5787958adada1e">GPT_FRAGMENT_PROGRAM</a>, <span class="stringliteral">&quot;mainTexture&quot;</span>, someTexture);</div></div><!-- fragment --><p>If parameters are modified often you can instead use <em>parameter handles</em> for faster access. Use the following methods to retrieve a handle to the parameter:</p><ul>
<li><a class="el" href="classbs_1_1_t_gpu_params.html#aa9a6f753a393eac497c16636834f37f9">ct::GpuParams::getTextureParam()</a> - Outputs a <a class="el" href="classbs_1_1_t_gpu_param_texture.html">GpuParamTexture</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_gpu_params.html#a12553003cccbdba773d9d2630932755e">GpuParams::getLoadStoreTextureParam()</a> - Outputs a <a class="el" href="classbs_1_1_t_gpu_param_load_store_texture.html">ct::GpuParamLoadStoreTexture</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_gpu_params.html#a0e3ea085c5eff60ff68d2e1508394a1f">ct::GpuParams::getBufferParam()</a> - Outputs a <a class="el" href="classbs_1_1_t_gpu_param_buffer.html">GpuParamBuffer</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_gpu_params.html#a4792c07d684b84796a7b3cea246051b3">ct::GpuParams::getSamplerStateParam()</a> - Outputs a <a class="el" href="classbs_1_1_t_gpu_param_samp_state.html">GpuParamSampState</a> handle that can be used for reading &amp; writing the parameter value.</li>
<li><a class="el" href="classbs_1_1_t_gpu_params.html#ae57120e0d38944bc1741dd62e00f27f7">ct::GpuParams::getParam&lt;T&gt;()</a> - Outputs a <a class="el" href="classbs_1_1_t_gpu_data_param.html">TGpuDataParam&lt;T&gt;</a> handle that can be used for reading &amp; writing the parameter value.</li>
</ul>
<p>Each of the methods accepts a <b>GpuProgramType</b> of the program whose parameter to assign, name of the parameter (as specified in the GPU program code), and outputs a handle to the parameter as specified above. Handles provide <b>set()</b> and <b>get()</b> methods that can be used for writing and reading the parameter values.</p>
<div class="fragment"><div class="line"><span class="comment">// Same result as above, only using handles</span></div><div class="line">GpuParamMat4 myMatParam;</div><div class="line">GpuParamTexture myTextureParam;</div><div class="line"></div><div class="line">params-&gt;getParam(<a class="code" href="group___utility-_core.html#ggaf388801ddd39d30124c0da064556415aa5893d873cc4995f47e0b988c8c67e427">GPT_VERTEX_PROGRAM</a>, <span class="stringliteral">&quot;vertProjMatrix&quot;</span>, myMatParam);</div><div class="line">params-&gt;getTextureParam(<a class="code" href="group___utility-_core.html#ggaf388801ddd39d30124c0da064556415aabc1cc2bb71a739e28f5787958adada1e">GPT_FRAGMENT_PROGRAM</a>, <span class="stringliteral">&quot;mainTexture&quot;</span>, myTextureParam);</div><div class="line"></div><div class="line">Matrix4 viewProjMat = ...;</div><div class="line">SPtr&lt;Texture&gt; someTexture = ...;</div><div class="line"></div><div class="line">myVectorParam.set(viewProjMat);</div><div class="line">myTextureParam.set(someTexture);</div></div><!-- fragment --><p>Parameter handles can be retrieved once and stored, then used for quick access to the parameter without an otherwise expensive lookup that happens when setting parameter directly.</p>
<h2><a class="anchor" id="gpuPrograms_c_b"></a>
Parameter blocks</h2>
<p>All primitive (<em>int</em>, <em>float</em>, <b>Vector3</b>, etc.) GPU parameters are grouped in parameter blocks - each GPU program must have at least one. These are better known as <em>constant buffers</em> in DirectX or <em>uniform blocks</em> in OpenGL/Vulkan.</p>
<p>Before we can assign primitive parameters to <b>GpuParams</b> we must first allocate their parameter blocks (in the examples above we skipped this step). Parameter blocks are represented by <a class="el" href="classbs_1_1ct_1_1_gpu_param_block_buffer.html">ct::GpuParamBlockBuffer</a>. They are essentially just blocks of memory and only require a size in bytes in their call to <a class="el" href="classbs_1_1ct_1_1_gpu_param_block_buffer.html#afa10d03e60805f4a321830882a336541">ct::GpuParamBlockBuffer::create()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Buffer with 256 bytes in size</span></div><div class="line">SPtr&lt;GpuParamBlockBuffer&gt; buffer = GpuParamBlockBuffer::create(256);</div></div><!-- fragment --><p>You can find out which parameter blocks (and their sizes) a GPU program contains from its <b>GpuParamDesc</b> structure retrieved from <b>GpuProgram::getParamDesc()</b>.</p>
<div class="fragment"><div class="line"><span class="comment">// Create the first available parameter block, with adequate size to fit all of its fields</span></div><div class="line">SPtr&lt;GpuParamDesc&gt; paramDesc = myProgram-&gt;getParamDesc();</div><div class="line"></div><div class="line">SPtr&lt;GpuParamBlockBuffer&gt; buffer;</div><div class="line"><span class="keywordflow">if</span>(paramDesc.paramBlocks.size() &gt; 0)</div><div class="line">{</div><div class="line">    UINT32 sizeBytes = paramDesc.paramBlocks[0].blockSize * 4; <span class="comment">// Block size is in multiples of 4 bytes</span></div><div class="line">    buffer = GpuParamBlockBuffer::create(sizeBytes);</div><div class="line">}</div></div><!-- fragment --><p>Finally you can bind the parameter block to <b>GpuParams</b> by calling <a class="el" href="classbs_1_1_t_gpu_params.html#a6fc228c721e5881d96561fbf9e5122db">ct::GpuParams::setParamBlockBuffer()</a> with the GPU program type, parameter block variable name, and the parameter block buffer.</p>
<div class="fragment"><div class="line">params-&gt;setParamBlockBuffer(<a class="code" href="group___utility-_core.html#ggaf388801ddd39d30124c0da064556415aabc1cc2bb71a739e28f5787958adada1e">GPT_FRAGMENT_PROGRAM</a>, <span class="stringliteral">&quot;myParamBlock&quot;</span>, buffer);</div></div><!-- fragment --><p>After it is bound you we free to set primitive parameters and they will be stored in the bound buffer. This buffer can then be shared between multiple GPU programs and/or GPU pipelines.</p>
<blockquote class="doxtable">
<p>You can also write to <b>GpuParamBlockBuffer</b> directly by calling its <a class="el" href="classbs_1_1ct_1_1_gpu_param_block_buffer.html#a479a1b8e4e39db14176f1c53dd46cd74">ct::GpuParamBlockBuffer::write()</a> method. In this case you must be careful to respect the layout of the variables in the buffer as expected by the render backend. This layout can be determined by examining the other entries in <b>GpuParamDesc</b> structure. </p>
</blockquote>
<h2><a class="anchor" id="gpuPrograms_c_c"></a>
Binding GPU params</h2>
<p>Once <b>GpuParams</b> has been created and populated with necessary data, you can bind it to the GPU by calling <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ac882c9af0c546bd2405637a5373c0a99">ct::RenderAPI::setGpuParams()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// This should be called after the pipeline expecting these parameters is bound</span></div><div class="line">RenderAPI::instance().setGpuParams(params);</div></div><!-- fragment --><h1><a class="anchor" id="gpuPrograms_d"></a>
Vertex input</h1>
<p>Vertex GPU programs provide information about their inputs in the form of a <b>VertexDeclaration</b>. This is the same structure that we used for describing per-vertex components while creating a mesh. Per-vertex input declaration can be retrieved from a GPU program by calling <a class="el" href="classbs_1_1ct_1_1_gpu_program.html#a6b66f87f9f71e3d764abdfc595857033">ct::GpuProgram::getInputDeclaration()</a>.</p>
<div class="fragment"><div class="line">SPtr&lt;GpuProgram&gt; vertProg = ...;</div><div class="line">SPtr&lt;VertexDeclaration&gt; inputs = vertProg-&gt;getInputDeclaration();</div></div><!-- fragment --><p>Input declaration can be used for creating meshes or vertex buffers that provide per-vertex information that a GPU program expects.</p>
<blockquote class="doxtable">
<p>Note: This method is only available on the core thread version of <b>GpuProgram</b>. </p>
</blockquote>
<h1><a class="anchor" id="gpuPrograms_e"></a>
GLSL specifics</h1>
<p>When declaring vertex inputs for a GPU program written in GLSL you should use the following variable names depending on the input usage:</p><ul>
<li>bs_position - Vertex position</li>
<li>bs_normal - Vertex normal</li>
<li>bs_tangent - Vertex tangent</li>
<li>bs_bitangent - Vertex bitangent</li>
<li>bs_texcoord - Vertex UV</li>
<li>bs_color - Vertex color</li>
<li>bs_blendweights - Blend weights used for skinning</li>
<li>bs_blendindices - Blend indices used for skinning</li>
</ul>
<p>This allows the system to map the semantics specified in <b>VertexDeclaration</b> of the bound mesh or vertex buffer to the GPU program inputs. This is not required for HLSL as HLSL has built-in support for semantics which are used instead.</p>
<p>You can append 0-8 to the names to receive more than one element of the same name. Actual types of these elements, as well as the data stored by them doesn't need to match the names and it's up to the user to provide whatever data he needs. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
