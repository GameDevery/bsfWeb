<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - BSL syntax</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='http://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="../SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="../SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">BSL syntax </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bsl_a">Basics</a></li>
<li class="level1"><a href="#bsl_b">Non-programmable states</a><ul><li class="level2"><a href="#bsl_b_a">raster</a></li>
<li class="level2"><a href="#bsl_b_b">depth</a></li>
<li class="level2"><a href="#bsl_b_c">stencil</a></li>
<li class="level2"><a href="#bsl_b_d">blend</a></li>
</ul>
</li>
<li class="level1"><a href="#bsl_c">Mixins</a><ul><li class="level2"><a href="#bsl_c_a">Mixin overrides</a></li>
</ul>
</li>
<li class="level1"><a href="#bsl_d">Passes</a></li>
<li class="level1"><a href="#bsl_e">Default values</a></li>
<li class="level1"><a href="#bsl_f">Attributes</a></li>
<li class="level1"><a href="#bsl_g">Global options</a></li>
<li class="level1"><a href="#bsl_h">Variations</a></li>
<li class="level1"><a href="#bsl_i">Sub-shaders</a></li>
</ul>
</div>
<div class="textblock"><p>All shaders in bs::f are written in BSL (bs::f Shading Language). The core of the language is based on HLSL (High Level Shading Language), with various extensions to make development easier. In this manual we will not cover HLSL syntax, nor talk about shaders in general, and will instead focus on the functionality specific to BSL. If you are not familiar with the concept of a shader, or HLSL syntax, it is suggested you learn about them before continuing.</p>
<h1><a class="anchor" id="bsl_a"></a>
Basics</h1>
<p>A simple BSL program that renders a mesh all in white looks like this: </p><div class="fragment"><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    code</div><div class="line">    {</div><div class="line">        struct VStoFS</div><div class="line">        {</div><div class="line">            float4 position : SV_Position;</div><div class="line">        };</div><div class="line"></div><div class="line">        cbuffer PerObject</div><div class="line">        {</div><div class="line">            float4x4 gMatWorldViewProj;</div><div class="line">        }               </div><div class="line"></div><div class="line">        struct VertexInput</div><div class="line">        {</div><div class="line">            float3 position : POSITION;</div><div class="line">        };</div><div class="line"></div><div class="line">        VStoFS vsmain(VertexInput input)</div><div class="line">        {</div><div class="line">            VStoFS output;</div><div class="line"></div><div class="line">            output.position = mul(gMatWorldViewProj, input.position);           </div><div class="line">            return output;</div><div class="line">        }</div><div class="line"></div><div class="line">        float4 fsmain(in VStoFS input) : SV_Target0</div><div class="line">        {</div><div class="line">            return float4(1.0f, 1.0f, 1.0f 1.0f); </div><div class="line">        }   </div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>As you can see, aside from the <b>shader</b> and <b>code</b> blocks, the shader code looks identical to HLSL. Inside the <b>shader</b> block you can use a variety of options, but the minimum required is the <b>code</b> block, which allows you to specify programmable shader code. Inside the <b>code</b> block you get to use the full power of HLSL, as if you were using it directly.</p>
<p>There are a few restrictions compared to normal HLSL that you must be aware of:</p><ul>
<li>All primitive (non-object) shader constants (uniforms in GLSL lingo) must be part of a <b>cbuffer</b>. Primitive types are any types that are not textures, buffers or samplers.</li>
<li>Entry points for specific shader stages must have specific names. In the example above <b>vsmain</b> serves as the entry point for the vertex shader, while <b>fsmain</b> serves as the entry point for the fragment (pixel) shader. The full list of entry point names per type:<ul>
<li><b>vsmain</b> - Vertex shader</li>
<li><b>gsmain</b> - Geometry shader</li>
<li><b>hsmain</b> - Hull (Tesselation control) shader</li>
<li><b>dsmain</b> - Domain (Tesselation evaluation) shader</li>
<li><b>fsmain</b> - Fragment (Pixel) shader</li>
<li><b>csmain</b> - Compute shader</li>
</ul>
</li>
</ul>
<p>Let's now move onto more advanced functionality specific to BSL.</p>
<h1><a class="anchor" id="bsl_b"></a>
Non-programmable states</h1>
<p>Aside from the <b>code</b> block, a <b>shader</b> can also specify four blocks that allow it to control non-programmable parts of the pipeline:</p><ul>
<li><b>raster</b> - Allows you to set options related to rasterization, like rasterization mode (fill/wireframe), cull mode, etc.</li>
<li><b>depth</b> - Allows you to set options related to depth buffer and depth comparison, like enabling/disabling depth reads or writes, or changing the depth comparison function</li>
<li><b>stencil</b> - Allows you to set options related to the stencil buffer and stencil test, like enabling stencil test and setting the test operations</li>
<li><b>blend</b> - Allows you to set blending options, like enabling/disabling blending, setting blend operations or setting color the write mask</li>
</ul>
<p>An example shader using a variety of these blocks is shown: </p><div class="fragment"><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    // No depth reads or writes</div><div class="line">    depth</div><div class="line">    {</div><div class="line">        read = false;</div><div class="line">        write = false;</div><div class="line">    };</div><div class="line"></div><div class="line">    // Enable blending on the first render target</div><div class="line">    blend</div><div class="line">    {</div><div class="line">        target  </div><div class="line">        {</div><div class="line">            enabled = true;</div><div class="line">            color = { srcA, srcIA, add };</div><div class="line">            writemask = RGB;</div><div class="line">        };</div><div class="line">    };</div><div class="line"></div><div class="line">    // Disable culling</div><div class="line">    raster</div><div class="line">    {</div><div class="line">        cull = none;</div><div class="line">    };</div><div class="line"></div><div class="line">    // Only render if stencil test passes</div><div class="line">    stencil</div><div class="line">    {</div><div class="line">        enabled = true;</div><div class="line">        front = { keep, keep, keep, lte };</div><div class="line">        reference = 1;</div><div class="line">    };</div><div class="line"></div><div class="line">    code</div><div class="line">    {</div><div class="line">        // ... some shader code</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>Let's cover all available options for each block type.</p>
<h2><a class="anchor" id="bsl_b_a"></a>
raster</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Valid values  </th><th class="markdownTableHeadNone">Reference   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fill  </td><td class="markdownTableBodyNone">wire, solid (See <a class="el" href="group___utility-_core.html#gaa2371b6569c7a782419ffaeb50b97fa7">PolygonMode</a>)  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_r_a_s_t_e_r_i_z_e_r___s_t_a_t_e___d_e_s_c.html#ac3254846f8dc0547996c86a20205778e">RASTERIZER_STATE_DESC::polygonMode</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">cull  </td><td class="markdownTableBodyNone">cw, ccw, none (See <a class="el" href="group___utility-_core.html#ga75343d54117298210d7b858147c3486e">CullingMode</a>)  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_r_a_s_t_e_r_i_z_e_r___s_t_a_t_e___d_e_s_c.html#ad197a0724a817cae1ca6bea1a87f0109">RASTERIZER_STATE_DESC::cullMode</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">scissor  </td><td class="markdownTableBodyNone">true, false  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_r_a_s_t_e_r_i_z_e_r___s_t_a_t_e___d_e_s_c.html#a52b4cdd20f7f4847f7a3fdec28c2565c">RASTERIZER_STATE_DESC::scissorEnable</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">multisample  </td><td class="markdownTableBodyNone">true, false  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_r_a_s_t_e_r_i_z_e_r___s_t_a_t_e___d_e_s_c.html#afd18336ae8c43b91c95ee1143d8e3bf7">RASTERIZER_STATE_DESC::multisampleEnable</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">lineaa  </td><td class="markdownTableBodyNone">true, false  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_r_a_s_t_e_r_i_z_e_r___s_t_a_t_e___d_e_s_c.html#a5e83624750785537c8a23e42750703ce">RASTERIZER_STATE_DESC::antialiasedLineEnable</a>   </td></tr>
</table>
<h2><a class="anchor" id="bsl_b_b"></a>
depth</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Valid values  </th><th class="markdownTableHeadNone">Reference   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">read  </td><td class="markdownTableBodyNone">true, false  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#a576b2d867bebcdb3a143ae6575b0d656">DEPTH_STENCIL_STATE_DESC::depthReadEnable</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">write  </td><td class="markdownTableBodyNone">true, false  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#a1944b0918378af218375dd45c1f191d1">DEPTH_STENCIL_STATE_DESC::depthWriteEnable</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">compare  </td><td class="markdownTableBodyNone">never, always, lt, lte, eq, neq, gte, gt (See <a class="el" href="group___utility-_core.html#ga36e1a5e792be24b3d1ed4f5fabea818d">CompareFunction</a>)  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#aec945d931a9e22cbf9ec2ffdf6a4a929">DEPTH_STENCIL_STATE_DESC::depthComparisonFunc</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">bias  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_r_a_s_t_e_r_i_z_e_r___s_t_a_t_e___d_e_s_c.html#a2894fe1122185e1e681e79ab7cfeb8d6">RASTERIZER_STATE_DESC::depthBias</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">scaledBias  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_r_a_s_t_e_r_i_z_e_r___s_t_a_t_e___d_e_s_c.html#a7d6c8cc49b0374cb87605d24acacd4e2">RASTERIZER_STATE_DESC::slopeScaledDepthBias</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">clip  </td><td class="markdownTableBodyNone">true, false  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_r_a_s_t_e_r_i_z_e_r___s_t_a_t_e___d_e_s_c.html#a19c867eb902deeadc492fa246f662b29">RASTERIZER_STATE_DESC::depthClipEnable</a>   </td></tr>
</table>
<h2><a class="anchor" id="bsl_b_c"></a>
stencil</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Valid values  </th><th class="markdownTableHeadNone">Reference   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">reference  </td><td class="markdownTableBodyNone">integer  </td><td class="markdownTableBodyNone">Reference value to use for stencil compare operations.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">enabled  </td><td class="markdownTableBodyNone">true, false  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#a742c8a0eb885bafbc3f607d76fa5063a">DEPTH_STENCIL_STATE_DESC::stencilEnable</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">readmask  </td><td class="markdownTableBodyNone">integer in [0, 255] range  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#a4ce5ff3c09a958e01d0bae6d31c46603">DEPTH_STENCIL_STATE_DESC::stencilReadMask</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">writemask  </td><td class="markdownTableBodyNone">integer in [0, 255] range  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#aacf2530c93539496f69b011707e15b04">DEPTH_STENCIL_STATE_DESC::stencilWriteMask</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">front  </td><td class="markdownTableBodyNone">StencilOp block  </td><td class="markdownTableBodyNone">Stencil operations and compare function for front facing geometry   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">back  </td><td class="markdownTableBodyNone">StencilOp block  </td><td class="markdownTableBodyNone">Stencil operations and compare function for back facing geometry   </td></tr>
</table>
<p><b>front</b> and <b>back</b> options are blocks themselves, and they accept the following options: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Valid values  </th><th class="markdownTableHeadNone">Reference   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fail  </td><td class="markdownTableBodyNone">keep, zero, replace, inc, dec, incwrap, decwrap, inverse (See <a class="el" href="group___utility-_core.html#gac692ecc1ffb4255c8c8628a3ce6f7a4b">StencilOperation</a>)  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#ad218388dfdf6057fdd20571147117c84">DEPTH_STENCIL_STATE_DESC::frontStencilFailOp</a> &amp; <a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#a5c7a31368b0c271c5b39b9a65b9d3144">DEPTH_STENCIL_STATE_DESC::backStencilFailOp</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">zfail  </td><td class="markdownTableBodyNone">keep, zero, replace, inc, dec, incwrap, decwrap, inverse (See <a class="el" href="group___utility-_core.html#gac692ecc1ffb4255c8c8628a3ce6f7a4b">StencilOperation</a>)  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#a1888675900435a2c677023a724b3a722">DEPTH_STENCIL_STATE_DESC::frontStencilZFailOp</a> &amp; <a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#a0e144620b888d2581d4aa88cce4e36c3">DEPTH_STENCIL_STATE_DESC::backStencilZFailOp</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">pass  </td><td class="markdownTableBodyNone">keep, zero, replace, inc, dec, incwrap, decwrap, inverse (See <a class="el" href="group___utility-_core.html#gac692ecc1ffb4255c8c8628a3ce6f7a4b">StencilOperation</a>)  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#ae150f96aebf42cd8163fe1e82687c17d">DEPTH_STENCIL_STATE_DESC::frontStencilPassOp</a> &amp; <a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#a62ea9f2f58c0bb9e0c0b31b4526eef4d">DEPTH_STENCIL_STATE_DESC::backStencilPassOp</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">compare  </td><td class="markdownTableBodyNone">never, always, lt, lte, eq, neq, gte, gt (See <a class="el" href="group___utility-_core.html#ga36e1a5e792be24b3d1ed4f5fabea818d">CompareFunction</a>)  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#aede07c1c2842655b8ecb694b7ad3ca00">DEPTH_STENCIL_STATE_DESC::frontStencilComparisonFunc</a> &amp; <a class="el" href="structbs_1_1_d_e_p_t_h___s_t_e_n_c_i_l___s_t_a_t_e___d_e_s_c.html#a1f3b3122ecd3dde946dd8aa362e65db9">DEPTH_STENCIL_STATE_DESC::backStencilComparisonFunc</a>   </td></tr>
</table>
<p>An example of a stencil block: </p><div class="fragment"><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    // Only render if stencil test passes</div><div class="line">    stencil</div><div class="line">    {</div><div class="line">        enabled = true;</div><div class="line">        front = { </div><div class="line">            fail = keep; // On stencil test fail don&#39;t do anything</div><div class="line">            zfail = keep; // On depth test fail don&#39;t do anything</div><div class="line">            pass = inc; // On stencil test pass, increment stencil buffer by one</div><div class="line">            compare = always; // Always pass the stencil test</div><div class="line">        };</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p><b>StencilOp</b> block can also be declared succintly on a single line. Same code as above, written differently: </p><div class="fragment"><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    // Only render if stencil test passes</div><div class="line">    stencil</div><div class="line">    {</div><div class="line">        enabled = true;</div><div class="line">        front = { keep, keep, inc, always }; // Note the order is always: fail op., zfail op., pass op., compare function</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="bsl_b_d"></a>
blend</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Valid values  </th><th class="markdownTableHeadNone">Reference   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dither  </td><td class="markdownTableBodyNone">true, false  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_b_l_e_n_d___s_t_a_t_e___d_e_s_c.html#ace0672cdd09f7c7c47d807dbaa1fcfd4">BLEND_STATE_DESC::alphaToCoverageEnable</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">independant  </td><td class="markdownTableBodyNone">true, false  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_b_l_e_n_d___s_t_a_t_e___d_e_s_c.html#ac7b902aa4447c90cfb7ccaeefd3b5657">BLEND_STATE_DESC::independantBlendEnable</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">target  </td><td class="markdownTableBodyNone">Target block  </td><td class="markdownTableBodyNone">Blend operations for a specific render target. Multiple Target blocks can exist under a single blend block.   </td></tr>
</table>
<p><b>Target</b> block accepts the following options: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Valid values  </th><th class="markdownTableHeadNone">Reference   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">index  </td><td class="markdownTableBodyNone">positive integer  </td><td class="markdownTableBodyNone">Index of the render target these options are applied to. If not specified the index is derived from the order in which Target blocks are defined.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">enabled  </td><td class="markdownTableBodyNone">true, false  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_r_e_n_d_e_r___t_a_r_g_e_t___b_l_e_n_d___s_t_a_t_e___d_e_s_c.html#af69e3282d64f8cfe88a2759960788417">RENDER_TARGET_BLEND_STATE_DESC::blendEnable</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">writemask  </td><td class="markdownTableBodyNone">R, G, B, A or any combination (e.g. RG, RBA, RGBA). "empty" for zero mask.  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_r_e_n_d_e_r___t_a_r_g_e_t___b_l_e_n_d___s_t_a_t_e___d_e_s_c.html#a5bb23278117ac137ae41fecc019400ed">RENDER_TARGET_BLEND_STATE_DESC::renderTargetWriteMask</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">color  </td><td class="markdownTableBodyNone">BlendOp block  </td><td class="markdownTableBodyNone">Represents the blend operation to execute on the color channels.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">alpha  </td><td class="markdownTableBodyNone">BlendOp block  </td><td class="markdownTableBodyNone">Represents the blend operation to execute on the alpha channel. Only relevant if independant blend is enabled.   </td></tr>
</table>
<p><b>BlendOp</b> block accepts the following options: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Valid values  </th><th class="markdownTableHeadNone">Reference   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">source  </td><td class="markdownTableBodyNone">one, zero, dstRGB, srcRGB, dstIRGB, srcIRGB, dstA, srcA, dstIA, srcIA (See <a class="el" href="group___utility-_core.html#ga39e43a2b0694d3f59c3ae3b942651d88">BlendFactor</a>)  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_r_e_n_d_e_r___t_a_r_g_e_t___b_l_e_n_d___s_t_a_t_e___d_e_s_c.html#a78c96890e8fda78fcc15f213ccb5e9fa">RENDER_TARGET_BLEND_STATE_DESC::srcBlend</a>, <a class="el" href="structbs_1_1_r_e_n_d_e_r___t_a_r_g_e_t___b_l_e_n_d___s_t_a_t_e___d_e_s_c.html#aa9bd58fcbd1ae8117f789bc76dd89493">RENDER_TARGET_BLEND_STATE_DESC::srcBlendAlpha</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">dest  </td><td class="markdownTableBodyNone">one, zero, dstRGB, srcRGB, dstIRGB, srcIRGB, dstA, srcA, dstIA, srcIA (See <a class="el" href="group___utility-_core.html#ga39e43a2b0694d3f59c3ae3b942651d88">BlendFactor</a>)  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_r_e_n_d_e_r___t_a_r_g_e_t___b_l_e_n_d___s_t_a_t_e___d_e_s_c.html#a546dd8734e5ce077168e7281a3284c61">RENDER_TARGET_BLEND_STATE_DESC::dstBlend</a>, <a class="el" href="structbs_1_1_r_e_n_d_e_r___t_a_r_g_e_t___b_l_e_n_d___s_t_a_t_e___d_e_s_c.html#a6749e302212c90a50d42ed7727ac5d90">RENDER_TARGET_BLEND_STATE_DESC::dstBlendAlpha</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">op  </td><td class="markdownTableBodyNone">add, sub, rsub, min, max (See <a class="el" href="group___utility-_core.html#gad3316ff174eff6a45c45f0e90d84eabe">BlendOperation</a>)  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_r_e_n_d_e_r___t_a_r_g_e_t___b_l_e_n_d___s_t_a_t_e___d_e_s_c.html#afccd835533d5f6b413b8751ba2c867d7">RENDER_TARGET_BLEND_STATE_DESC::blendOp</a>, <a class="el" href="structbs_1_1_r_e_n_d_e_r___t_a_r_g_e_t___b_l_e_n_d___s_t_a_t_e___d_e_s_c.html#a35b2ace218d6eb3cf968f2426e2a7e66">RENDER_TARGET_BLEND_STATE_DESC::blendOpAlpha</a>   </td></tr>
</table>
<p>An example of a <b>blend</b> block: </p><div class="fragment"><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    blend</div><div class="line">    {</div><div class="line">        target  </div><div class="line">        {</div><div class="line">            enabled = true;</div><div class="line">            color = { </div><div class="line">                source = srcA;</div><div class="line">                dest = srcIA;</div><div class="line">                op = add;</div><div class="line">            };</div><div class="line">            writemask = RGB;</div><div class="line">        };</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p><b>BlendOp</b> block can also be defined succintly on a single line. Same code as above, written differently: </p><div class="fragment"><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    blend</div><div class="line">    {</div><div class="line">        target  </div><div class="line">        {</div><div class="line">            enabled = true;</div><div class="line">            color = { srcA, srcIA, add }; // Note the order is always: source, destination, operation</div><div class="line">            writemask = RGB;</div><div class="line">        };</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><h1><a class="anchor" id="bsl_c"></a>
Mixins</h1>
<p>When writing complex shaders is it is often useful to break them up into components. This is where the concept of a <b>mixin</b> comes in. Any shader code or programmable states defined in a <b>mixin</b> can be included in any <b>shader</b>, or in another <b>mixin</b>. Syntax within a <b>mixin</b> block is identical to syntax in a <b>shader</b> block, meaning you can define code and non-programmable state blocks as shown above.</p>
<div class="fragment"><div class="line">// Provides common functionality that might be useful for many different shaders</div><div class="line">mixin MyMixin</div><div class="line">{</div><div class="line">    code</div><div class="line">    {</div><div class="line">        Texture2D gGBufferAlbedoTex;</div><div class="line">        Texture2D gDepthBufferTex;</div><div class="line"></div><div class="line">        struct SurfaceData </div><div class="line">        {</div><div class="line">            float4 albedo;</div><div class="line">            float depth;</div><div class="line">        };</div><div class="line"></div><div class="line">        SurfaceData getGBufferData(uint2 pixelPos)</div><div class="line">        {</div><div class="line">            SurfaceData output;</div><div class="line">            output.albedo = gGBufferAlbedoTex.Load(int3(pixelPos, 0));</div><div class="line">            output.depth = gDepthBufferTex.Load(int3(pixelPos, 0)).r;</div><div class="line"></div><div class="line">            return output;</div><div class="line">        }           </div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>When a shader wishes to use a mixin, simply add it to the shader using the same <b>mixin</b> keyword, followed by its name. </p><div class="fragment"><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    mixin MyMixin;</div><div class="line"></div><div class="line">    code</div><div class="line">    {</div><div class="line">        // ...</div><div class="line"></div><div class="line">        float4 fsmain(in VStoFS input) : SV_Target0</div><div class="line">        {</div><div class="line">            uint2 pixelPos = ...;</div><div class="line"></div><div class="line">            // We can now call methods from the mixin</div><div class="line">            SurfaceData surfaceData = getGBufferData(pixelPos);</div><div class="line"></div><div class="line">            return surfaceData.albedo; </div><div class="line">        }   </div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>Included mixins will append their shader code and states to the shader they are included in. If mixin and shader define the same states, the value of the states present on the shader will be used. If multiple included mixins use the same state then the state from the last included mixin will be used. Code is included in the order in which mixins are defined, followed by code from the shader itself.</p>
<p>Often you will want to define mixins in separate files. BSL files are normally stored with the ".bsl" extension, but when writing include files you should use the ".bslinc" extension instead, in order to prevent the system trying to compile the shader code on its own.</p>
<p>In order to include other files in BSL, use the #include command. The paths are relative to the working folder, or if you are working in Banshee 3D editor, the paths are relative to your project folder. You can use the special variables $ENGINE$ and $EDITOR$ to access paths to the builtin engine and editor shaders.</p>
<div class="fragment"><div class="line">// Include the code for accessing the GBuffer</div><div class="line">#include &quot;$ENGINE$/GBufferInput.bslinc&quot;</div><div class="line"></div><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    mixin GBufferInput;</div><div class="line"></div><div class="line">    // ...</div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="bsl_c_a"></a>
Mixin overrides</h2>
<p>Mixins can override each other if another mixin is defined with the same name. The last defined mixin is considered the override and will be used in the shader. Shaders can also reference mixins that haven't been declared yet. This concept of mixin overrides allows you to change functionality of complex shaders without having to be aware of any code other than the mixin you are overriding. This concept is heavily used when writing surface and lighting shaders, as described in a later manual.</p>
<div class="fragment"><div class="line">// This mixin overrides the MyMixin behaviour we defined above</div><div class="line">mixin MyMixin</div><div class="line">{</div><div class="line">    code</div><div class="line">    {</div><div class="line">        struct SurfaceData </div><div class="line">        {</div><div class="line">            float4 albedo;</div><div class="line">            float depth;</div><div class="line">        };</div><div class="line"></div><div class="line">        SurfaceData getGBufferData(uint2 pixelPos)</div><div class="line">        {</div><div class="line">            SurfaceData output;</div><div class="line">            output.albedo = float4(1, 0, 0, 1); // Always return red color</div><div class="line">            output.depth = 0.0f;</div><div class="line"></div><div class="line">            return output;</div><div class="line">        }           </div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><h1><a class="anchor" id="bsl_d"></a>
Passes</h1>
<p>Passes can be used when a shader needs to perform multiple complex operations in a sequence. Each pass can be thought of as its own fully functional shader. By default shaders have one pass, which doesn't have to be explicitly defined, as was the case in all examples above. To explicitly define a pass, use the <b>pass</b> block and define the relevant code/state blocks within it, same as it was shown for shaders above. Passes will be executed sequentially one after another in the order they are defined.</p>
<div class="fragment"><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    // First pass</div><div class="line">    pass</div><div class="line">    {</div><div class="line">        code</div><div class="line">        {</div><div class="line">            // Some shader code </div><div class="line">        };</div><div class="line">    };</div><div class="line"></div><div class="line">    // Second pass</div><div class="line">    pass</div><div class="line">    {</div><div class="line">        // Enable blending so data written by this pass gets blended with data from the previous pass</div><div class="line">        blend</div><div class="line">        {</div><div class="line">            target  </div><div class="line">            {</div><div class="line">                enabled = true;</div><div class="line">                color = { </div><div class="line">                    source = srcA;</div><div class="line">                    dest = srcIA;</div><div class="line">                    op = add;</div><div class="line">                };</div><div class="line">                writemask = RGB;</div><div class="line">            };</div><div class="line">        };  </div><div class="line"></div><div class="line">        code</div><div class="line">        {</div><div class="line">            // Some shader code</div><div class="line">        };</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><h1><a class="anchor" id="bsl_e"></a>
Default values</h1>
<p>All constants (uniforms) of primitive types can be assigned default values. These values will be used if the user doesn't assign the values explicitly. The relevant syntax is:</p><ul>
<li>For scalars: "type name = value;"</li>
<li>For vectors/matrices: "type name = { v0, v1, ... };", where the number of values is the total number of elements in a vector/matrix</li>
</ul>
<div class="fragment"><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    code</div><div class="line">    {</div><div class="line">        cbuffer SomeBuffer</div><div class="line">        {</div><div class="line">            bool val1 = false;</div><div class="line">            float val2 = 5.0f;</div><div class="line">            float3 val3 = { 0.0f, 1.0f, 2.0f };</div><div class="line">            float2x2 val4 = { 0.0f, 1.0f, 2.0f, 3.0f };</div><div class="line">        };</div><div class="line"></div><div class="line">        // ... remaining shader code</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>Textures can also be assigned default values, limited to a specific subset. Valid set of values is:</p><ul>
<li>white - All white texture</li>
<li>black - All black texture</li>
<li>normal - Texture representing a normal map with normals facing in the Y (up) direction</li>
</ul>
<div class="fragment"><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    code</div><div class="line">    {</div><div class="line">        Texture2D albedoMap = black;</div><div class="line">        Texture2D normalMap = normal;</div><div class="line"></div><div class="line">        // ... remaining shader code</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>Finally, sampler states may also be assigned default values. The values are specified in a block immediately following the sampler state definition.</p>
<div class="fragment"><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    code</div><div class="line">    {</div><div class="line">        SamplerState MySampler</div><div class="line">        {</div><div class="line">            Filter = MIN_MAG_MIP_LINEAR;</div><div class="line">            AddressU = Wrap;</div><div class="line">            AddressV = Wrap;</div><div class="line">        };</div><div class="line"></div><div class="line">        // ... remaining shader code</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>Valid values within the sampler state block are: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Valid values  </th><th class="markdownTableHeadNone">Reference   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">AddressU  </td><td class="markdownTableBodyNone">WRAP, MIRROR, CLAMP, BORDER, MIRROR_ONCE  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_s_a_m_p_l_e_r___s_t_a_t_e___d_e_s_c.html#a9bf4d84bc0992c41d1567f2b284b0e1d">SAMPLER_STATE_DESC::addressMode</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">AddressV  </td><td class="markdownTableBodyNone">WRAP, MIRROR, CLAMP, BORDER, MIRROR_ONCE  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_s_a_m_p_l_e_r___s_t_a_t_e___d_e_s_c.html#a9bf4d84bc0992c41d1567f2b284b0e1d">SAMPLER_STATE_DESC::addressMode</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">AddressW  </td><td class="markdownTableBodyNone">WRAP, MIRROR, CLAMP, BORDER, MIRROR_ONCE  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_s_a_m_p_l_e_r___s_t_a_t_e___d_e_s_c.html#a9bf4d84bc0992c41d1567f2b284b0e1d">SAMPLER_STATE_DESC::addressMode</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">BorderColor  </td><td class="markdownTableBodyNone">float4  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_s_a_m_p_l_e_r___s_t_a_t_e___d_e_s_c.html#a025f6b594225be22eb00f2699608adad">SAMPLER_STATE_DESC::borderColor</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Filter  </td><td class="markdownTableBodyNone">See table below  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_s_a_m_p_l_e_r___s_t_a_t_e___d_e_s_c.html#a81c76e175b15ae8aa246385eade11447">SAMPLER_STATE_DESC::minFilter</a>, <a class="el" href="structbs_1_1_s_a_m_p_l_e_r___s_t_a_t_e___d_e_s_c.html#add5bcb256b88795801e4154b2968f5d5">SAMPLER_STATE_DESC::magFilter</a>, <a class="el" href="structbs_1_1_s_a_m_p_l_e_r___s_t_a_t_e___d_e_s_c.html#a243ee071eebc3d95d330c9ed9c22aec4">SAMPLER_STATE_DESC::mipFilter</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">MaxAnisotropy  </td><td class="markdownTableBodyNone">uint  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_s_a_m_p_l_e_r___s_t_a_t_e___d_e_s_c.html#a3e9581cba882adbc48138bdceb7dc119">SAMPLER_STATE_DESC::maxAniso</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MaxLOD  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_s_a_m_p_l_e_r___s_t_a_t_e___d_e_s_c.html#a172b5ec3251464d8bbdd0a6ba3c8f8d1">SAMPLER_STATE_DESC::mipMax</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">MinLOD  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_s_a_m_p_l_e_r___s_t_a_t_e___d_e_s_c.html#ab9575c4117c73d587df29871bc09816a">SAMPLER_STATE_DESC::mipMin</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MipLODBias  </td><td class="markdownTableBodyNone">float  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_s_a_m_p_l_e_r___s_t_a_t_e___d_e_s_c.html#a0b7da88bf3da3d791249473961763aa2">SAMPLER_STATE_DESC::mipmapBias</a>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">ComparisonFunc  </td><td class="markdownTableBodyNone">NEVER, LESS, EQUAL, LESS_EQUAL, GREATER, NOT_EQUAL, GREATER_EQUAL, ALWAYS  </td><td class="markdownTableBodyNone"><a class="el" href="structbs_1_1_s_a_m_p_l_e_r___s_t_a_t_e___d_e_s_c.html#a7d72a8b950de6ccb5801bbabcb92f07e">SAMPLER_STATE_DESC::comparisonFunc</a>   </td></tr>
</table>
<p>Filter valid values:</p><ul>
<li>MIN_MAG_MIP_POINT</li>
<li>MIN_MAG_POINT_MIP_LINEAR</li>
<li>MIN_POINT_MAG_LINEAR_MIP_POINT</li>
<li>MIN_POINT_MAG_MIP_LINEAR</li>
<li>MIN_LINEAR_MAG_MIP_POINT</li>
<li>MIN_LINEAR_MAG_POINT_MIP_LINEAR</li>
<li>MIN_MAG_LINEAR_MIP_POINT</li>
<li>MIN_MAG_MIP_LINEAR</li>
<li>ANISOTROPIC</li>
<li>COMPARISON_MIN_MAG_MIP_POINT</li>
<li>COMPARISON_MIN_MAG_POINT_MIP_LINEAR</li>
<li>COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT</li>
<li>COMPARISON_MIN_POINT_MAG_MIP_LINEAR</li>
<li>COMPARISON_MIN_LINEAR_MAG_MIP_POINT</li>
<li>COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR</li>
<li>COMPARISON_MIN_MAG_LINEAR_MIP_POINT</li>
<li>COMPARISON_MIN_MAG_MIP_LINEAR</li>
<li>COMPARISON_ANISOTROPIC</li>
<li>MINIMUM_MIN_MAG_MIP_POINT</li>
<li>MINIMUM_MIN_MAG_POINT_MIP_LINEAR</li>
<li>MINIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT</li>
<li>MINIMUM_MIN_POINT_MAG_MIP_LINEAR</li>
<li>MINIMUM_MIN_LINEAR_MAG_MIP_POINT</li>
<li>MINIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR</li>
<li>MINIMUM_MIN_MAG_LINEAR_MIP_POINT</li>
<li>MINIMUM_MIN_MAG_MIP_LINEAR</li>
<li>MINIMUM_ANISOTROPIC</li>
<li>MAXIMUM_MIN_MAG_MIP_POINT</li>
<li>MAXIMUM_MIN_MAG_POINT_MIP_LINEAR</li>
<li>MAXIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT</li>
<li>MAXIMUM_MIN_POINT_MAG_MIP_LINEAR</li>
<li>MAXIMUM_MIN_LINEAR_MAG_MIP_POINT</li>
<li>MAXIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR</li>
<li>MAXIMUM_MIN_MAG_LINEAR_MIP_POINT</li>
<li>MAXIMUM_MIN_MAG_MIP_LINEAR</li>
<li>MAXIMUM_ANISOTROPIC</li>
</ul>
<blockquote class="doxtable">
<p>Note: Sampler state default values use the same syntax as HLSL Effects framework. </p>
</blockquote>
<h1><a class="anchor" id="bsl_f"></a>
Attributes</h1>
<p>BSL provides a couple of extension attributes that can be applied to constants (uniforms) or constant (uniform) blocks. Attributes are specified using the standard HSLS [] attribute syntax.</p>
<div class="fragment"><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    code</div><div class="line">    {</div><div class="line">        [someAttribute]</div><div class="line">        Texture2D someMap;</div><div class="line"></div><div class="line">        [someAttributeWithParameters(p0, p1)]</div><div class="line">        Texture2D someMap2;</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>Supported attribute types are: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Parameters  </th><th class="markdownTableHeadNone">Usable on  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">internal  </td><td class="markdownTableBodyNone">none  </td><td class="markdownTableBodyNone">constants and cbuffers  </td><td class="markdownTableBodyNone">Forces the constant (or all the constants in a buffer if applied to cbuffer) to be hidden from the materials public interface (editor UI or <b>Material</b> API). This is useful for constants that are set by the engine itself and shouldn't be touched by normal users. Additionaly internal cbuffers must be explicitly created and assigned by the low level rendering API, as they will not be created automatically.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">color  </td><td class="markdownTableBodyNone">none  </td><td class="markdownTableBodyNone">float3 or float4 constants  </td><td class="markdownTableBodyNone">Marks the floating point vector as a color. This ensures the constant is displayed as a color in the editor UI (with access to a color picker), and is represented by the <b>Color</b> structure in <b>Material</b> API.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">layout  </td><td class="markdownTableBodyNone">See table below  </td><td class="markdownTableBodyNone">RW texture or buffer constant  </td><td class="markdownTableBodyNone">Used primarily as compatibility with OpenGL and Vulkan code, which require read-write objects (e.g. <b>RWTexture</b>) to have an explicit layout provided in shader. This is only required when READING from a read-write object AND when you will be using either OpenGL or Vulkan render backend.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">alias  </td><td class="markdownTableBodyNone">Texture name  </td><td class="markdownTableBodyNone">SamplerState  </td><td class="markdownTableBodyNone">Allows you to provide an alternative name to a SamplerState. This is important when using render backends like OpenGL, which may not support separate sampler states. In these cases the sampler state will be 'merged' with the texture it is used on. This means all internal systems will report the name of this sampler to be the same as the name of the texture, rather than the given name. In this case you will want to explictly add an <code>alias(TextureName)</code> attribute so the system knows this sampler state might have an alternative name.   </td></tr>
</table>
<p><b>layout</b> valid values:</p><ul>
<li>rgba32f</li>
<li>rgba16f</li>
<li>rg32f</li>
<li>rg16f</li>
<li>r11f_g11f_b10f</li>
<li>r32f</li>
<li>r16f</li>
<li>rgba16</li>
<li>rgb10_a2</li>
<li>rgba8</li>
<li>rg16</li>
<li>rg8</li>
<li>r16</li>
<li>r8</li>
<li>rgba16_snorm</li>
<li>rgba8_snorm</li>
<li>rg16_snorm</li>
<li>rg8_snorm</li>
<li>r16_snorm</li>
<li>r8_snorm</li>
<li>rgba32i</li>
<li>rgba16i</li>
<li>rgba8i</li>
<li>rg32i</li>
<li>rg16i</li>
<li>rg8i</li>
<li>r32i</li>
<li>r16i</li>
<li>r8i</li>
<li>rgba32ui</li>
<li>rgba16ui</li>
<li>rgb10_a2ui</li>
<li>rgba8ui</li>
<li>rg32ui</li>
<li>rg16ui</li>
<li>rg8ui</li>
<li>r32ui</li>
<li>r16ui</li>
<li>r8ui</li>
</ul>
<p>Where:</p><ul>
<li>letters "rgba" represent the number of channels</li>
<li>numbers represent number of bits per channel</li>
<li>"f" - floating point</li>
<li>"snorm" - normalized real in [-1, 1] range (internally backed by a signed integer)</li>
<li>"i" - signed integer</li>
<li>"ui" - unsigned integer</li>
<li>no suffix - normalized real in [0, 1] range (internally backed by an unsigned integer)</li>
</ul>
<p>Example of attributes in action: </p><div class="fragment"><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    code</div><div class="line">    {</div><div class="line">        // Hide from public interface</div><div class="line">        [internal]</div><div class="line">        Texture2D someMap;</div><div class="line"></div><div class="line">        cbuffer SomeBuffer</div><div class="line">        {</div><div class="line">            float3 position;</div><div class="line"></div><div class="line">            // Interpret as color, instead of a 3D vector</div><div class="line">            [color]</div><div class="line">            float3 tint;</div><div class="line">        };      </div><div class="line"></div><div class="line">        // Texture contains 4-channel 16-bit floating point data, and we plan on reading from it</div><div class="line">        [layout(rgba16f))]</div><div class="line">        RWTexture2D someMap2;</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><h1><a class="anchor" id="bsl_g"></a>
Global options</h1>
<p>BSL supports a few global options that control all shaders and mixins in a shader file. These options are specified in a <b>options</b> block, which must be defined at the top most level along with <b>shader</b> or <b>mixin</b> blocks.</p>
<div class="fragment"><div class="line">options</div><div class="line">{</div><div class="line">    separable = true;</div><div class="line">    sort = backtofront;</div><div class="line">    transparent = true;</div><div class="line">    priority = 100;</div><div class="line">};</div><div class="line"></div><div class="line">shader MyShader</div><div class="line">{</div><div class="line">    // Shader definition</div><div class="line">};</div></div><!-- fragment --><p>Valid options are: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Valid values  </th><th class="markdownTableHeadNone">Default value  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">separable  </td><td class="markdownTableBodyNone">true, false  </td><td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">When true, tells the renderer that passes within the shader don't need to be renderered one straight after another. This allows the system to perform rendering more optimally, but can be unfeasible for most materials which will depend on exact rendering order. Only relevant if a shader has multiple passes.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">sort  </td><td class="markdownTableBodyNone">none, backtofront, fronttoback  </td><td class="markdownTableBodyNone">fronttoback  </td><td class="markdownTableBodyNone">Determines how does the renderer sort objects with this material before rendering. Most objects should be sorted front to back in order to avoid overdraw. Transparent (see below) objects will always be sorted back to front and this option is ignored. When no sorting is active the system will try to group objects based on the material alone, reducing material switching and potentially reducing CPU overhead, at the cost of overdraw.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">transparent  </td><td class="markdownTableBodyNone">true, false  </td><td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">Notifies the renderer that this object is see-through. This will force the renderer to the use back to front sorting mode, and likely employ a different rendering method. Attempting to render transparent geometry without this option set to true will likely result in graphical artifacts.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">forward  </td><td class="markdownTableBodyNone">true, false  </td><td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">Notifies the renderer that this object should be rendered using the forward rendering pipeline (as opposed to a deferred one).   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">priority  </td><td class="markdownTableBodyNone">integer  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">Allows you to force objects with this shader to render before others. Objects with higher priority will be rendered before those with lower priority. If sorting is enabled, objects will be sorted within their priority groups (i.e. priority takes precedence over sort mode).   </td></tr>
</table>
<h1><a class="anchor" id="bsl_h"></a>
Variations</h1>
<p>Sometimes you need a few versions of the same shader, that are mostly similar but have some minor differences between them. For example, when rendering objects you might need to support a vertex shader for static meshes, as well as those using skinned and/or morph animation.</p>
<p>This is where the <b>variation</b> block comes into play. It allows you to specify a set of permutations for which the shader will be compiled. During shader import every permutation of that shader will be parsed, enabling pre-processor #define blocks depending on the current permutation. The #defines take on the name of their variation, and one of the user provided values.</p>
<div class="fragment"><div class="line">// An example shader supporting different mesh animation modes</div><div class="line">shader VertexInput</div><div class="line">{</div><div class="line">    // This will be be compiled using 4 different variations:</div><div class="line">    // - Static (no animation) (SKINNED = false, MORPH = false)</div><div class="line">    // - Skinned animation (SKINNED = true, MORPH = false)</div><div class="line">    // - Morph animation (SKINNED = false, MORPH = true)</div><div class="line">    // - Skinned morph animation (SKINNED = true, MORPH = true)</div><div class="line">    variations</div><div class="line">    {</div><div class="line">        SKINNED = { false, true };</div><div class="line">        MORPH = { false, true };</div><div class="line">    };</div><div class="line"></div><div class="line">    code</div><div class="line">    {</div><div class="line">        struct VertexInput</div><div class="line">        {</div><div class="line">            float3 position : POSITION;</div><div class="line">            float3 normal : NORMAL; // Note: Half-precision could be used</div><div class="line">            float4 tangent : TANGENT; // Note: Half-precision could be used</div><div class="line">            float2 uv0 : TEXCOORD0;</div><div class="line"></div><div class="line">            #if SKINNED</div><div class="line">                uint4 blendIndices : BLENDINDICES;</div><div class="line">                float4 blendWeights : BLENDWEIGHT;</div><div class="line">            #endif</div><div class="line"></div><div class="line">            #if MORPH</div><div class="line">                float3 deltaPosition : POSITION1;</div><div class="line">                float4 deltaNormal : NORMAL1;</div><div class="line">            #endif              </div><div class="line">        };</div><div class="line"></div><div class="line">        // Potentially more code...</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>The syntax within the <b>variation</b> block is as follows:</p><ul>
<li><code>IDENTIFIER = { bool/int, bool/int, ... }</code></li>
</ul>
<p>Each variation block can have one or multiple entries. Each must have a unique identifier. Each entry can take on two or more values, each representing a single variation. The values must be boolean (true/false), or integers. If there are multiple variation entries, a variation for each possible combination of their values will be created.</p>
<p>Once a shader with variations is imported, those variations will be available on the shader in the form of <b>Technique</b> objects. In general variations are only required when working with the low level rendering API, therefore we discuss techniques in more details in the developer manuals.</p>
<h1><a class="anchor" id="bsl_i"></a>
Sub-shaders</h1>
<p>Each BSL file can contain an optional set of sub-shaders, alongside the main shader. Sub-shaders are recognized by the renderer and are meant to allow the user to override functionality of default shaders used by the renderer. They are specified using the <b>subshader</b> keyword, followed by an unique identifier. Sub-shaders are only allowed to contain <b>mixin</b> blocks, within which the same rules as for normal mixins apply.</p>
<div class="fragment"><div class="line">shader MainShader</div><div class="line">{</div><div class="line">    // Shader definition</div><div class="line">};</div><div class="line"></div><div class="line">subshader SomeSubShader</div><div class="line">{</div><div class="line">    mixin SomeMixin</div><div class="line">    {</div><div class="line">        // Mixin definition</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>The mixins you specify in a sub-shader will be used to override some existing mixin, allowing you to change specific rendering functionality.</p>
<p>Imagine for example that you wanted to implement a custom lighting model while using deferred rendering. Deferred rendering doesn't perform lighting when rendering the object, instead it does lighting in a single pass for all objects at once. The renderer will closely interact with that lighting shader, and if you wanted to change it you would need to rewrite it using the exact rules as the renderer expects. Worse yet, the renderer might support different forms of deferred rendering (e.g. standard vs. tiled), meaning you would need to write multiple shaders to fully support it. You would also need to keep your shader(s) updated whenever the renderer's internal change. For a normal user this is very difficult and requires detailed knowledge of how the renderer works.</p>
<p>bsf's renderer instead provides a set of "extension points". Extension points match to a specific part of the renderer pipeline that can be overriden. For example an extension point named "DeferredDirectLighting" would let you override the BRDF and direct lighting calculations during deferred rendering. Sub-shaders are how you "link" with those extension points. The name of the sub-shader corresponds to the extension point name, and the mixins in the sub-shader override specific functionality of that extension point. For example you might override the "StandardBRDF" mixin to change the BRDF model for the standard material, or "LuminanceSpot" to change how is luminance for spot lights calculated.</p>
<p>This way you only override small parts of the renderer shader code, without having to rewrite all the complex shader code, while all the implementation details are transparently handled by the renderer itself.</p>
<div class="fragment"><div class="line">// Sub-shader overriding direct lighting used for deferred rendering</div><div class="line">subshader DeferredDirectLighting // Name of the subshader specifies exactly what part of the rendering pipeline to override</div><div class="line">{</div><div class="line">    // Exact name of the mixin to override. Each subshader extension point can provide one or multiple mixins that can be overriden</div><div class="line">    mixin StandardBRDF</div><div class="line">    {</div><div class="line">        // Override the PBR BRDF with a simple Lambert BRDF</div><div class="line">        float3 evaluateStandardBRDF(float3 V, float3 L, float specLobeEnergy, SurfaceData surfaceData)</div><div class="line">        {</div><div class="line">            return surfaceData.albedo.rgb / 3.14f;</div><div class="line">        }</div><div class="line">    };</div><div class="line">};</div></div><!-- fragment --><p>In a later manual we will provide a list of all extension points that the default renderer provides, as well as the mixins that can be overriden, and their required method signatures. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
