<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - HardwareBuffer Class Reference</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='http://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="../SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="../SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebs.html">bs</a></li><li class="navelem"><a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Methods</a> &#124;
<a href="classbs_1_1_hardware_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HardwareBuffer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group___internals.html">Internals</a> &raquo; <a class="el" href="group___internal-_core.html">Core</a> &raquo; <a class="el" href="group___render_a_p_i-_internal.html">RenderAPI</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Abstract class defining common features of hardware buffers. </p>
<p>Hardware buffers usually represent areas of memory the GPU or the driver can access directly.</p>
<dl class="section note"><dt>Note</dt><dd>Core thread only. </dd>
<dd>
Be aware that reading from non-system memory hardware buffers is usually slow and should be avoided. </dd></dl>
</div>
<p>Inherited by <a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html">D3D11HardwareBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_gpu_buffer.html">GpuBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_index_buffer.html">IndexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_vertex_buffer.html">VertexBuffer</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_hardware_buffer.html">VulkanHardwareBuffer</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Methods</h2></td></tr>
<tr class="memitem:a0cbc193b72c0af3780c5f354dd4c821f"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#a0cbc193b72c0af3780c5f354dd4c821f">lock</a> (UINT32 offset, UINT32 length, <a class="el" href="group___utility-_core.html#gab3f183d1c687b60796c72dda0073e2f3">GpuLockOptions</a> options, UINT32 deviceIdx=0, UINT32 queueIdx=0)</td></tr>
<tr class="memdesc:a0cbc193b72c0af3780c5f354dd4c821f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks a portion of the buffer and returns pointer to the locked area.  <a href="#a0cbc193b72c0af3780c5f354dd4c821f">More...</a><br /></td></tr>
<tr class="separator:a0cbc193b72c0af3780c5f354dd4c821f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f10c4c910370528770f31eeb68937fe"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#a6f10c4c910370528770f31eeb68937fe">lock</a> (<a class="el" href="group___utility-_core.html#gab3f183d1c687b60796c72dda0073e2f3">GpuLockOptions</a> options, UINT32 deviceIdx=0, UINT32 queueIdx=0)</td></tr>
<tr class="memdesc:a6f10c4c910370528770f31eeb68937fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the entire buffer and returns pointer to the locked area.  <a href="#a6f10c4c910370528770f31eeb68937fe">More...</a><br /></td></tr>
<tr class="separator:a6f10c4c910370528770f31eeb68937fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f018536d482152b993f522d8d2942d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#ae6f018536d482152b993f522d8d2942d">unlock</a> ()</td></tr>
<tr class="memdesc:ae6f018536d482152b993f522d8d2942d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on this buffer.  <a href="#ae6f018536d482152b993f522d8d2942d">More...</a><br /></td></tr>
<tr class="separator:ae6f018536d482152b993f522d8d2942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533ab13e635c42121fec740dc7b695cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#a533ab13e635c42121fec740dc7b695cc">readData</a> (UINT32 offset, UINT32 length, void *dest, UINT32 deviceIdx=0, UINT32 queueIdx=0)=0</td></tr>
<tr class="memdesc:a533ab13e635c42121fec740dc7b695cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from a portion of the buffer and copies it to the destination buffer.  <a href="#a533ab13e635c42121fec740dc7b695cc">More...</a><br /></td></tr>
<tr class="separator:a533ab13e635c42121fec740dc7b695cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed63b4da7c915f4b42e08824c4e60020"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#aed63b4da7c915f4b42e08824c4e60020">writeData</a> (UINT32 offset, UINT32 length, const void *source, <a class="el" href="group___utility-_core.html#gaa97ce01a8dbe96664979215009cc2c29">BufferWriteType</a> writeFlags=<a class="el" href="group___utility-_core.html#ggaa97ce01a8dbe96664979215009cc2c29ac9486c8284a168cdbce33184a6c34dff">BWT_NORMAL</a>, UINT32 queueIdx=0)=0</td></tr>
<tr class="memdesc:aed63b4da7c915f4b42e08824c4e60020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data into a portion of the buffer from the source memory.  <a href="#aed63b4da7c915f4b42e08824c4e60020">More...</a><br /></td></tr>
<tr class="separator:aed63b4da7c915f4b42e08824c4e60020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2db96da569923dd85906763e9b92479"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#af2db96da569923dd85906763e9b92479">copyData</a> (<a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;srcBuffer, UINT32 srcOffset, UINT32 dstOffset, UINT32 length, bool discardWholeBuffer=false, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">ct::CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:af2db96da569923dd85906763e9b92479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a specific portion of the source buffer into a specific portion of this buffer.  <a href="#af2db96da569923dd85906763e9b92479">More...</a><br /></td></tr>
<tr class="separator:af2db96da569923dd85906763e9b92479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e45e589fe2a5541b6f0d410bb310fe8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#a5e45e589fe2a5541b6f0d410bb310fe8">copyData</a> (<a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;srcBuffer, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">ct::CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)</td></tr>
<tr class="memdesc:a5e45e589fe2a5541b6f0d410bb310fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the provided buffer into this buffer.  <a href="#a5e45e589fe2a5541b6f0d410bb310fe8">More...</a><br /></td></tr>
<tr class="separator:a5e45e589fe2a5541b6f0d410bb310fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee07b35f394554713293253d46e4260d"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#aee07b35f394554713293253d46e4260d">getSize</a> () const</td></tr>
<tr class="memdesc:aee07b35f394554713293253d46e4260d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of this buffer in bytes.  <a href="#aee07b35f394554713293253d46e4260d">More...</a><br /></td></tr>
<tr class="separator:aee07b35f394554713293253d46e4260d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43966e19963e4bcb7f7f9b5327ec732b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#a43966e19963e4bcb7f7f9b5327ec732b">isLocked</a> () const</td></tr>
<tr class="memdesc:a43966e19963e4bcb7f7f9b5327ec732b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this buffer is currently locked.  <a href="#a43966e19963e4bcb7f7f9b5327ec732b">More...</a><br /></td></tr>
<tr class="separator:a43966e19963e4bcb7f7f9b5327ec732b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Method documentation</h2>
<a id="af2db96da569923dd85906763e9b92479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2db96da569923dd85906763e9b92479">&#9670;&nbsp;</a></span>copyData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>srcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>dstOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discardWholeBuffer</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">ct::CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a specific portion of the source buffer into a specific portion of this buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBuffer</td><td>Buffer to copy from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcOffset</td><td>Offset into the source buffer to start copying from, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstOffset</td><td>Offset into this buffer to start copying to, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Size of the data to copy, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discardWholeBuffer</td><td>Specify true if the data in the current buffer can be entirely discarded. This may improve performance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Command buffer to queue the copy operation on. If null, main command buffer is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e45e589fe2a5541b6f0d410bb310fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e45e589fe2a5541b6f0d410bb310fe8">&#9670;&nbsp;</a></span>copyData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">ct::CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data from the provided buffer into this buffer. </p>
<p>If buffers are not the same size, smaller size will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBuffer</td><td>Hardware buffer to copy from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Command buffer to queue the copy operation on. If null, main command buffer is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee07b35f394554713293253d46e4260d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee07b35f394554713293253d46e4260d">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of this buffer in bytes. </p>

</div>
</div>
<a id="a43966e19963e4bcb7f7f9b5327ec732b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43966e19963e4bcb7f7f9b5327ec732b">&#9670;&nbsp;</a></span>isLocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isLocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not this buffer is currently locked. </p>

</div>
</div>
<a id="a0cbc193b72c0af3780c5f354dd4c821f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbc193b72c0af3780c5f354dd4c821f">&#9670;&nbsp;</a></span>lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* lock </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gab3f183d1c687b60796c72dda0073e2f3">GpuLockOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>deviceIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>queueIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks a portion of the buffer and returns pointer to the locked area. </p>
<p>You must call <a class="el" href="classbs_1_1_hardware_buffer.html#ae6f018536d482152b993f522d8d2942d" title="Releases the lock on this buffer. ">unlock()</a> when done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes from which to lock the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the area you want to lock, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Signifies what you want to do with the returned pointer. Caller must ensure not to do anything he hasn't requested (for example don't try to read from the buffer unless you requested it here). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceIdx</td><td>Index of the device whose memory to map. If the buffer doesn't exist on this device, the method returns null. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueIdx</td><td>Device queue to perform any read/write operations on. See <a class="el" href="queues_doc.html">Device queues</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_gpu_buffer.html#a26b30626f079fec8c0f519ad82d7241c">D3D11GpuBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#a26b30626f079fec8c0f519ad82d7241c">GLGpuBuffer</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_gpu_buffer.html#a26b30626f079fec8c0f519ad82d7241c">VulkanGpuBuffer</a>.</p>

</div>
</div>
<a id="a6f10c4c910370528770f31eeb68937fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f10c4c910370528770f31eeb68937fe">&#9670;&nbsp;</a></span>lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gab3f183d1c687b60796c72dda0073e2f3">GpuLockOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>deviceIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>queueIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the entire buffer and returns pointer to the locked area. </p>
<p>You must call <a class="el" href="classbs_1_1_hardware_buffer.html#ae6f018536d482152b993f522d8d2942d" title="Releases the lock on this buffer. ">unlock()</a> when done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Signifies what you want to do with the returned pointer. Caller must ensure not to do anything he hasn't requested (for example don't try to read from the buffer unless you requested it here). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceIdx</td><td>Index of the device whose memory to map. If the buffer doesn't exist on this device, the method returns null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueIdx</td><td>Device queue to perform any read/write operations on. See <a class="el" href="queues_doc.html">Device queues</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaf76c7aeec7b89f59488046d23e9253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf76c7aeec7b89f59488046d23e9253">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* map </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gab3f183d1c687b60796c72dda0073e2f3">GpuLockOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>deviceIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>queueIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks a portion of the buffer and returns pointer to the locked area. <br />
 </p>
<p>You must call <a class="el" href="classbs_1_1_hardware_buffer.html#ae6f018536d482152b993f522d8d2942d" title="Releases the lock on this buffer. ">unlock()</a> when done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes from which to lock the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the area you want to lock, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Signifies what you want to do with the returned pointer. Caller must ensure not to do anything he hasn't requested (for example don't try to read from the buffer unless you requested it here). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceIdx</td><td>Index of the device whose memory to map. If the buffer doesn't exist on this device, the method returns null. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueIdx</td><td>Device queue to perform any read/write operations on. See <a class="el" href="queues_doc.html">Device queues</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classbs_1_1ct_1_1_vulkan_hardware_buffer.html#aa3e703d2f1b77e2483451a0950aff082">VulkanHardwareBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#aa3e703d2f1b77e2483451a0950aff082">D3D11HardwareBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_g_l_vertex_buffer.html#aa3e703d2f1b77e2483451a0950aff082">GLVertexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_g_l_index_buffer.html#aa3e703d2f1b77e2483451a0950aff082">GLIndexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_index_buffer.html#aa3e703d2f1b77e2483451a0950aff082">VulkanIndexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_vertex_buffer.html#aa3e703d2f1b77e2483451a0950aff082">VulkanVertexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_index_buffer.html#aa3e703d2f1b77e2483451a0950aff082">D3D11IndexBuffer</a>, and <a class="el" href="classbs_1_1ct_1_1_d3_d11_vertex_buffer.html#aa3e703d2f1b77e2483451a0950aff082">D3D11VertexBuffer</a>.</p>

</div>
</div>
<a id="a533ab13e635c42121fec740dc7b695cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533ab13e635c42121fec740dc7b695cc">&#9670;&nbsp;</a></span>readData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void readData </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>deviceIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>queueIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from a portion of the buffer and copies it to the destination buffer. </p>
<p>Caller must ensure destination buffer is large enough.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes from which to copy the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the area you want to copy, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Destination buffer large enough to store the read data. Data is written from the start of the buffer (<code>offset</code> is only applied to the source). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceIdx</td><td>Index of the device whose memory to read. If the buffer doesn't exist on this device, no data will be read. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueIdx</td><td>Device queue to perform the read operation on. See <a class="el" href="queues_doc.html">Device queues</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_vulkan_hardware_buffer.html#a0e39463e9ce0f7d3875682503f0eb529">VulkanHardwareBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#a0e39463e9ce0f7d3875682503f0eb529">D3D11HardwareBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_gpu_buffer.html#a0e39463e9ce0f7d3875682503f0eb529">D3D11GpuBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#a0e39463e9ce0f7d3875682503f0eb529">GLGpuBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_gpu_buffer.html#a0e39463e9ce0f7d3875682503f0eb529">VulkanGpuBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_index_buffer.html#a0e39463e9ce0f7d3875682503f0eb529">D3D11IndexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_vertex_buffer.html#a0e39463e9ce0f7d3875682503f0eb529">D3D11VertexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_g_l_vertex_buffer.html#a0e39463e9ce0f7d3875682503f0eb529">GLVertexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_g_l_index_buffer.html#a0e39463e9ce0f7d3875682503f0eb529">GLIndexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_index_buffer.html#a0e39463e9ce0f7d3875682503f0eb529">VulkanIndexBuffer</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_vertex_buffer.html#a0e39463e9ce0f7d3875682503f0eb529">VulkanVertexBuffer</a>.</p>

</div>
</div>
<a id="ae6f018536d482152b993f522d8d2942d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f018536d482152b993f522d8d2942d">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock on this buffer. </p>

<p>Reimplemented in <a class="el" href="classbs_1_1ct_1_1_d3_d11_gpu_buffer.html#a333677ac769a10df2775f24893e07c21">D3D11GpuBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#a333677ac769a10df2775f24893e07c21">GLGpuBuffer</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_gpu_buffer.html#a333677ac769a10df2775f24893e07c21">VulkanGpuBuffer</a>.</p>

</div>
</div>
<a id="a4c528e19a2cbd1b9a315a3db6fdcacdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c528e19a2cbd1b9a315a3db6fdcacdc">&#9670;&nbsp;</a></span>unmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void unmap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock on this buffer. <br />
 </p>

<p>Reimplemented in <a class="el" href="classbs_1_1ct_1_1_vulkan_hardware_buffer.html#a7deff0e432f0883942948c55c12673d2">VulkanHardwareBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#a7deff0e432f0883942948c55c12673d2">D3D11HardwareBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_g_l_vertex_buffer.html#a7deff0e432f0883942948c55c12673d2">GLVertexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_g_l_index_buffer.html#a7deff0e432f0883942948c55c12673d2">GLIndexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_index_buffer.html#a7deff0e432f0883942948c55c12673d2">VulkanIndexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_vertex_buffer.html#a7deff0e432f0883942948c55c12673d2">VulkanVertexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_index_buffer.html#a7deff0e432f0883942948c55c12673d2">D3D11IndexBuffer</a>, and <a class="el" href="classbs_1_1ct_1_1_d3_d11_vertex_buffer.html#a4320a7165098608a2513f88128c7b205">D3D11VertexBuffer</a>.</p>

</div>
</div>
<a id="aed63b4da7c915f4b42e08824c4e60020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed63b4da7c915f4b42e08824c4e60020">&#9670;&nbsp;</a></span>writeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void writeData </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gaa97ce01a8dbe96664979215009cc2c29">BufferWriteType</a>&#160;</td>
          <td class="paramname"><em>writeFlags</em> = <code><a class="el" href="group___utility-_core.html#ggaa97ce01a8dbe96664979215009cc2c29ac9486c8284a168cdbce33184a6c34dff">BWT_NORMAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>queueIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data into a portion of the buffer from the source memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes from which to copy the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the area you want to copy, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source buffer containing the data to write. Data is read from the start of the buffer (<code>offset</code> is only applied to the destination). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">writeFlags</td><td>Optional write flags that may affect performance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueIdx</td><td>Device queue to perform the write operation on. See <a class="el" href="queues_doc.html">Device queues</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classbs_1_1ct_1_1_vulkan_hardware_buffer.html#ac0ab1f124cb7354ab62b5453562f32a9">VulkanHardwareBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_hardware_buffer.html#ac0ab1f124cb7354ab62b5453562f32a9">D3D11HardwareBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_gpu_buffer.html#ac0ab1f124cb7354ab62b5453562f32a9">D3D11GpuBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#ac0ab1f124cb7354ab62b5453562f32a9">GLGpuBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_gpu_buffer.html#ac0ab1f124cb7354ab62b5453562f32a9">VulkanGpuBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_index_buffer.html#ac0ab1f124cb7354ab62b5453562f32a9">D3D11IndexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_d3_d11_vertex_buffer.html#ac0ab1f124cb7354ab62b5453562f32a9">D3D11VertexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_g_l_vertex_buffer.html#ac0ab1f124cb7354ab62b5453562f32a9">GLVertexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_g_l_index_buffer.html#ac0ab1f124cb7354ab62b5453562f32a9">GLIndexBuffer</a>, <a class="el" href="classbs_1_1ct_1_1_vulkan_index_buffer.html#ac0ab1f124cb7354ab62b5453562f32a9">VulkanIndexBuffer</a>, and <a class="el" href="classbs_1_1ct_1_1_vulkan_vertex_buffer.html#ac0ab1f124cb7354ab62b5453562f32a9">VulkanVertexBuffer</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a32356bb620b55c7d6f2636a93b051f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32356bb620b55c7d6f2636a93b051f86">&#9670;&nbsp;</a></span>HardwareBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the buffer, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
