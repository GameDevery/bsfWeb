<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-120676613-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-120676613-1');
</script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - Advanced textures</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='https://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Advanced textures </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#advancedTextures_a">Creating textures</a></li>
<li class="level1"><a href="#advancedTextures_b">Writing data</a><ul><li class="level2"><a href="#advancedTextures_b_a">Writing to sub-resources</a></li>
<li class="level2"><a href="#advancedTextures_b_b">Discard on write</a></li>
<li class="level2"><a href="#advancedTextures_b_c">Generating mip-maps</a></li>
<li class="level2"><a href="#advancedTextures_b_d">Writing compressed data</a></li>
<li class="level2"><a href="#advancedTextures_b_e">Creating textures with data</a></li>
</ul>
</li>
<li class="level1"><a href="#advancedTextures_c">Reading texture data</a><ul><li class="level2"><a href="#advancedTextures_c_a">Reading cached CPU data</a></li>
<li class="level2"><a href="#advancedTextures_c_b">Reading GPU data</a></li>
</ul>
</li>
<li class="level1"><a href="#advancedTextures_d">Other</a></li>
</ul>
</div>
<div class="textblock"><p>In this manual we'll learn how to create textures manually, modify their contents and even read-back texture data that was written on the GPU.</p>
<h1><a class="anchor" id="advancedTextures_a"></a>
Creating textures</h1>
<p>To create a texture call <a class="el" href="classbs_1_1_texture.html#a2d159661bb17a26b7277801ec25a3877">Texture::create()</a>. You'll need to populate the <a class="el" href="structbs_1_1_t_e_x_t_u_r_e___d_e_s_c.html">TEXTURE_DESC</a> structure and pass it as a parameter. The structure requires you to populate these properties at minimum:</p><ul>
<li><a class="el" href="structbs_1_1_t_e_x_t_u_r_e___d_e_s_c.html#a6d0659bb23ff72a9d7acd1ff2745b82b">TEXTURE_DESC::type</a> - Allows you to choose between 1D/2D/3D or cube-map textures using the <a class="el" href="group___utility-_core.html#ga65468556d79304b3a4bfc464cc12e549">TextureType</a> enum</li>
<li><a class="el" href="structbs_1_1_t_e_x_t_u_r_e___d_e_s_c.html#a66a9a92335243033aaf7ac4bd401f78f">TEXTURE_DESC::format</a> - Allows you to choose a format for each individual pixel in the texture, using the <a class="el" href="group___resources.html#ga60883d4958a60b91661e97027a85072a">PixelFormat</a> enum</li>
<li><a class="el" href="structbs_1_1_t_e_x_t_u_r_e___d_e_s_c.html#a3c22ff514988933119b1154530e70d02">TEXTURE_DESC::width</a> - Width of the texture, in pixels</li>
<li><a class="el" href="structbs_1_1_t_e_x_t_u_r_e___d_e_s_c.html#a46648f9451b96e05271ba6c0356a861b">TEXTURE_DESC::height</a> - Height of the texture, in pixels. Not relevant for 1D textures.</li>
<li><a class="el" href="structbs_1_1_t_e_x_t_u_r_e___d_e_s_c.html#ac0ca3561d182e21b3a316040a7ad20e4">TEXTURE_DESC::depth</a> - Depth of the texture, in pixels. Only relevant for 3D textures.</li>
</ul>
<p>When it comes to texture types there four kinds of textures:</p><ul>
<li><a class="el" href="group___utility-_core.html#gga65468556d79304b3a4bfc464cc12e549af1f3aaec6e9df0405da1083913874147">TextureType::TEX_TYPE_1D</a> - A one-dimensional texture, containing just one row of pixels. Rarely used.</li>
<li><a class="el" href="group___utility-_core.html#gga65468556d79304b3a4bfc464cc12e549af7fefc7c59368fca229966f3b463309b">TextureType::TEX_TYPE_2D</a> - A two-dimensional texture, most commonly used type.</li>
<li><a class="el" href="group___utility-_core.html#gga65468556d79304b3a4bfc464cc12e549acee7be64493f2a50acbf58354b528d28">TextureType::TEX_TYPE_3D</a> - A three-dimensional texture, can be imagined as an array of 2D textures, but with support for interpolating between the texture slices. Used primarily when working with the low-level rendering API for special purposes.</li>
<li><a class="el" href="group___utility-_core.html#gga65468556d79304b3a4bfc464cc12e549ad01ad7e972fbf7cfa7f638bab7098953">TextureType::TEX_TYPE_CUBE_MAP</a> - A cubemap texture that consists out of six 2D textures, each representing one face of the cube. Used primarily when working with the low-level rendering API for special purposes.</li>
</ul>
<p>You may also set these optional properties:</p><ul>
<li><a class="el" href="structbs_1_1_t_e_x_t_u_r_e___d_e_s_c.html#a95d3cfcd6320eaa3fe50ae7c8870b397">TEXTURE_DESC::numMips</a> - A texture with mip-maps will contain a set of scaled down versions of itself that are used by the GPU for anti-aliasing. Specify zero to use no mip maps. You can use the helper function <a class="el" href="classbs_1_1_pixel_util.html#ad577905703ec3dea168f5198e383e11e">PixelUtil::getMaxMipmaps()</a> to return the maximum possible mip-map count for a specific set of dimensions.</li>
<li><a class="el" href="structbs_1_1_t_e_x_t_u_r_e___d_e_s_c.html#a993222ae2a1333479e7eccd12a1a1aba">TEXTURE_DESC::numArraySlices</a> - Specify number higher than 1 in order to create an array of textures. This is primarily used for low-level rendering purposes. Texture arrays are not supported for 3D textures.</li>
<li><a class="el" href="structbs_1_1_t_e_x_t_u_r_e___d_e_s_c.html#a9ca287041ac89c8c5aa7f361e24fc92c">TEXTURE_DESC::hwGamma</a> - When true, it specifies if the data in the texture is gamma corrected. When performing reads on such texture in a shader the GPU will transform the texture data back to linear space before returning the value. When a texture is used as a render target, the GPU will automatically convert from linear space into gamma space when rendering to the texture. Only relevant for 2D textures.</li>
<li><a class="el" href="structbs_1_1_t_e_x_t_u_r_e___d_e_s_c.html#a1542cc8772b565742445ed6f687327bf">TEXTURE_DESC::numSamples</a> - Specifies the number of samples per pixel. This is used primarily for multi-sample antialiasing. This is only relevant for 2D textures, and only for textures used as render targets. You cannot read or write from/to multi-sample textures manually.</li>
<li><a class="el" href="structbs_1_1_t_e_x_t_u_r_e___d_e_s_c.html#a2758b06a82e6330f5e02941e43f29fce">TEXTURE_DESC::usage</a> - Flags that control how is the texture allowed to be used, represented by the <a class="el" href="group___resources.html#gac78ff90c8cbce819a61e65d1bb3d29f9">TextureUsage</a> enum</li>
</ul>
<p>Supported textures usages are:</p><ul>
<li><a class="el" href="group___resources.html#ggac78ff90c8cbce819a61e65d1bb3d29f9af3fc1ee86a272f134bc7e6563e541a79">TextureUsage::TU_STATIC</a> - Specify for normal textures that are created once (or updated very rarely) and used for normal rendering.</li>
<li><a class="el" href="group___resources.html#ggac78ff90c8cbce819a61e65d1bb3d29f9abc2800d7120ed5a7f470b29584b5efd2">TextureUsage::TU_DYNAMIC</a> - Specify for textures that are updated often (e.g. every frame) and used for normal rendering.</li>
<li><a class="el" href="group___resources.html#ggac78ff90c8cbce819a61e65d1bb3d29f9a1451acea7839c632c5643bfe11fd1fc1">TextureUsage::TU_RENDERTARGET</a> - Specify for textures that will be used as color attachments for a render target.</li>
<li><a class="el" href="group___resources.html#ggac78ff90c8cbce819a61e65d1bb3d29f9ac5e1f1edb56bf664228c50f0cd24b4a1">TextureUsage::TU_DEPTHSTENCIL</a> - Specify for textures that will be used as a depth/stencil attachment for render target. Texture's pixel format must be one of the depth-stencil formats.</li>
<li><a class="el" href="group___resources.html#ggac78ff90c8cbce819a61e65d1bb3d29f9a29b6588e71cae0dea4f826d041dbbdc2">TextureUsage::TU_LOADSTORE</a> - Specify that the texture can be used for random read/write by shaders (e.g. for use in a compute shader).</li>
<li><a class="el" href="group___resources.html#ggac78ff90c8cbce819a61e65d1bb3d29f9abdb40ac697fc3dbe76f91008a6fb631a">TextureUsage::TU_CPUCACHED</a> - Specify that any data written to the texture (from the CPU) will be cached internally, allowing it to be accessed through <b>Texture::readCachedData()</b>. Uses extra memory as data needs to be stored in both normal and GPU memory.</li>
<li><a class="el" href="group___resources.html#ggac78ff90c8cbce819a61e65d1bb3d29f9ab284f7908e911930a8ad1ee61d1f2550">TextureUsage::TU_CPUREADABLE</a> - Specify that the CPU should be allowed to read texture data that was written by the GPU (e.g. resulting from rendering or a compute shader writes).</li>
</ul>
<p>Most of these options are only useful when using the low-level rendering API and your own shaders, in which case you might require advanced texture types and options. In majority of cases however you will be using 2D textures with mip-maps, potentially with gamma-corrected data, used for normal rendering (e.g. assigning them to materials).</p>
<div class="fragment"><div class="line"><span class="comment">// Creates a 2D texture, 128x128 with an 8-bit RGBA format</span></div><div class="line">TEXTURE_DESC desc;</div><div class="line">desc.type = <a class="code" href="group___utility-_core.html#gga65468556d79304b3a4bfc464cc12e549af7fefc7c59368fca229966f3b463309b">TEX_TYPE_2D</a>;</div><div class="line">desc.width = 128;</div><div class="line">desc.heigth = 128;</div><div class="line">desc.format = PF_R8G8B8A8;</div><div class="line"></div><div class="line">HTexture texture = Texture::create(desc);</div></div><!-- fragment --><blockquote class="doxtable">
<p>Low level rendering API is explained as a part of the developer manuals. </p>
</blockquote>
<h1><a class="anchor" id="advancedTextures_b"></a>
Writing data</h1>
<p>Once a texture has been created you might want to write some data to it. This is accomplished by calling <a class="el" href="classbs_1_1_texture.html#acb1a9f05d575fa1c50e5e2efb3cb4d92">Texture::writeData()</a>. The method accepts a <a class="el" href="classbs_1_1_pixel_data.html">PixelData</a> object, as well as a mip-map level and a face to write to.</p>
<p><b>PixelData</b> object is just a container for all the pixels of a single mip-level &amp; face of a texture. It is created by calling <a class="el" href="classbs_1_1_pixel_data.html#ac262463d28fad17e0d6fd5b7374844d9">PixelData::create()</a> and providing dimensions as well as the pixel format.</p>
<div class="fragment"><div class="line"><span class="comment">// Create pixel data for a 128x128 texture with an 8-bit RGBA format</span></div><div class="line">SPtr&lt;PixelData&gt; pixelData = PixelData::create(128, 128, 1, PF_R8G8B8A8);</div></div><!-- fragment --><p>Once created you can set the color of each pixel by calling <a class="el" href="classbs_1_1_pixel_data.html#a67a7e5d9db2b879d0f1649063c2b1e80">PixelData::setColorAt()</a>, or set all colors at once by calling <a class="el" href="classbs_1_1_pixel_data.html#a5441aafdb06754c9f3099478c1e6058b">PixelData::setColors()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Generate some arbitrary colors</span></div><div class="line">Vector&lt;Color&gt; colors;</div><div class="line"><span class="keywordflow">for</span>(UINT32 y = 0; y &lt; 128; y++)</div><div class="line">    <span class="keywordflow">for</span>(UINT32 x = 0; x &lt; 128; x++)</div><div class="line">        colors.push_back(Color(x / 128.0f, y / 128.0f, 0.0f, 1.0f));</div><div class="line"></div><div class="line">pixelData-&gt;setColors(colors);       </div></div><!-- fragment --><p>Finally you can write the data the the texture.</p>
<div class="fragment"><div class="line">texture-&gt;writeData(pixelData);</div></div><!-- fragment --><h2><a class="anchor" id="advancedTextures_b_a"></a>
Writing to sub-resources</h2>
<p>If a texture contains mip levels, or more than one face then we say it has multiple sub-resources. Each such sub-resource must be written to with a separate call to <b>Texture::writeData()</b>.</p>
<p>A texture has multiple mip-levels if its <b>TEXTURE_DESC::numMips</b> property is larger than zero. A texture has multiple faces if its <b>TEXTURE_DESC::numArraySlices</b> property is larger than one, or if texture type is <b>TextureType::TEX_TYPE_CUBE_MAP</b>.</p>
<p>If texture type is <b>TextureType::TEX_TYPE_CUBE_MAP</b> then the texture will have six faces by default. If such texture has multiple array slices the total number of faces is 6 * number of array slices. Each face has its own set of mip-map levels (if mip-maps count is larger than zero).</p>
<p>To write to different sub-resources simply provide the mip-level and face index when calling <b>Texture::writeData()</b>. Note that when setting mip-levels your <b>PixelData</b> object must be of valid size for the mip-level. You can use the helper method <a class="el" href="classbs_1_1_pixel_util.html#a528f22550730b935b7583cb165cd619b">PixelUtil::getSizeForMipLevel()</a> to calculate dimensions of a specific mip level.</p>
<div class="fragment"><div class="line"><span class="comment">// Creates a 2D texture, 128x128 with an 8-bit RGBA format, with maximum number of mipmaps, and 4 faces</span></div><div class="line">TEXTURE_DESC desc;</div><div class="line">desc.type = <a class="code" href="group___utility-_core.html#gga65468556d79304b3a4bfc464cc12e549af7fefc7c59368fca229966f3b463309b">TEX_TYPE_2D</a>;</div><div class="line">desc.width = 128;</div><div class="line">desc.heigth = 128;</div><div class="line">desc.numMips = PixelUtil::getMaxMipmaps(128, 128, 1, PF_R8G8B8A8);</div><div class="line">desc.format = PF_R8G8B8A8;</div><div class="line">desc.numArraySlices = 4;</div><div class="line"></div><div class="line">HTexture texture = Texture::create(desc);</div><div class="line"></div><div class="line"><span class="comment">// For each face, and for each mip-level, write some data</span></div><div class="line"><span class="keywordflow">for</span>(UINT32 face = 0; face &lt; 4; face++)</div><div class="line">    <span class="keywordflow">for</span>(UINT32 mip = 0; mip &lt;= desc.numMips; mip++)</div><div class="line">    {</div><div class="line">        UINT32 mipWidth, mipHeight, mipDepth;</div><div class="line">        PixelUtil::getSizeForMipLevel(128, 128, 1, mip, mipWidth, mipHeight, mipDepth);</div><div class="line"></div><div class="line">        SPtr&lt;PixelData&gt; pixelData = PixelData::create(mipWidth, mipHeight, 1, PF_R8G8B8A8);</div><div class="line"></div><div class="line">        Vector&lt;Color&gt; colors;</div><div class="line">        <span class="keywordflow">for</span>(UINT32 y = 0; y &lt; mipHeight; y++)</div><div class="line">            <span class="keywordflow">for</span>(UINT32 x = 0; x &lt; mipWidth; x++)</div><div class="line">                colors.push_back(Color(x * 2.0f, y * 2.0f, 0.0f, 1.0f));</div><div class="line"></div><div class="line">        pixelData-&gt;setColors(colors);</div><div class="line">        texture-&gt;writeData(pixelData, face, mip);</div><div class="line">    }</div></div><!-- fragment --><blockquote class="doxtable">
<p>Note when writing we access a total of <em>desc.numMips + 1</em> mip-levels. This is because the 0th mip level is the main texture. </p>
</blockquote>
<p>As a shortcut, you can retrieve texture properties by calling <b>Texture::getProperties()</b> and then call the <a class="el" href="classbs_1_1_texture_properties.html#ad8fb43fa12016c68c5efe228e5071101">TextureProperties::allocBuffer()</a> to automatically create a <b>PixelData</b> object of a valid size and format, depending on provided face and mip level.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; texProps = texture-&gt;getProperties();</div><div class="line"></div><div class="line"><span class="comment">// Get buffer with enough space and valid format for 0th face and 2nd mip-level</span></div><div class="line">SPtr&lt;PixelData&gt; pixelData = texProps.allocBuffer(0, 2);</div><div class="line"><span class="comment">// ... populate the buffer and write</span></div></div><!-- fragment --><h2><a class="anchor" id="advancedTextures_b_b"></a>
Discard on write</h2>
<p>When you are sure you will overwrite all the contents of a texture, make sure to set the last parameter of <b>Texture::writeData()</b> to true. This ensures the system can more optimally execute the transfer, without requiring the GPU to finish its current action (which can be considerably slow if it is currently using that particular texture).</p>
<h2><a class="anchor" id="advancedTextures_b_c"></a>
Generating mip-maps</h2>
<p>Mip-maps are generally created automatically from a source texture, rather than by manually setting their pixels. Therefore bs::f provides <a class="el" href="classbs_1_1_pixel_util.html#a6a2f9cf48ad3b9ab048239b91533cccd">PixelUtil::genMipmaps()</a> method that accepts a <b>PixelData</b> object containing pixels to generate mip levels from. A maximum number of mip-maps levels is then generated and output. You can optionally customize mip-map generation by providing a <a class="el" href="structbs_1_1_mip_map_gen_options.html">MipMapGenOptions</a> object.</p>
<div class="fragment"><div class="line">SPtr&lt;PixelData&gt; pixelData = <span class="stringliteral">&quot;...&quot;</span>;</div><div class="line">Vector&lt;SPtr&lt;PixelData&gt;&gt; mipMapPixelData = PixelUtil::genMipmaps(*pixelData, MipMapGenOptions());</div><div class="line"></div><div class="line"><span class="comment">// Write mipmap data to texture...</span></div></div><!-- fragment --><h2><a class="anchor" id="advancedTextures_b_d"></a>
Writing compressed data</h2>
<p>If a <b>PixelFormat</b> chosen for your texture uses one of the compressed pixel formats, you will need to compress the data before writing it to the texture. For this purpose you can use the <a class="el" href="classbs_1_1_pixel_util.html#ad7acb017fba22a8a683bbfdc4c972e2d">PixelUtil::compress()</a> method. The method accepts a source <b>PixelData</b> and a destination <b>PixelData</b>, as well as a <a class="el" href="structbs_1_1_compression_options.html">CompressionOptions</a> object that contains the pixel format to compress to, among other options.</p>
<div class="fragment"><div class="line">SPtr&lt;PixelData&gt; srcPixelData = PixelData::create(128, 128, 1, PF_R8G8B8A8);</div><div class="line"><span class="comment">// ... fill up srcPixelData with some colors</span></div><div class="line"></div><div class="line"><span class="comment">// Container for resulting data</span></div><div class="line">SPtr&lt;PixelData&gt; dstPixelData = PixelData::create(128, 128, 1, <a class="code" href="group___resources.html#gga60883d4958a60b91661e97027a85072aa4a3a979f754adb660137732aca91ace2">PF_BC3</a>);</div><div class="line"></div><div class="line"><span class="comment">// Compress into BC3 format</span></div><div class="line">CompressionOptions options;</div><div class="line">options.format = <a class="code" href="group___resources.html#gga60883d4958a60b91661e97027a85072aa4a3a979f754adb660137732aca91ace2">PF_BC3</a>;</div><div class="line">PixelUtil::compress(srcPixelData, dstPixelData, options);</div><div class="line"></div><div class="line"><span class="comment">// Write data to texture...</span></div></div><!-- fragment --><h2><a class="anchor" id="advancedTextures_b_e"></a>
Creating textures with data</h2>
<p>If you're creating a texture you wish to immediately populate with data, you can use the overload for <a class="el" href="classbs_1_1_texture.html#aa00a49bb4ab7665036c60bfef2e4f8da">Texture::create()</a> that accepts a <b>PixelData</b> object directly, allowing you to skip the call to <b>Texture::writeData()</b>.</p>
<div class="fragment"><div class="line">SPtr&lt;PixelData&gt; pixelData = PixelData::create(128, 128, 1, PF_R8G8B8A8);</div><div class="line"><span class="comment">// ... fill up pixelData with some colors</span></div><div class="line"></div><div class="line">HTexture texture = Texture::create(pixelData);</div></div><!-- fragment --><h1><a class="anchor" id="advancedTextures_c"></a>
Reading texture data</h1>
<p>Reading data from a texture is done similarly to writing, using <b>PixelData</b> object as well. There are two ways to read texture data:</p><ul>
<li>Reading cached CPU data</li>
<li>Reading GPU data</li>
</ul>
<h2><a class="anchor" id="advancedTextures_c_a"></a>
Reading cached CPU data</h2>
<p>Reading cached CPU data allows you to read-back any data you have written to the texture by calling <b>Texture::writeData()</b>. It is particularily useful when importing textures from external files and wish to access their pixels. Note that texture must be created with the <b>TextureUsage::TU_CPUCACHED</b> usage flag in order for CPU cached data to be available. When importing textures this flag will automatically be set if the relevant property is enabled in <b>TextureImportOptions</b>.</p>
<p>Cached CPU data can be read by calling <a class="el" href="classbs_1_1_texture.html#ac630312b45d7b431b721d0d5a1c168df">Texture::readCachedData()</a>. It accepts a <b>PixelData</b> parameter to which to output the pixel colors, as well as indices to the face &amp; mip-level to read.</p>
<div class="fragment"><div class="line">SPtr&lt;PixelData&gt; pixelData = texProps.allocBuffer(0, 0);</div><div class="line">texture-&gt;readCachedData(*pixelData);</div></div><!-- fragment --><p>After reading the data you can access it through <a class="el" href="classbs_1_1_pixel_data.html#aec3c5281563c73d6f98a9ad347d0a575">PixelData::getColorAt()</a> or <a class="el" href="classbs_1_1_pixel_data.html#ae90c7b18f7318bb3bccd04809eebf2db">PixelData::getColors()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Read pixel at 50x50</span></div><div class="line">Color color = pixelData-&gt;getColorAt(50, 50);</div></div><!-- fragment --><p>Note that cached data reads will not contain any data written by the GPU (e.g. in case the texture is used as a render target or written to by GPU in some other way).</p>
<h2><a class="anchor" id="advancedTextures_c_b"></a>
Reading GPU data</h2>
<p>In case cached CPU reads are not enough, you can perform GPU reads, which always read the most recent data which includes both the data written by the CPU and the GPU. Unlike CPU caching this also does not require additional memory to be used to store texture data. Note that texture must be created with the <b>TextureUsage::TU_CPUREADABLE</b> usage flag in order for such reads to be available.</p>
<p>To perform GPU reads call <a class="el" href="classbs_1_1_texture.html#a1e751556fba9ba1c70e4e432925c1db0">Texture::readData()</a> which has the same interface as <b>Texture::readCachedData()</b>.</p>
<div class="fragment"><div class="line">SPtr&lt;PixelData&gt; pixelData = texProps.allocBuffer(0, 0);</div><div class="line">texture-&gt;readData(*pixelData);</div></div><!-- fragment --><p>Note that performing GPU reads will almost certainly cause a GPU pipeline stall, requiring all GPU operations to finish before the read completes. Such stalls can severely impact performance and should generally be avoided.</p>
<p>Also note that this operation is asynchronous. This means the function will return immediately, but the actual contents of the provided <b>PixelData</b> object will not be populated until the async operation finishes. Read the <a class="el" href="async_method.html">mini-manual</a> for async operations for more information.</p>
<h1><a class="anchor" id="advancedTextures_d"></a>
Other</h1>
<p>Take a look at <a class="el" href="classbs_1_1_pixel_util.html">PixelUtil</a> class for a variety of helper methods for manipulating pixel data and colors. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
