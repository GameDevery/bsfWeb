<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - Math</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='https://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Math </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#mathUtilities_a">Vectors</a><ul><li class="level2"><a href="#mathUtilities_a_a">Integer vectors</a></li>
</ul>
</li>
<li class="level1"><a href="#mathUtilities_b">Angles</a></li>
<li class="level1"><a href="#mathUtilities_c">Quaternions</a><ul><li class="level2"><a href="#mathUtilities_c_a">Other useful methods</a></li>
</ul>
</li>
<li class="level1"><a href="#mathUtilities_d">Matrices</a><ul><li class="level2"><a href="#mathUtilities_d_a">Matrix3</a></li>
<li class="level2"><a href="#mathUtilities_d_b">Matrix4</a></li>
</ul>
</li>
<li class="level1"><a href="#mathUtilities_e">Rays</a></li>
<li class="level1"><a href="#mathUtilities_f">Rectangles</a></li>
<li class="level1"><a href="#mathUtilities_g">Shapes</a></li>
</ul>
</div>
<div class="textblock"><p>General purpose math functionality in bs::f is provided through the <a class="el" href="classbs_1_1_math.html">Math</a> class. It provides a variety of familiar methods, such as <a class="el" href="classbs_1_1_math.html#adee275282c15de025c35f30a0eae9815">Math::floor()</a>, <a class="el" href="classbs_1_1_math.html#a41a91a05fd044784e1ebe2b801990192">Math::clamp()</a>, <a class="el" href="classbs_1_1_math.html#a75c077c2c51ef98480a07cb7a98e8062">Math::cos()</a> and many others. Check the API reference for a full list.</p>
<p>All other math functionality is provided through specific types, as listed below.</p>
<h1><a class="anchor" id="mathUtilities_a"></a>
Vectors</h1>
<p>Vectors are represented by <a class="el" href="classbs_1_1_vector2.html">Vector2</a>, <a class="el" href="classbs_1_1_vector3.html">Vector3</a> and <a class="el" href="classbs_1_1_vector4.html">Vector4</a> classes. All classes come with a full range of operators so manipulating vectors is easy.</p>
<div class="fragment"><div class="line">Vector3 a(0.0f, 10.0f, 20.0f);</div><div class="line">Vector3 b(-1.0f, -2.0f, -3.0f);</div><div class="line"></div><div class="line">Vector3 c = a + b;</div><div class="line">Vector3 d = b - a;</div><div class="line">Vector3 scaled = a * 3.0f;</div></div><!-- fragment --><p>They also come with a variety of helpful methods, and some of the more useful ones are:</p><ul>
<li><a class="el" href="classbs_1_1_vector3.html#a710d9df2dedef127ea6e8ef063e20e50">Vector3::dot()</a> - Dot product</li>
<li><a class="el" href="classbs_1_1_vector3.html#a8813ab75bb5c3b19490f6ca7aea922be">Vector3::cross()</a> - Cross product</li>
<li><a class="el" href="classbs_1_1_vector3.html#ab5068053e7758f065a8725c40ab39194">Vector3::normalize()</a> - Normalizes the vector</li>
<li><a class="el" href="classbs_1_1_vector3.html#a75cc30ec124919b956140f357e4da8f9">Vector3::length()</a> - Returns the length of the vector</li>
<li><a class="el" href="classbs_1_1_vector3.html#a7916ddb3e74bb3b07cea0e9662232e0b">Vector3::distance()</a> - Returns the distance between two vectors</li>
</ul>
<p>And many more as listed on their API reference pages.</p>
<div class="fragment"><div class="line">Vector3 cross = a.cross(b);</div><div class="line"><span class="keywordtype">float</span> dotProduct = a.dot(b);</div><div class="line"><span class="keywordtype">float</span> length = a.length();</div></div><!-- fragment --><h2><a class="anchor" id="mathUtilities_a_a"></a>
Integer vectors</h2>
<p>Integer 2D vector type is also provided as <a class="el" href="structbs_1_1_vector2_i.html">Vector2I</a>. It also supports a full range of operators and comes with a few helper methods. Higher level integer vector types can also be created in the form of <a class="el" href="structbs_1_1_vector3_i.html">Vector3I</a> and <a class="el" href="structbs_1_1_vector4_i.html">Vector4I</a>.</p>
<div class="fragment"><div class="line">Vector2I intVec(0, 10);</div></div><!-- fragment --><h1><a class="anchor" id="mathUtilities_b"></a>
Angles</h1>
<p>Angles are represented using either <a class="el" href="classbs_1_1_degree.html">Degree</a> or <a class="el" href="classbs_1_1_radian.html">Radian</a> classes. They accept a raw floating point value, which they expect to be in degrees or radians, respectively. Once created the system automatically converts between the two.</p>
<div class="fragment"><div class="line">Degree myAngle(90.0f);</div><div class="line">Radian myAngle2 = myAngle;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> printAngle(Degree angle)</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> angleValue = angle.valueDegrees();</div><div class="line">    <a class="code" href="group___debug.html#ga3d2df36e0b331304f012c778c43d86a9">gDebug</a>().<a class="code" href="classbs_1_1_debug.html#acb8d76b720a9ce83aff8bcef5340151b">logDebug</a>(<span class="stringliteral">&quot;Angle is &quot;</span> + <a class="code" href="group___string.html#ga852e40fdd80b537b8ccf93e9cefe0e2b">toString</a>(angleValue));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Caller doesn&#39;t need to care if the method accepts radians or degrees</span></div><div class="line">printAngle(myAngle2);</div></div><!-- fragment --><h1><a class="anchor" id="mathUtilities_c"></a>
Quaternions</h1>
<p><a class="el" href="classbs_1_1_quaternion.html">Quaternion</a>s are the primary way of representing rotations in bs::f. They can be created using Euler angles, axis/angle combination, or from a rotation matrix (talked about later).</p>
<div class="fragment"><div class="line"><span class="comment">// Quaternion that rotates 30 degrees around X axis, followed by 50 degrees around Z axis (Euler angle representation)</span></div><div class="line">Quaternion a(Degree(30), 0, Degree(50));</div><div class="line"></div><div class="line"><span class="comment">// Quaternion that rotates 40 degrees around Y axis (axis/angle representation)</span></div><div class="line">Quaternion b(Vector3::UNIT_Y, Degree(40));</div><div class="line"></div><div class="line"><span class="comment">// Quaternion initialized from a rotation matrix</span></div><div class="line">Matrix3 someMatrix = ...;</div><div class="line">Quaternion c(someMatrix);</div></div><!-- fragment --><p>Once created quaternion can be used to apply rotation to a 3D vector by calling <a class="el" href="classbs_1_1_quaternion.html#a9319d28bf88112fa545d6c74c5a31c8e">Quaternion::rotate()</a>.</p>
<div class="fragment"><div class="line">Vector3 myVector(1, 0, 0);</div><div class="line">Vector3 rotatedVector = b.rotate(myVector);</div></div><!-- fragment --><p>Rotations can be combined by multiplying the quaternions.</p>
<div class="fragment"><div class="line"><span class="comment">// Quaternion that applies rotation b, followed by rotation a</span></div><div class="line">Quaternion combination = a * b;</div></div><!-- fragment --><p>Inverse of a rotation can be obtained by calling <a class="el" href="classbs_1_1_quaternion.html#a567f751ab549bce51e4546ffbb88d068">Quaternion::inverse()</a>. </p><div class="fragment"><div class="line"><span class="comment">// Quaternion that rotates 40 degrees around Y axis</span></div><div class="line">Quaternion quat(Degree(40), Vector3::UNIT_Y);</div><div class="line"></div><div class="line"><span class="comment">// Quaternion that rotates 40 degrees around Y axis, in opposite direction</span></div><div class="line">Quaternion invQuat = quat.inverse();</div></div><!-- fragment --><p>Quaternions only make sense for rotations if they are normalized. If you're doing many operations with them, due to precision issues they might become un-normalized. In such cases you can call <a class="el" href="classbs_1_1_quaternion.html#ab5068053e7758f065a8725c40ab39194">Quaternion::normalize()</a> to re-normalize them.</p>
<div class="fragment"><div class="line">quat.normalize();</div></div><!-- fragment --><p>You can transform a quaternion back to a more familiar form using one of these methods:</p><ul>
<li><a class="el" href="classbs_1_1_quaternion.html#a5b2382e18125789ca7e196cca78689e5">Quaternion::toEulerAngles()</a></li>
<li><a class="el" href="classbs_1_1_quaternion.html#a7562fb351eaa5d45c6da0bee155f8dd5">Quaternion::toAxisAngle()</a></li>
<li><a class="el" href="classbs_1_1_quaternion.html#ac9c5aff6ed0f494ca3b54c884fd18902">Quaternion::toRotationMatrix()</a></li>
</ul>
<div class="fragment"><div class="line">Radian xAngle, yAngle, zAngle;</div><div class="line">quat.toEulerAngles(xAngle, yAngle, zAngle);</div><div class="line"></div><div class="line">Radian angle;</div><div class="line">Vector3 axis;</div><div class="line">quat.toAxisAngle(axis, angle);</div><div class="line"></div><div class="line">Matrix3 rotationMat;</div><div class="line">quat.toRotationMatrix(rotationMat);</div></div><!-- fragment --><h2><a class="anchor" id="mathUtilities_c_a"></a>
Other useful methods</h2>
<p>Often you want to rotate towards a certain direction, for example making a camera look towards something. You can create such rotation by calling <a class="el" href="classbs_1_1_quaternion.html#ab7d9eb1914efb527b9dfc066ee4ac387">Quaternion::lookRotation()</a>.</p>
<div class="fragment"><div class="line">Quaternion q;</div><div class="line"></div><div class="line"><span class="comment">// Look towards negative z axis</span></div><div class="line">q.lookRotation(-Vector3::UNIT_Z);</div></div><!-- fragment --><p>You can interpolate between using two quaternions using <a class="el" href="classbs_1_1_quaternion.html#a826d824993263d7c79aa5ed580fa5d69">Quaternion::lerp()</a> and <a class="el" href="classbs_1_1_quaternion.html#ab2a82fac0e0306155fd4d68be5986430">Quaternion::slerp()</a>. The first method offers normal linear interpolation, and the second method offers a specialized form of interpolation possible only with quaternions, called spherical interpolation. Spherical interpolation is special because it doesn't change the magnitude of the quaternion (i.e. the interpolation happens on a surface of a sphere), while linear interpolation might require a quaternion to be re-normalized after interpolating. On the other hand linear interpolation requires less CPU cycles to execute.</p>
<div class="fragment"><div class="line">Quaternion interpVal0 = Quaternion::lerp(0.5f, a, b);</div><div class="line">interpVal0.normalize();</div><div class="line"></div><div class="line">Quaternion interpVal1 = Quaternion::slerp(0.5f, a, b);</div></div><!-- fragment --><p>Sometimes you have two vectors and want to find a rotation that rotates the first vector into the position of the second. You can do that by using <a class="el" href="classbs_1_1_quaternion.html#a5b5d6bf3baf8d547895a8ee3673c28d4">Quaternion::getRotationFromTo()</a>.</p>
<div class="fragment"><div class="line">Vector3 from(0.0f, 1.0f, 0.0f);</div><div class="line">Vector3 to(1.0f, 0.0f, 0.0f);</div><div class="line"></div><div class="line"><span class="comment">// Generates a rotation that rotates from a vector pointing towards positive Y axis, to a vector pointing towards positive X axis. Essentially creates a 90 degree rotation around the Z axis.</span></div><div class="line">Quaternion quat = Quaternion::getRotationFromTo(from, to);</div></div><!-- fragment --><p>You can find out the rotation axes of a quaternion by calling <a class="el" href="classbs_1_1_quaternion.html#add533b4d910ed4cf82e33a8c1302c308">Quaternion::xAxis()</a>, <a class="el" href="classbs_1_1_quaternion.html#a208df0ad0674b3979b7c427a5f797e7a">Quaternion::yAxis()</a> or <a class="el" href="classbs_1_1_quaternion.html#a8d289ac8eea2a02a6beec0b007c0389a">Quaternion::zAxis()</a>. For example you can use this to find the direction in which a quaternion is facing.</p>
<div class="fragment"><div class="line"><span class="comment">// Assuming we consider the Z axis the facing direction</span></div><div class="line">Vector3 dir = quat.zAxis();</div></div><!-- fragment --><h1><a class="anchor" id="mathUtilities_d"></a>
Matrices</h1>
<p>Matrices can be split into two major types: <a class="el" href="classbs_1_1_matrix3.html">Matrix3</a> representing a 3x3 matrix and <a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> representing a 4x4 matrix. 3x3 matrices are used primarily for representing rotations, and are used similarly to quaternions. 4x4 matrices are used to represent a complete set of transformations like scale, translation and rotation, and are the most commonly used matrix type. We also provide a generic <a class="el" href="classbs_1_1_matrix_nx_m.html">MatrixNxM&lt;N, M&gt;</a> template for other matrix sizes, but they come with much simpler functionality.</p>
<h2><a class="anchor" id="mathUtilities_d_a"></a>
Matrix3</h2>
<p><b>Matrix3</b> can be initialized using Euler angles, axis/angle combination, or from a quaternion. It can also accept a scale factor as well as rotation.</p>
<div class="fragment"><div class="line"><span class="comment">// Matrix that rotates 30 degrees around X axis, followed by 50 degrees around Z axis (Euler angle representation)</span></div><div class="line">Matrix3 a(Degree(30), 0, Degree(50));</div><div class="line"></div><div class="line"><span class="comment">// Matrix that rotates 40 degrees around Y axis (axis/angle representation)</span></div><div class="line">Matrix3 b(Vector3::UNIT_Y, Degree(40));</div><div class="line"></div><div class="line"><span class="comment">// Matrix initialized from a quaternion</span></div><div class="line">Quaternion someQuat = ...;</div><div class="line">Matrix3 c(someQuat);</div><div class="line"></div><div class="line"><span class="comment">// Matrix initialized from a quaternion, but also does scaling along with rotation</span></div><div class="line">Vector3 scale(1.0f, 0.5f, 2.0f);</div><div class="line">Matrix3 d(someQuat, scale);</div></div><!-- fragment --><p>To apply a matrix transformation to a 3D vector call <a class="el" href="classbs_1_1_matrix3.html#a3d8fd948759519c6a6f70b5eb27fb025">Matrix3::multiply()</a>.</p>
<div class="fragment"><div class="line">Vector3 myVector(1, 0, 0);</div><div class="line">Vector3 transformedVector = b.multiply(myVector);</div></div><!-- fragment --><p>Matrices can be multiplied to combine their transformations.</p>
<div class="fragment"><div class="line"><span class="comment">// Creates a matrix that first applies transformation of matrix &quot;a&quot;, followed by transformation of matrix &quot;b&quot;</span></div><div class="line">Matrix3 combination = b * a;</div></div><!-- fragment --><p>Matrices can be transposed (switching rows/columns) by calling <a class="el" href="classbs_1_1_matrix3.html#af236b0f7862e9869d45e41bbf93ea6f5">Matrix3::transpose()</a>.</p>
<div class="fragment"><div class="line">Matrix3 mat(Vector3::UNIT_Y, Degree(40));</div><div class="line">Matrix3 transpose = mat.transpose();</div></div><!-- fragment --><p>Matrices can be inverted by calling <a class="el" href="classbs_1_1_matrix3.html#ae08e2808726cac49db13791d510f9df3">Matrix3::inverse()</a>. Not all matrices have an inverse therefore this method returns a boolean which returns true if an inverse was found.</p>
<div class="fragment"><div class="line">Matrix3 inverseMat;</div><div class="line"><span class="keywordflow">if</span>(mat.inverse(inverseMat))</div><div class="line">    <a class="code" href="group___debug.html#ga3d2df36e0b331304f012c778c43d86a9">gDebug</a>().<a class="code" href="classbs_1_1_debug.html#acb8d76b720a9ce83aff8bcef5340151b">logDebug</a>(<span class="stringliteral">&quot;Inverse found!&quot;</span>);</div></div><!-- fragment --><p>You can decompose a matrix back into rotation &amp; scale components by calling <a class="el" href="classbs_1_1_matrix3.html#ab9c380821a813e5e23123440cb77a6dd">Matrix3::decomposition()</a>. Note that this is only able to work if the matrix contains rotation and/or uniform scale, without any other transformations. Otherwise returned values will likely not be accurate.</p>
<div class="fragment"><div class="line">Quaternion rotation;</div><div class="line">Vector3 scale;</div><div class="line">mat.decomposition(rotation, scale);</div></div><!-- fragment --><p>If the matrix contains only rotation you can also use any of the following methods to extract it:</p><ul>
<li><a class="el" href="classbs_1_1_matrix3.html#a5b2382e18125789ca7e196cca78689e5">Matrix3::toEulerAngles()</a></li>
<li><a class="el" href="classbs_1_1_matrix3.html#a7562fb351eaa5d45c6da0bee155f8dd5">Matrix3::toAxisAngle()</a></li>
<li><a class="el" href="classbs_1_1_matrix3.html#a26236c614bfb134a00f90b6e39ce6925">Matrix3::toQuaternion()</a></li>
</ul>
<div class="fragment"><div class="line">Radian xAngle, yAngle, zAngle;</div><div class="line">mat.toEulerAngles(xAngle, yAngle, zAngle);</div><div class="line"></div><div class="line">Radian angle;</div><div class="line">Vector3 axis;</div><div class="line">mat.toAxisAngle(axis, angle);</div><div class="line"></div><div class="line">Quaternion quat;</div><div class="line">mat.toQuaternion(quat);</div></div><!-- fragment --><h2><a class="anchor" id="mathUtilities_d_b"></a>
Matrix4</h2>
<p><b>Matrix4</b> can be initialized using any of the following static methods:</p><ul>
<li><a class="el" href="classbs_1_1_matrix4.html#a6b8ac6ceca8bf96ac884cf62b9e68867">Matrix4::rotation()</a> - Creates a matrix containing only rotation, from a quaternion.</li>
<li><a class="el" href="classbs_1_1_matrix4.html#a503d61eb77a88bc27c70e7c3fa7253c6">Matrix4::translation()</a> - Creates a matrix containing only translation.</li>
<li><a class="el" href="classbs_1_1_matrix4.html#aac3e079a01a1371f2bafebf16de82414">Matrix4::scaling()</a> - Creates a matrix containing only scale.</li>
<li><a class="el" href="classbs_1_1_matrix4.html#afd1f11bcf844ef3eed59951740d7010f">Matrix4::TRS()</a> - Creates a matrix containing translation, rotation and scale. Scale is applied first, followed by rotation and finally translation.</li>
</ul>
<div class="fragment"><div class="line">Quaternion rotation(Degree(90), Degree(0), Degree(0));</div><div class="line">Matrix4 rotMat = Matrix4::rotation(rotation);</div><div class="line"></div><div class="line">Vector3 translation(0.0f, 50.0f, 0.0f);</div><div class="line">Matrix4 transMat = Matrix4::translation(translation);</div><div class="line"></div><div class="line">Vector3 scale(1.0f, 1.0f, 2.0f);</div><div class="line">Matrix4 scaleMat = Matrix4::scaling(scale);</div><div class="line"></div><div class="line">Matrix4 combinedMat = Matrix4::TRS(translation, rotation, scale);</div></div><!-- fragment --><p>To apply a matrix transformation to a 4D vector you can call <a class="el" href="classbs_1_1_matrix4.html#a0cbfa719fc9dd23f5bcbe034cae7054b">Matrix4::multiply()</a>.</p>
<div class="fragment"><div class="line">Vector4 myVector(1, 0, 0, 1);</div><div class="line">Vector4 transformedVector = combinedMat.multiply(myVector);</div></div><!-- fragment --><p>Not that a vector has its 4th component set to 1. This means the vector is treated as a point, and will be translated by the matrix. If the 4th component was 0, the vector would be treated as a direction instead, and translation would not be applied.</p>
<p>You can also use overriden <a class="el" href="classbs_1_1_matrix4.html#ae5b80d6f256a424670ba627ddfda2c65">Matrix4::multiply()</a> to multiply a <b>Vector3</b>, in which case it is assumed to be a point (4th component is equal to 1). If you instead wish to assume a <b>Vector3</b> is a direction, use <a class="el" href="classbs_1_1_matrix4.html#a2383b6395833229492f1684f1619e688">Matrix4::multiplyDirection()</a> instead.</p>
<div class="fragment"><div class="line">Vector3 myVector(1, 0, 0);</div><div class="line">Vector3 transformedPoint = combinedMat.multiply(myVector);</div><div class="line"></div><div class="line"><span class="comment">// No translation applied (if matrix had any)</span></div><div class="line">Vector3 transformedDirection = combinedMat.multiplyDirection(myVector);</div></div><!-- fragment --><p>Matrices can be multiplied to combine their transformations.</p>
<div class="fragment"><div class="line"><span class="comment">// Creates a matrix that first applies transformation of matrix &quot;a&quot;, followed by transformation of matrix &quot;b&quot;</span></div><div class="line">Matrix4 combination = b * a;</div></div><!-- fragment --><p>Matrices can be transposed (switching rows/columns) by calling <a class="el" href="classbs_1_1_matrix4.html#ae3656c6dfbdd8fc1ec98a468c7b612ba">Matrix4::transpose()</a>.</p>
<div class="fragment"><div class="line">Matrix4 mat(Vector3::UNIT_Y, Degree(40));</div><div class="line">Matrix4 transpose = mat.transpose();</div></div><!-- fragment --><p>Matrices can be inverted by calling <a class="el" href="classbs_1_1_matrix4.html#a70ca51f3efc765252f0b4a45cfac74a0">Matrix4::inverse()</a>. Not all matrices have an inverse therefore this method returns a boolean which returns true if an inverse was found.</p>
<div class="fragment"><div class="line">Matrix4 inverseMat;</div><div class="line"><span class="keywordflow">if</span>(mat.inverse(inverseMat))</div><div class="line">    <a class="code" href="group___debug.html#ga3d2df36e0b331304f012c778c43d86a9">gDebug</a>().<a class="code" href="classbs_1_1_debug.html#acb8d76b720a9ce83aff8bcef5340151b">logDebug</a>(<span class="stringliteral">&quot;Inverse found!&quot;</span>);</div></div><!-- fragment --><p>You can decompose a matrix back into rotation, scale and translation components by calling <a class="el" href="classbs_1_1_matrix4.html#a53b019b614de7c5f0735ee826a8ecc1a">Matrix4::decomposition()</a>. Note that this is only able to work if the matrix contains rotation, translation and uniform scale, without any other transformations. Otherwise returned values will likely not be accurate.</p>
<div class="fragment"><div class="line">Vector3 translation;</div><div class="line">Quaternion rotation;</div><div class="line">Vector3 scale;</div><div class="line">mat.decomposition(translation, rotation, scale);</div></div><!-- fragment --><h1><a class="anchor" id="mathUtilities_e"></a>
Rays</h1>
<p><a class="el" href="classbs_1_1_ray.html">Ray</a>s are represented using an origin point, and a direction. They are often used in physics for intersection tests.</p>
<div class="fragment"><div class="line"><span class="comment">// Ray with origin at world origin, looking up</span></div><div class="line">Ray ray(Vector3(0, 0, 0), Vector3(0, 1, 0));</div></div><!-- fragment --><p>You can use <a class="el" href="classbs_1_1_ray.html#a8099b4cf9b7fbd4278c14584633e114c">Ray::getPoint()</a> to get a point some distance from ray origin, along the direction.</p>
<div class="fragment"><div class="line">Vector3 point = ray.getPoint(10.0f);</div></div><!-- fragment --><p>Rays can be transformed by matrices by calling <a class="el" href="classbs_1_1_ray.html#a53654e802a3da0aaf7626485ea1a3b74">Ray::transform()</a>.</p>
<div class="fragment"><div class="line">Matrix4 mat = ...;</div><div class="line">ray.transform(mat);</div></div><!-- fragment --><p>They also provide a series of <em>intersects</em> methods that allow them to test for intersection against axis aligned boxes, spheres, planes and triangles:</p><ul>
<li><a class="el" href="classbs_1_1_ray.html#a8626ae0becda1b17417ed311235d1541">Ray::intersects(const AABox&amp;)</a> - Axis aligned box intersection</li>
<li><a class="el" href="classbs_1_1_ray.html#a72b612152f60b084bfc66e052a0be56d">Ray::intersects(const Sphere&amp;)</a> - Sphere intersection</li>
<li><a class="el" href="classbs_1_1_ray.html#a8ec59fd0e20f570acd21c03e20f11d0f">Ray::intersects(const Plane&amp;)</a> - Plane intersection</li>
<li><a class="el" href="classbs_1_1_ray.html#ae4016825d35de78b9cc764dfe69d92a6">Ray::intersects(const Vector3&amp;, const Vector3&amp;, const Vector3&amp;)</a> - Triangle intersection</li>
</ul>
<h1><a class="anchor" id="mathUtilities_f"></a>
Rectangles</h1>
<p><a class="el" href="classbs_1_1_rect2.html">Rect2</a> and <a class="el" href="classbs_1_1_rect2_i.html">Rect2I</a> structures can be used for storing rectangles using floating point or integer values, respectively. Check their API reference for the methods they support, but in most scenarios you will be using them for storage and method parameters.</p>
<h1><a class="anchor" id="mathUtilities_g"></a>
Shapes</h1>
<p>bs::f supports a variety of other 3D shapes:</p><ul>
<li><a class="el" href="classbs_1_1_a_a_box.html">AABox</a></li>
<li><a class="el" href="classbs_1_1_sphere.html">Sphere</a></li>
<li><a class="el" href="classbs_1_1_plane.html">Plane</a></li>
<li><a class="el" href="classbs_1_1_capsule.html">Capsule</a></li>
</ul>
<p>How they work should be self explanatory from their API reference. All of the shapes provide a way be initialized, to be transformed by a world matrix as well a set of intersection tests against rays and other shapes.</p>
<div class="fragment"><div class="line"><span class="comment">// Axis aligned box created from minimum and maximum corners</span></div><div class="line">Vector3 min(-1.0f, -1.0f, -1.0f);</div><div class="line">Vector3 max(1.0f, 1.0f, 1.0f);</div><div class="line"></div><div class="line">AABox box(min, max);</div><div class="line"></div><div class="line"><span class="comment">// Sphere created from center and radius</span></div><div class="line">Vector3 center(0.0f, 10.0f, 0.0f);</div><div class="line"><span class="keywordtype">float</span> radius = 20.0f;</div><div class="line"></div><div class="line"><a class="code" href="group___renderer-_internal.html#gga8c082c4504173be0d18e62c5f403e4edab7095f057db3fefa7325ad93a04e14fd">Sphere</a> sphere(center, radius);</div><div class="line"></div><div class="line"><span class="comment">// Plane created from normal, and distance from origin along the normal</span></div><div class="line">Vector3 normal(0.0f, 1.0f, 0.0f);</div><div class="line"><span class="keywordtype">float</span> dist = 10.0f;</div><div class="line"></div><div class="line">Plane plane(normal, dist);</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
