<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - GUI elements</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='https://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">GUI elements </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#guiElements_a">Displaying a GUI element</a></li>
<li class="level1"><a href="#guiElements_b">Destroying GUI elements</a></li>
<li class="level1"><a href="#guiElements_c">Customizing GUI elements</a><ul><li class="level2"><a href="#guiElements_c_a">Changing position</a></li>
<li class="level2"><a href="#guiElements_c_b">Changing size</a></li>
<li class="level2"><a href="#guiElements_c_c">Changing color</a></li>
<li class="level2"><a href="#guiElements_c_d">Hiding</a></li>
</ul>
</li>
<li class="level1"><a href="#guiElements_d">GUI element types</a><ul><li class="level2"><a href="#guiElements_d_a">Label</a></li>
<li class="level2"><a href="#guiElements_d_b">Texture</a></li>
<li class="level2"><a href="#guiElements_d_c">Button</a></li>
<li class="level2"><a href="#guiElements_d_d">Toggle</a></li>
<li class="level2"><a href="#guiElements_d_e">Input box</a></li>
<li class="level2"><a href="#guiElements_d_f">List box</a></li>
<li class="level2"><a href="#guiElements_d_g">Slider</a></li>
<li class="level2"><a href="#guiElements_d_h">Scroll area</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>A GUI element is a basic primitive that GUI is constructed out of. They can be text, buttons, input boxes, images, scroll areas and more. We'll explain what the individual GUI element types are later, but initially we'll focus on functionality common to all GUI elements.</p>
<h1><a class="anchor" id="guiElements_a"></a>
Displaying a GUI element</h1>
<p>In order to display a GUI element we must first create it. All GUI elements are created using a static <em>create</em> method.</p>
<div class="fragment"><div class="line"><span class="comment">// GUILabel is a type of GUI element that displays the provided text on screen</span></div><div class="line">GUILabel* label = GUILabel::create(HString(<span class="stringliteral">&quot;Hello!&quot;</span>));</div></div><!-- fragment --><p>But just creating the element is not enough. We must also register it with our <b>GUIWidget</b>. To do that we must first retrieve the primary <a class="el" href="classbs_1_1_g_u_i_panel.html">GUIPanel</a> from the widget. <b>GUIPanel</b> serves as an element container, and by default every widget has one. Use <a class="el" href="classbs_1_1_c_g_u_i_widget.html#ae3cced0093766ce5d4287754d67ef625">CGUIWidget::getPanel()</a> to retrieve the panel.</p>
<div class="fragment"><div class="line">GUIPanel* mainPanel = gui-&gt;getPanel();</div></div><!-- fragment --><p><b>GUIPanel</b> is a special type of a GUI element called a "layout". We'll discuss layouts in more detail in the next chapter, but for now all you need to know is that they are element containers you can add and remove other GUI elements to/from.</p>
<p>To add an element to the panel use <a class="el" href="classbs_1_1_g_u_i_layout.html#a2760d3f90c6a971be3efac63cc17c027">GUIPanel::addElement()</a>.</p>
<div class="fragment"><div class="line">mainPanel-&gt;addElement(label);</div></div><!-- fragment --><p>At this point our GUI element will be displayed.</p>
<div class="image">
<img src="guiBasic.png" alt="guiBasic.png"/>
<div class="caption">
Simple GUI</div></div>
<h1><a class="anchor" id="guiElements_b"></a>
Destroying GUI elements</h1>
<p>You do not need to manually destroy a GUI element that is registered with a layout (e.g. a <b>GUIPanel</b>). Such elements will be destroyed automatically when their parent layout is destroyed. If their parent layout is connected to <b>GUIWidget</b> root panel, then all layouts and elements will be destroyed with the widget.</p>
<p>In case you need to manually destroy a GUI element you can call <a class="el" href="classbs_1_1_g_u_i_element.html#aa28a305f764bf03f882ba9d6b920cbdb">GUIElement::destroy()</a>.</p>
<div class="fragment"><div class="line">GUIElement::destroy(label);</div></div><!-- fragment --><p>Such element will also automatically be removed from the parent layout (if any).</p>
<h1><a class="anchor" id="guiElements_c"></a>
Customizing GUI elements</h1>
<p>All GUI elements share a common set of methods you can use to customize their position, size, color and other properties.</p>
<h2><a class="anchor" id="guiElements_c_a"></a>
Changing position</h2>
<p>You can change the position of a GUI element by calling <a class="el" href="classbs_1_1_g_u_i_element_base.html#a326dc5e877e848a5d3ba192c29be3238">GUIElement::setPosition()</a>. The position is in pixels, relative to the top left corner of the render target.</p>
<div class="fragment"><div class="line"><span class="comment">// Moves the displayed text to coordinates (50, 50)</span></div><div class="line">label-&gt;setPosition(50, 50);</div></div><!-- fragment --><h2><a class="anchor" id="guiElements_c_b"></a>
Changing size</h2>
<p>Element size can be changed by calling <a class="el" href="classbs_1_1_g_u_i_element_base.html#a0f86dad0f3006b909753317a96664d92">GUIElement::setSize()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Make the label 30 pixels high, and 100 pixels wide</span></div><div class="line">label-&gt;setSize(100, 30);</div></div><!-- fragment --><p>You can also set both position and size at the same time by calling <a class="el" href="classbs_1_1_g_u_i_element_base.html#ab816b80259befb761809a958ec77524b">GUIElement::setBounds()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Make the label 30 pixels high, and 100 pixels wide, and position it at (50, 50)</span></div><div class="line">label-&gt;setBounds(Rect2I(50, 50, 100, 30));</div></div><!-- fragment --><h2><a class="anchor" id="guiElements_c_c"></a>
Changing color</h2>
<p>You can change the tint of the GUI element with <a class="el" href="classbs_1_1_g_u_i_element.html#a28d679bbce3fd21883f11295466c0bc0">GUIElement::setTint()</a>. By default an all-white tint is used for all elements.</p>
<div class="fragment"><div class="line"><span class="comment">// Make the label text green</span></div><div class="line">label-&gt;setTint(Color::Green);</div></div><!-- fragment --><h2><a class="anchor" id="guiElements_c_d"></a>
Hiding</h2>
<p>You can temporarily hide an element with <a class="el" href="classbs_1_1_g_u_i_element_base.html#a18e44e30b31525a243960ca3928125aa">GUIElement::setVisible()</a>. As the name implies hidden element will not be displayed, and cannot be interacted with.</p>
<div class="fragment"><div class="line"><span class="comment">// Hide the label</span></div><div class="line">label-&gt;setVisible(<span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="comment">// Show the label</span></div><div class="line">label-&gt;setVisible(<span class="keyword">true</span>);</div></div><!-- fragment --><h1><a class="anchor" id="guiElements_d"></a>
GUI element types</h1>
<p>bs::f provides a large library of existing GUI element types. We'll focus on explaining the most important ones, but you can find an exhaustive list in <a class="el" href="group___g_u_i.html">GUI</a>.</p>
<h2><a class="anchor" id="guiElements_d_a"></a>
Label</h2>
<p>A label is the most basic of GUI elements, that allows no user interaction and just displays a textual string. It is created with <a class="el" href="classbs_1_1_g_u_i_label.html#a2a8e4d335e090cb7c9b61e9ce5218974">GUILabel::create()</a>, which accepts a string as input.</p>
<div class="fragment"><div class="line">GUILabel* label = GUILabel::create(HString(<span class="stringliteral">&quot;Hello!&quot;</span>));</div><div class="line">mainPanel-&gt;addElement(label);</div></div><!-- fragment --><p>Once created you can optionally change the displayed text with <a class="el" href="classbs_1_1_g_u_i_label.html#a4d77220786de0f8120edf78f298f13c9">GUILabel::setContent()</a>.</p>
<div class="fragment"><div class="line">label-&gt;setContent(HString(<span class="stringliteral">&quot;New text!&quot;</span>));</div></div><!-- fragment --><blockquote class="doxtable">
<p>You can use <em>setContent</em> function on most GUI elements, so we won't mention it further for each individual element. </p>
</blockquote>
<div class="image">
<img src="guiLabel.png" alt="guiLabel.png"/>
<div class="caption">
Label</div></div>
<h2><a class="anchor" id="guiElements_d_b"></a>
Texture</h2>
<p>A texture is another basic GUI element that allows no interaction. All it does is display a <b>SpriteTexture</b> on the screen.</p>
<p>To create a GUI texture element, call <a class="el" href="classbs_1_1_g_u_i_texture.html#aa303b21c561f189cd8f5759cabeb6d45">GUITexture::create()</a> which accepts three parameters:</p><ul>
<li><b>SpriteTexture</b> - Determines which texture to draw.</li>
<li><a class="el" href="group___utility-_engine.html#ga423720335845aad11b02e84f3c2d8579">TextureScaleMode</a> - Determines how to scale the texture in the available area.</li>
<li>Transparency flag - Should transparency be enabled, allowing elements behind the texture to render.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Create a sprite texture for use</span></div><div class="line">HTexture tex = <a class="code" href="group___importer.html#gafda9808bfcae11afa60eee731056225e">gImporter</a>().<a class="code" href="classbs_1_1_importer.html#a956425fa45716612e04b109701bdd62f">import</a>&lt;Texture&gt;(<span class="stringliteral">&quot;BansheLogoRoundSmall.png&quot;</span>);</div><div class="line">HSpriteTexture spriteTexture = SpriteTexture::create(tex);</div><div class="line"></div><div class="line"><span class="comment">// Create the texture GUI element with our sprite texture and default scaling/transparency</span></div><div class="line">GUITexture* guiTexture = GUITexture::create(spriteTexture);</div><div class="line"></div><div class="line"><span class="comment">// Position the texture</span></div><div class="line">guiTexture-&gt;setPosition(250, 90);</div><div class="line">guiTexture-&gt;setSize(150, 150);</div><div class="line"></div><div class="line">mainPanel-&gt;addElement(guiTexture);</div></div><!-- fragment --><div class="image">
<img src="guiTexture.png" alt="guiTexture.png"/>
<div class="caption">
Texture</div></div>
<h2><a class="anchor" id="guiElements_d_c"></a>
Button</h2>
<p>A button GUI element displays a textual string or an image and reports events about user interaction with the button.</p>
<p>GUI elements that can have either text or image contents (or both) accept a <a class="el" href="classbs_1_1_g_u_i_content.html">GUIContent</a> structure in their <em>create</em> and <em>setContent</em> functions. It is just a container and constructed simply:</p>
<div class="fragment"><div class="line"><span class="comment">// Contents containing only text</span></div><div class="line">GUIContent textContents(HString(<span class="stringliteral">&quot;Click me!&quot;</span>));</div><div class="line"></div><div class="line"><span class="comment">// Contents containing only an image</span></div><div class="line">HTexture tex = <a class="code" href="group___importer.html#gafda9808bfcae11afa60eee731056225e">gImporter</a>().<a class="code" href="classbs_1_1_importer.html#a956425fa45716612e04b109701bdd62f">import</a>&lt;Texture&gt;(<span class="stringliteral">&quot;BansheLogoRoundSmall.png&quot;</span>);</div><div class="line">HSpriteTexture spriteTexture = SpriteTexture::create(tex);</div><div class="line"></div><div class="line">GUIContent imageContents(spriteTexture);</div></div><!-- fragment --><p>To create a button, call <a class="el" href="classbs_1_1_g_u_i_button.html#a4fc1de9dc478b477a3d901393d8764a5">GUIButton::create()</a>. </p><div class="fragment"><div class="line">GUIButton* textButton = GUIButton::create(textContents);</div><div class="line">GUIButton* imageButton = GUIButton::create(imageContents);</div><div class="line"></div><div class="line">mainPanel-&gt;addElement(textButton);</div><div class="line">mainPanel-&gt;addElement(imageButton);</div></div><!-- fragment --><p>Once created, user can interact with the button by mousing over it or clicking on it. <b>GUIButton</b> provides a set of callbacks that notify the developer when user interacts with the button:</p><ul>
<li><a class="el" href="classbs_1_1_g_u_i_button_base.html#a143ff73d83659980df005128c873dfc8">GUIButton::onClick</a> - Triggers when the user clicks the button.</li>
<li><a class="el" href="classbs_1_1_g_u_i_button_base.html#affdecfbda5297f021a6bbf08684b9874">GUIButton::onHover</a> - Triggers when the mouse cursor hovers over a button.</li>
<li><a class="el" href="classbs_1_1_g_u_i_button_base.html#a0f1b65022b434572788bc725a390dbcf">GUIButton::onOut</a> - Triggers when the mouse cursor leaves the button area.</li>
<li><a class="el" href="classbs_1_1_g_u_i_button_base.html#a71a4e8e32d5735346f060eccb6d25353">GUIButton::onDoubleClick</a> - Triggers when the user clicks the button twice in a quick succession.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> buttonClicked = []()</div><div class="line">{</div><div class="line">    <a class="code" href="group___debug.html#ga3d2df36e0b331304f012c778c43d86a9">gDebug</a>().<a class="code" href="classbs_1_1_debug.html#acb8d76b720a9ce83aff8bcef5340151b">logDebug</a>(<span class="stringliteral">&quot;Button clicked!&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Print a message &quot;Button clicked!&quot; whenever user clicks the button</span></div><div class="line">imageButton-&gt;onClick.connect(buttonClicked);</div></div><!-- fragment --><div class="image">
<img src="guiButton.png" alt="guiButton.png"/>
<div class="caption">
GUI buttons</div></div>
<h2><a class="anchor" id="guiElements_d_d"></a>
Toggle</h2>
<p>Toggle buttons are very similar to normal buttons, with the main difference being that they remain in a toggled state after they have been pressed. Multiple toggle buttons can also be grouped so that only one of them can be toggled at a time. Other than that they share the same interface as <b>GUIButton</b>, so we'll focus only on the additional functionality.</p>
<p>To create an individual toggle button call <a class="el" href="classbs_1_1_g_u_i_toggle.html#a2aa66f4d4e99412d7a627b920e92899f">GUIToggle::create()</a>. </p><div class="fragment"><div class="line">GUIToggle* toggle = GUIButton::create(HString());</div><div class="line"></div><div class="line">mainPanel-&gt;addElement(toggle);</div></div><!-- fragment --><p>To create a set of toggle buttons call <b>GUIToggle::create</b> overload with the <a class="el" href="classbs_1_1_g_u_i_toggle_group.html">GUIToggleGroup</a> parameter. All toggles sharing the same toggle group will allow only one of the buttons to be active at a time. This allows you to create a "pick one out of many" element.</p>
<p>To create a toggle group call <a class="el" href="classbs_1_1_g_u_i_toggle.html#a1c547abdf803ad8101b5b3dac20491d7">GUIToggle::createToggleGroup()</a>. After that just create the toggle elements as normal, and provide the group as a parameter.</p>
<div class="fragment"><div class="line">SPtr&lt;GUIToggleGroup&gt; group = GUIToggle::createToggleGroup();</div><div class="line"></div><div class="line">GUIToggle* radio0 = GUIButton::create(HString(), group);</div><div class="line">GUIToggle* radio1 = GUIButton::create(HString(), group);</div><div class="line">GUIToggle* radio2 = GUIButton::create(HString(), group);</div><div class="line"></div><div class="line">mainPanel-&gt;addElement(radio0);</div><div class="line">mainPanel-&gt;addElement(radio1);</div><div class="line">mainPanel-&gt;addElement(radio2);</div></div><!-- fragment --><blockquote class="doxtable">
<p>Note that we aren't giving any textual labels to the toggle buttons. This is because their default style is a small box, in which we cannot fit any text. If you wish to add labels you need to either use a different style (discussed later), or use a separate <b>GUILabel</b> element next to the <b>GUIToggle</b> element. </p>
</blockquote>
<p>Once created you can subscribe to the <a class="el" href="classbs_1_1_g_u_i_toggle.html#ad2214cc8546da1fd0df2d8863640df9c">GUIToggle::onToggled</a> event, as well as all previously mentioned <b>GUIButton</b> events. <b>GUIToggle::onToggled</b> triggers whenever the toggle state of the element changes.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> elementToggled = [](<span class="keywordtype">bool</span> toggled)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>(toggled)</div><div class="line">        <a class="code" href="group___debug.html#ga3d2df36e0b331304f012c778c43d86a9">gDebug</a>().<a class="code" href="classbs_1_1_debug.html#acb8d76b720a9ce83aff8bcef5340151b">logDebug</a>(<span class="stringliteral">&quot;Toggled!&quot;</span>);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group___debug.html#ga3d2df36e0b331304f012c778c43d86a9">gDebug</a>().<a class="code" href="classbs_1_1_debug.html#acb8d76b720a9ce83aff8bcef5340151b">logDebug</a>(<span class="stringliteral">&quot;Untoggled!&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line">toggle-&gt;onClick.connect(elementToggled);</div></div><!-- fragment --><div class="image">
<img src="guiToggle.png" alt="guiToggle.png"/>
<div class="caption">
GUI toggle</div></div>
<h2><a class="anchor" id="guiElements_d_e"></a>
Input box</h2>
<p>Input boxes allow user to type into them using the keyboard. They can be single-line (default) or multi-line. To create them call <a class="el" href="classbs_1_1_g_u_i_input_box.html#ace457449d535f733824cd5c52c9a2f7e">GUIInputBox::create()</a> where the first parameter specifies whether the input box is single- or multi-line.</p>
<div class="fragment"><div class="line">GUIInputBox* singleLineInput = GUIInputBox::create();</div><div class="line">GUIInputBox* multiLineInput = GUIInputBox::create(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">mainPanel-&gt;addElement(singleLineInput);</div><div class="line">mainPanel-&gt;addElement(multiLineInput);</div></div><!-- fragment --><p>Once created you can retrieve the text currently in the input box by calling <a class="el" href="classbs_1_1_g_u_i_input_box.html#a96b875e8a5a27aa97d49a4173f72dbf1">GUIInputBox::getText()</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> userInput = singleLineInput-&gt;getText();</div></div><!-- fragment --><p>You can also programatically set text in the box with <a class="el" href="classbs_1_1_g_u_i_input_box.html#a90b92b647abb3c9f7cc25f07f5fa0982">GUIInputBox::setText()</a>.</p>
<div class="fragment"><div class="line">multiLineInput-&gt;setText(<span class="stringliteral">&quot;Type in me!&quot;</span>);</div></div><!-- fragment --><p>If you wish to get notified as the user is inputting text you can use the <a class="el" href="classbs_1_1_g_u_i_input_box.html#a4092a2d0aef83045fcfd9e80b33fc446">GUIInputBox::onValueChanged</a> event. It will be called whenever the user types a new character (or deletes an existing one).</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> respondToInput = [](<span class="keyword">const</span> <a class="code" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a>&amp; text)</div><div class="line">{</div><div class="line">    <a class="code" href="group___debug.html#ga3d2df36e0b331304f012c778c43d86a9">gDebug</a>().<a class="code" href="classbs_1_1_debug.html#acb8d76b720a9ce83aff8bcef5340151b">logDebug</a>(<span class="stringliteral">&quot;New input box value: &quot;</span> + text);</div><div class="line">};</div><div class="line"></div><div class="line">multiLineInput-&gt;onValueChanged.connect(respondToInput);</div></div><!-- fragment --><p>Sometimes you might want to limit what is user allowed to input (for example, just numbers). In that case you can use <a class="el" href="classbs_1_1_g_u_i_input_box.html#a03ba90c2fcf5d4951219b116c84d2074">GUIInputBox::setFilter()</a> to set a custom filter callback. The callback accepts a potential input, and returns true if it will be accepted.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> intFilter = [](<span class="keyword">const</span> <a class="code" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a>&amp; str)</div><div class="line">{</div><div class="line">    <span class="comment">// Use regex to match only integers</span></div><div class="line">    <span class="keywordflow">return</span> std::regex_match(str, std::regex(<span class="stringliteral">&quot;-?(\\d+)?&quot;</span>));</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// This input box now accepts only integers</span></div><div class="line">singleLineInput-&gt;setFilter(intFilter);</div></div><!-- fragment --><div class="image">
<img src="guiInputBox.png" alt="guiInputBox.png"/>
<div class="caption">
Input boxes</div></div>
<h2><a class="anchor" id="guiElements_d_f"></a>
List box</h2>
<p>List boxes allow you to provide multiple elements the user can pick between. They can allow selection of just a single element (default), or allow multi-selection. List boxes are created by calling <a class="el" href="classbs_1_1_g_u_i_list_box.html#a96e271db2d5b19779bdd3dfd3ba30eb6">GUIListBox::create()</a> where the first argument represents a list of entries to display on the list, while the second argument specifies whether the list should allow multi-selection or not.</p>
<div class="fragment"><div class="line">Vector&lt;HString&gt; listElements =</div><div class="line">{</div><div class="line">    HString(<span class="stringliteral">&quot;Orange&quot;</span>),</div><div class="line">    HString(<span class="stringliteral">&quot;Apple&quot;</span>),</div><div class="line">    HString(<span class="stringliteral">&quot;Banana&quot;</span>),</div><div class="line">    HString(<span class="stringliteral">&quot;Strawberry&quot;</span>)</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Create a single-select list with four elements</span></div><div class="line">GUIListBox* listBox = GUIListBox::create(listElements);</div><div class="line"></div><div class="line"><span class="comment">// Create a multi-select list with four elements</span></div><div class="line">GUIListBox* multiSelectListBox = GUIListBox::create(listElements, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">mainPanel-&gt;addElement(listBox);</div><div class="line">mainPanel-&gt;addElement(multiSelectListBox);</div></div><!-- fragment --><p>Once created, you can retrieve the current selection by calling <a class="el" href="classbs_1_1_g_u_i_list_box.html#ab81e39bf7833fb0c48f44c8b2dce9bc1">GUIListBox::getElementStates()</a>. This will return a list of booleans that specify if an element at the specified index (corresponding to the initial index of the element when passed to <b>GUIListBox::create()</b>) is selected.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> selection = multiSelectListBox-&gt;getElementStates();</div><div class="line">UINT32 idx = 0;</div><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; isSelected : selection)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (isSelected)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> selectedValue = listElements[idx].getValue();</div><div class="line">        <a class="code" href="group___debug.html#ga3d2df36e0b331304f012c778c43d86a9">gDebug</a>().<a class="code" href="classbs_1_1_debug.html#acb8d76b720a9ce83aff8bcef5340151b">logDebug</a>(<span class="stringliteral">&quot;Element &quot;</span> + selectedValue + <span class="stringliteral">&quot; is selected&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    idx++;</div><div class="line">}</div></div><!-- fragment --><p>You can also get notified immediately as the selection is changing by subscribing to the <a class="el" href="classbs_1_1_g_u_i_list_box.html#ad1b4441c9a2d4405c4d79eb58c1c36cc">GUIListBox::onSelectionToggled</a> event. It will report an index of the element that was interacted with, as well a boolean whether the element was just selected or deselected.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> selectionToggled = [=](UINT32 idx, <span class="keywordtype">bool</span> enabled)</div><div class="line">{</div><div class="line">    <a class="code" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> selectedValue = listElements[idx].getValue();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (enabled)</div><div class="line">        <a class="code" href="group___debug.html#ga3d2df36e0b331304f012c778c43d86a9">gDebug</a>().<a class="code" href="classbs_1_1_debug.html#acb8d76b720a9ce83aff8bcef5340151b">logDebug</a>(<span class="stringliteral">&quot;User selected &quot;</span> + selectedValue);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group___debug.html#ga3d2df36e0b331304f012c778c43d86a9">gDebug</a>().<a class="code" href="classbs_1_1_debug.html#acb8d76b720a9ce83aff8bcef5340151b">logDebug</a>(<span class="stringliteral">&quot;User deselected &quot;</span> + selectedValue);</div><div class="line">};</div><div class="line"></div><div class="line">listBox-&gt;onSelectionToggled.connect(selectionToggled);</div></div><!-- fragment --><div class="image">
<img src="guiListBox.png" alt="guiListBox.png"/>
<div class="caption">
List boxes</div></div>
<h2><a class="anchor" id="guiElements_d_g"></a>
Slider</h2>
<p>Sliders allow the user to select a numeric value by dragging a slider. Sliders can be vertical or horizontal, represented by <a class="el" href="classbs_1_1_g_u_i_slider_vert.html">GUISliderVert</a> and <a class="el" href="classbs_1_1_g_u_i_slider_horz.html">GUISliderHorz</a> classes, respectively. They both share the same interface.</p>
<p>To create a slider call either <a class="el" href="classbs_1_1_g_u_i_slider_vert.html#ab8af253b6e72e95f0a0cbad18b0c44b0">GUISliderVert::create()</a> or <a class="el" href="classbs_1_1_g_u_i_slider_horz.html#ae88d97697d568a19f3ea5fa50fe8d800">GUISliderHorz::create()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Vertical slider</span></div><div class="line">GUISliderVert* sliderVert = GUISliderVert::create();</div><div class="line"></div><div class="line"><span class="comment">// Horizontal slider</span></div><div class="line">GUISliderHorz* sliderHorz = GUISliderHorz::create();</div><div class="line"></div><div class="line">mainPanel-&gt;addElement(sliderVert);</div><div class="line">mainPanel-&gt;addElement(sliderHorz);</div></div><!-- fragment --><p>Once created you can retrieve the current position of the slider by calling <a class="el" href="classbs_1_1_g_u_i_slider.html#a8612fa870c09c26a73ecc25c0dda7c4f">GUISlider::getPercent()</a>. This will always return a value in range [0, 1] where 0 represents top/left, and 1 represent bottom/right positions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> curSliderPosition = sliderHorz-&gt;getPercent();</div></div><!-- fragment --><p>You can also get notified immediately when the slider handle moves by subscribing to the <a class="el" href="classbs_1_1_g_u_i_slider.html#a09973fdf9f7b731101578dc199177356">GUISlider::onChanged</a> event.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sliderPositionChanged = [](<span class="keywordtype">float</span> percent)</div><div class="line">{</div><div class="line">    <a class="code" href="group___debug.html#ga3d2df36e0b331304f012c778c43d86a9">gDebug</a>().<a class="code" href="classbs_1_1_debug.html#acb8d76b720a9ce83aff8bcef5340151b">logDebug</a>(<span class="stringliteral">&quot;Current slider position: &quot;</span> + <a class="code" href="group___string.html#ga852e40fdd80b537b8ccf93e9cefe0e2b">toString</a>(percent));</div><div class="line">};</div><div class="line"></div><div class="line">sliderHorz-&gt;onChanged.connect(sliderPositionChanged);</div></div><!-- fragment --><p>By default the slider maps to the range [0, 1], but you can also specify a custom range by calling <a class="el" href="classbs_1_1_g_u_i_slider.html#a39e513b9a36ebaa12a8d922960bb9aee">GUISlider::setRange()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Set range from 0 to 360 (e.g. degrees)</span></div><div class="line">sliderHorz-&gt;setRange(0.0f, 360.0f);</div></div><!-- fragment --><p>Note that even after setting the range <b>GUISlider::getPercent()</b> will still return the value in range [0, 1]. Use <a class="el" href="classbs_1_1_g_u_i_slider.html#adbf217d742043b65c25b91464bfb7620">GUISlider::getValue()</a> to get the value in the actual range specified.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> curSliderValue = sliderHorz-&gt;getValue();</div></div><!-- fragment --><p>Finally, you can specify a minimum step between two increments of the slider by calling <a class="el" href="classbs_1_1_g_u_i_slider.html#afbc210df8a78226891f61c3aed33fbb6">GUISlider::setStep()</a>. Without a minimum increment the slider can be moved as well as user's input &amp; screen precision allows.</p>
<div class="fragment"><div class="line"><span class="comment">// Allow a maximum of 36 increments (increment by 10 degrees)</span></div><div class="line">sliderHorz-&gt;setStep(10.0f / 360.0f);</div></div><!-- fragment --><p>Note the step is specified in [0, 1] range.</p>
<div class="image">
<img src="guiSlider.png" alt="guiSlider.png"/>
<div class="caption">
Vertical and a horizontal slider</div></div>
 <h2><a class="anchor" id="guiElements_d_h"></a>
Scroll area</h2>
<p>Scroll areas serve as containers for other GUI elements. They can contain more elements that would normally be able to fit in the visible area by providing scrollbars when necessary. Create a scroll area by calling <a class="el" href="classbs_1_1_g_u_i_scroll_area.html#a7ad751808ef815731ba4b60354dd9b18">GUIScrollArea::create()</a>.</p>
<div class="fragment"><div class="line">GUIScrollArea* scrollArea = GUIScrollArea::create();</div><div class="line"></div><div class="line"><span class="comment">// Scroll area&#39;s don&#39;t have default size, we must specify one. This is where the contents will be displayed.</span></div><div class="line">scrollArea-&gt;setSize(100, 150);</div><div class="line"></div><div class="line">mainPanel-&gt;addElement(scrollArea);</div></div><!-- fragment --><p>When creating them you can individually control when should vertical or horizontal scroll-bars show up using the <a class="el" href="group___g_u_i.html#gaf9b14d5d396c8e676beac8be8a4c69ed">ScrollBarType</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Show vertical scrollbar only when contents don&#39;t fit in the scroll-bar area, and never show the horizontal scrollbar</span></div><div class="line">GUIScrollArea* anotherScrollArea = GUIScrollArea::create(ScrollBarType::ShowIfDoesntFit, ScrollBarType::NeverShow);</div></div><!-- fragment --><p>Once scroll area is created it will provide you with a layout, similar to how <b>GUIWidget::getPanel()</b> works. Call <a class="el" href="classbs_1_1_g_u_i_scroll_area.html#a5f816827c4bdc4eb41b3a01a4116bf49">GUIScrollArea::getLayout()</a> to retrieve the layout, and then attach GUI elements to it normally.</p>
<div class="fragment"><div class="line"><span class="comment">// Add a bunch of elements to the scroll area</span></div><div class="line">GUILayout&amp; layout = scrollArea-&gt;getLayout();</div><div class="line"><span class="keywordflow">for</span>(UINT32 i = 0; i &lt; 20; i++)</div><div class="line">{</div><div class="line">    GUIButton* button = GUIButton::create(HString(<span class="stringliteral">&quot;Entry #&quot;</span> + <a class="code" href="group___string.html#ga852e40fdd80b537b8ccf93e9cefe0e2b">toString</a>(i)));</div><div class="line">    layout.addElement(button);</div><div class="line">}</div></div><!-- fragment --><p>We'll go more in depth about layouts in the next chapter.</p>
<div class="image">
<img src="guiScrollArea.png" alt="guiScrollArea.png"/>
<div class="caption">
Scroll area</div></div>
 </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
