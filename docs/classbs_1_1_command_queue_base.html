<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - CommandQueueBase Class Reference</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='http://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="../SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="../SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebs.html">bs</a></li><li class="navelem"><a class="el" href="classbs_1_1_command_queue_base.html">CommandQueueBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Methods</a> &#124;
<a href="#pub-static-methods">Static methods</a> &#124;
<a href="classbs_1_1_command_queue_base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CommandQueueBase Class Reference<div class="ingroups"><a class="el" href="group___internals.html">Internals</a> &raquo; <a class="el" href="group___internal-_core.html">Core</a> &raquo; <a class="el" href="group___core_thread-_internal.html">Core thread</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Manages a list of commands that can be queued for later execution on the core thread. </p>
</div>
<p>Inherited by <a class="el" href="classbs_1_1_command_queue.html">CommandQueue&lt; SyncPolicy &gt;</a>, and <a class="el" href="classbs_1_1_command_queue.html">CommandQueue&lt; bs::CommandQueueSync &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Methods</h2></td></tr>
<tr class="memitem:af5663458fe244c67af8244c48b3fe9ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_command_queue_base.html#af5663458fe244c67af8244c48b3fe9ae">CommandQueueBase</a> (<a class="el" href="group___threading.html#gae572b4cffa57c1aacfb26c487370061f">ThreadId</a> threadId)</td></tr>
<tr class="memdesc:af5663458fe244c67af8244c48b3fe9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#af5663458fe244c67af8244c48b3fe9ae">More...</a><br /></td></tr>
<tr class="separator:af5663458fe244c67af8244c48b3fe9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f32158c902b43cf91ebb748d0c462a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___threading.html#gae572b4cffa57c1aacfb26c487370061f">ThreadId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_command_queue_base.html#a5f32158c902b43cf91ebb748d0c462a8">getThreadId</a> () const</td></tr>
<tr class="memdesc:a5f32158c902b43cf91ebb748d0c462a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the thread identifier the command queue is used on.  <a href="#a5f32158c902b43cf91ebb748d0c462a8">More...</a><br /></td></tr>
<tr class="separator:a5f32158c902b43cf91ebb748d0c462a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97289fea2ff425baba96ece8eb5650d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_command_queue_base.html#a97289fea2ff425baba96ece8eb5650d3">playbackWithNotify</a> (<a class="el" href="group___containers.html#gad81cb80bc12b745899abea44d1e69ca4">Queue</a>&lt; <a class="el" href="structbs_1_1_queued_command.html">QueuedCommand</a> &gt; *commands, std::function&lt; void(UINT32)&gt; notifyCallback)</td></tr>
<tr class="memdesc:a97289fea2ff425baba96ece8eb5650d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes all provided commands one by one in order.  <a href="#a97289fea2ff425baba96ece8eb5650d3">More...</a><br /></td></tr>
<tr class="separator:a97289fea2ff425baba96ece8eb5650d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ad1a90a454e373698eac49bcdb691f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_command_queue_base.html#a52ad1a90a454e373698eac49bcdb691f">playback</a> (<a class="el" href="group___containers.html#gad81cb80bc12b745899abea44d1e69ca4">Queue</a>&lt; <a class="el" href="structbs_1_1_queued_command.html">QueuedCommand</a> &gt; *commands)</td></tr>
<tr class="memdesc:a52ad1a90a454e373698eac49bcdb691f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes all provided commands one by one in order.  <a href="#a52ad1a90a454e373698eac49bcdb691f">More...</a><br /></td></tr>
<tr class="separator:a52ad1a90a454e373698eac49bcdb691f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab650f257cd4c6d2409245cd7d845050a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbs_1_1_async_op.html">AsyncOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_command_queue_base.html#ab650f257cd4c6d2409245cd7d845050a">queueReturn</a> (std::function&lt; void(<a class="el" href="classbs_1_1_async_op.html">AsyncOp</a> &amp;)&gt; commandCallback, bool _notifyWhenComplete=false, UINT32 _callbackId=0)</td></tr>
<tr class="memdesc:ab650f257cd4c6d2409245cd7d845050a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue up a new command to execute.  <a href="#ab650f257cd4c6d2409245cd7d845050a">More...</a><br /></td></tr>
<tr class="separator:ab650f257cd4c6d2409245cd7d845050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29637a119cfff08107c5278fe4baa535"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_command_queue_base.html#a29637a119cfff08107c5278fe4baa535">queue</a> (std::function&lt; void()&gt; commandCallback, bool _notifyWhenComplete=false, UINT32 _callbackId=0)</td></tr>
<tr class="memdesc:a29637a119cfff08107c5278fe4baa535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue up a new command to execute.  <a href="#a29637a119cfff08107c5278fe4baa535">More...</a><br /></td></tr>
<tr class="separator:a29637a119cfff08107c5278fe4baa535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0788ea7682779860fd2fdc6c2b6e02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___containers.html#gad81cb80bc12b745899abea44d1e69ca4">Queue</a>&lt; <a class="el" href="structbs_1_1_queued_command.html">QueuedCommand</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_command_queue_base.html#a3a0788ea7682779860fd2fdc6c2b6e02">flush</a> ()</td></tr>
<tr class="memdesc:a3a0788ea7682779860fd2fdc6c2b6e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of all queued commands and makes room for new ones.  <a href="#a3a0788ea7682779860fd2fdc6c2b6e02">More...</a><br /></td></tr>
<tr class="separator:a3a0788ea7682779860fd2fdc6c2b6e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3618f3b53b9a0e735dfeb17b51d403a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_command_queue_base.html#ac3618f3b53b9a0e735dfeb17b51d403a">cancelAll</a> ()</td></tr>
<tr class="memdesc:ac3618f3b53b9a0e735dfeb17b51d403a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels all currently queued commands.  <a href="#ac3618f3b53b9a0e735dfeb17b51d403a">More...</a><br /></td></tr>
<tr class="separator:ac3618f3b53b9a0e735dfeb17b51d403a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af337ffd75e4f019ce15302c60715d84b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_command_queue_base.html#af337ffd75e4f019ce15302c60715d84b">isEmpty</a> ()</td></tr>
<tr class="memdesc:af337ffd75e4f019ce15302c60715d84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if no commands are queued.  <a href="#af337ffd75e4f019ce15302c60715d84b">More...</a><br /></td></tr>
<tr class="separator:af337ffd75e4f019ce15302c60715d84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static methods</h2></td></tr>
<tr class="memitem:adefc39f031d6e324b311e2c751320c71"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_command_queue_base.html#adefc39f031d6e324b311e2c751320c71">addBreakpoint</a> (UINT32 queueIdx, UINT32 commandIdx)</td></tr>
<tr class="memdesc:adefc39f031d6e324b311e2c751320c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to set a breakpoint that will trigger when the specified command is executed.  <a href="#adefc39f031d6e324b311e2c751320c71">More...</a><br /></td></tr>
<tr class="separator:adefc39f031d6e324b311e2c751320c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Method documentation</h2>
<a id="adefc39f031d6e324b311e2c751320c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefc39f031d6e324b311e2c751320c71">&#9670;&nbsp;</a></span>addBreakpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void addBreakpoint </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>queueIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>commandIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows you to set a breakpoint that will trigger when the specified command is executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueIdx</td><td>Zero-based index of the queue the command was queued on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandIdx</td><td>Zero-based index of the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><br />
This is helpful when you receive an error on the executing thread and you cannot tell from where was the command that caused the error queued from. However you can make a note of the queue and command index and set a breakpoint so that it gets triggered next time you run the program. At that point you can know exactly which part of code queued the command by examining the stack trace. </dd></dl>

</div>
</div>
<a id="ac3618f3b53b9a0e735dfeb17b51d403a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3618f3b53b9a0e735dfeb17b51d403a">&#9670;&nbsp;</a></span>cancelAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cancelAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels all currently queued commands. </p>

</div>
</div>
<a id="a3a0788ea7682779860fd2fdc6c2b6e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0788ea7682779860fd2fdc6c2b6e02">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___containers.html#gad81cb80bc12b745899abea44d1e69ca4">Queue</a>&lt;<a class="el" href="structbs_1_1_queued_command.html">QueuedCommand</a>&gt;* flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of all queued commands and makes room for new ones. </p>
<p>Must be called from the thread that created the command queue. Returned commands must be passed to <a class="el" href="classbs_1_1_command_queue_base.html#a52ad1a90a454e373698eac49bcdb691f" title="Executes all provided commands one by one in order. ">playback()</a> method. </p>

</div>
</div>
<a id="a5f32158c902b43cf91ebb748d0c462a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f32158c902b43cf91ebb748d0c462a8">&#9670;&nbsp;</a></span>getThreadId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___threading.html#gae572b4cffa57c1aacfb26c487370061f">ThreadId</a> getThreadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the thread identifier the command queue is used on. </p>
<dl class="section note"><dt>Note</dt><dd>If the command queue is using a synchonized access policy generally this is not relevant as it may be used on multiple threads. </dd></dl>

</div>
</div>
<a id="af337ffd75e4f019ce15302c60715d84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af337ffd75e4f019ce15302c60715d84b">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if no commands are queued. </p>

</div>
</div>
<a id="a52ad1a90a454e373698eac49bcdb691f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ad1a90a454e373698eac49bcdb691f">&#9670;&nbsp;</a></span>playback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___containers.html#gad81cb80bc12b745899abea44d1e69ca4">Queue</a>&lt; <a class="el" href="structbs_1_1_queued_command.html">QueuedCommand</a> &gt; *&#160;</td>
          <td class="paramname"><em>commands</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes all provided commands one by one in order. </p>
<p>To get the commands you should call <a class="el" href="classbs_1_1_command_queue_base.html#a3a0788ea7682779860fd2fdc6c2b6e02" title="Returns a copy of all queued commands and makes room for new ones. ">flush()</a>. </p>

</div>
</div>
<a id="a97289fea2ff425baba96ece8eb5650d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97289fea2ff425baba96ece8eb5650d3">&#9670;&nbsp;</a></span>playbackWithNotify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playbackWithNotify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___containers.html#gad81cb80bc12b745899abea44d1e69ca4">Queue</a>&lt; <a class="el" href="structbs_1_1_queued_command.html">QueuedCommand</a> &gt; *&#160;</td>
          <td class="paramname"><em>commands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(UINT32)&gt;&#160;</td>
          <td class="paramname"><em>notifyCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes all provided commands one by one in order. </p>
<p>To get the commands you should call <a class="el" href="classbs_1_1_command_queue_base.html#a3a0788ea7682779860fd2fdc6c2b6e02" title="Returns a copy of all queued commands and makes room for new ones. ">flush()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commands</td><td>Commands to execute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notifyCallback</td><td>Callback that will be called if a command that has <code>notifyOnComplete</code> flag set. The callback will receive <code>callbackId</code> of the command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29637a119cfff08107c5278fe4baa535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29637a119cfff08107c5278fe4baa535">&#9670;&nbsp;</a></span>queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queue </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>commandCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_notifyWhenComplete</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>_callbackId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue up a new command to execute. </p>
<p>Make sure the provided function has all of its parameters properly bound. Provided command is not expected to return a value. If you wish to return a value from the callback use the <a class="el" href="classbs_1_1_command_queue_base.html#ab650f257cd4c6d2409245cd7d845050a" title="Queue up a new command to execute. ">queueReturn()</a> which accepts an <a class="el" href="classbs_1_1_async_op.html" title="Object you may use to check on the results of an asynchronous operation. ">AsyncOp</a> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandCallback</td><td>Command to queue for execution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_notifyWhenComplete</td><td>(optional) Call the notify method (provided in the call to <a class="el" href="classbs_1_1_command_queue_base.html#a52ad1a90a454e373698eac49bcdb691f" title="Executes all provided commands one by one in order. ">playback()</a>) when the command is complete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_callbackId</td><td>(optional) Identifier for the callback so you can then later find it if needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab650f257cd4c6d2409245cd7d845050a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab650f257cd4c6d2409245cd7d845050a">&#9670;&nbsp;</a></span>queueReturn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbs_1_1_async_op.html">AsyncOp</a> queueReturn </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classbs_1_1_async_op.html">AsyncOp</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>commandCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_notifyWhenComplete</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>_callbackId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue up a new command to execute. </p>
<p>Make sure the provided function has all of its parameters properly bound. Last parameter must be unbound and of <a class="el" href="classbs_1_1_async_op.html" title="Object you may use to check on the results of an asynchronous operation. ">AsyncOp</a>&amp; type. This is used to signal that the command is completed, and also for storing the return value. <br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandCallback</td><td>Command to queue for execution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_notifyWhenComplete</td><td>(optional) Call the notify method (provided in the call to <a class="el" href="classbs_1_1_command_queue_base.html#a52ad1a90a454e373698eac49bcdb691f" title="Executes all provided commands one by one in order. ">playback()</a>) when the command is complete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_callbackId</td><td>(optional) Identifier for the callback so you can then later find it if needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Async operation object that you can continuously check until the command completes. After it completes AsyncOp::isResolved() will return true and return data will be valid (if the callback provided any).</dd></dl>
<dl class="section note"><dt>Note</dt><dd><br />
Callback method also needs to call AsyncOp::markAsResolved once it is done processing. (If it doesn't it will still be called automatically, but the return value will default to nullptr) </dd></dl>

</div>
</div>
<a id="a9665a887a5da1bb7b5c7f0fbf2eff335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9665a887a5da1bb7b5c7f0fbf2eff335">&#9670;&nbsp;</a></span>throwInvalidThreadException()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void throwInvalidThreadException </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method that throws an "Invalid thread" exception. </p>
<p>Used primarily so we can avoid including <a class="el" href="classbs_1_1_exception.html" title="Base class for all Banshee exceptions. ">Exception</a> include in this header. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af5663458fe244c67af8244c48b3fe9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5663458fe244c67af8244c48b3fe9ae">&#9670;&nbsp;</a></span>CommandQueueBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbs_1_1_command_queue_base.html">CommandQueueBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___threading.html#gae572b4cffa57c1aacfb26c487370061f">ThreadId</a>&#160;</td>
          <td class="paramname"><em>threadId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadId</td><td>Identifier for the thread the command queue will be getting commands from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
