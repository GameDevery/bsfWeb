<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-120676613-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-120676613-1');
</script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - VulkanRenderAPI Class Reference</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='https://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebs.html">bs</a></li><li class="navelem"><b>ct</b></li><li class="navelem"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html">VulkanRenderAPI</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Methods</a> &#124;
<a href="classbs_1_1ct_1_1_vulkan_render_a_p_i-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">VulkanRenderAPI Class Reference<div class="ingroups"><a class="el" href="group___plugins.html">Plugins</a> &raquo; <a class="el" href="group___vulkan.html">BansheeVulkanRenderAPI</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Implementation of a render system using Vulkan. </p>
<p>Provides abstracted access to various low level Vulkan methods. </p>
</div>
<p>Inherits <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html">RenderAPI</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Methods</h2></td></tr>
<tr class="memitem:a5099169c5d5949d4a96279844ad545ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbs_1_1_string_i_d.html">StringID</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a5099169c5d5949d4a96279844ad545ad">getName</a> () const override</td></tr>
<tr class="memdesc:a5099169c5d5949d4a96279844ad545ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the rendering system. <br />
  <a href="#a5099169c5d5949d4a96279844ad545ad">More...</a><br /></td></tr>
<tr class="separator:a5099169c5d5949d4a96279844ad545ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d06bc7ba63d82065a37664ad3098434"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a0d06bc7ba63d82065a37664ad3098434">setGraphicsPipeline</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_graphics_pipeline_state.html">GraphicsPipelineState</a> &gt; &amp;pipelineState, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a0d06bc7ba63d82065a37664ad3098434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a pipeline state that controls how will subsequent draw commands render primitives. <br />
  <a href="#a0d06bc7ba63d82065a37664ad3098434">More...</a><br /></td></tr>
<tr class="separator:a0d06bc7ba63d82065a37664ad3098434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3ee554197454cce52c13421779e3ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a5c3ee554197454cce52c13421779e3ac">setComputePipeline</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_compute_pipeline_state.html">ComputePipelineState</a> &gt; &amp;pipelineState, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a5c3ee554197454cce52c13421779e3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a pipeline state that controls how will subsequent dispatch commands execute. <br />
  <a href="#a5c3ee554197454cce52c13421779e3ac">More...</a><br /></td></tr>
<tr class="separator:a5c3ee554197454cce52c13421779e3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb90fad9397c2bad313abb1efa523845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#abb90fad9397c2bad313abb1efa523845">setGpuParams</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_gpu_params.html">GpuParams</a> &gt; &amp;gpuParams, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:abb90fad9397c2bad313abb1efa523845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a set of parameters that control execution of all currently bound GPU programs. <br />
  <a href="#abb90fad9397c2bad313abb1efa523845">More...</a><br /></td></tr>
<tr class="separator:abb90fad9397c2bad313abb1efa523845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f0245bd3b64909cddab2a8f5d2ee80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a91f0245bd3b64909cddab2a8f5d2ee80">clearRenderTarget</a> (UINT32 buffers, const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;color=Color::Black, float depth=1.0f, UINT16 stencil=0, UINT8 targetMask=0xFF, const SPtr&lt; CommandBuffer &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a91f0245bd3b64909cddab2a8f5d2ee80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the currently active render target. <br />
  <a href="#a91f0245bd3b64909cddab2a8f5d2ee80">More...</a><br /></td></tr>
<tr class="separator:a91f0245bd3b64909cddab2a8f5d2ee80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c11c7d446f639196adf69b56308a228"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a5c11c7d446f639196adf69b56308a228">clearViewport</a> (UINT32 buffers, const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;color=Color::Black, float depth=1.0f, UINT16 stencil=0, UINT8 targetMask=0xFF, const SPtr&lt; CommandBuffer &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a5c11c7d446f639196adf69b56308a228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the currently active viewport (meaning it clears just a sub-area of a render-target that is covered by the viewport, as opposed to <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a91f0245bd3b64909cddab2a8f5d2ee80" title="Clears the currently active render target.   ">clearRenderTarget()</a> which always clears the entire render target). <br />
  <a href="#a5c11c7d446f639196adf69b56308a228">More...</a><br /></td></tr>
<tr class="separator:a5c11c7d446f639196adf69b56308a228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25e6df723f29a5647adced8b644e06d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#af25e6df723f29a5647adced8b644e06d">setRenderTarget</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_target.html">RenderTarget</a> &gt; &amp;target, UINT32 readOnlyFlags=0, <a class="el" href="classbs_1_1_flags.html">RenderSurfaceMask</a> loadMask=RT_NONE, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:af25e6df723f29a5647adced8b644e06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the render target into which we want to draw. <br />
  <a href="#af25e6df723f29a5647adced8b644e06d">More...</a><br /></td></tr>
<tr class="separator:af25e6df723f29a5647adced8b644e06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc830dd83363d37c5d07f055b0e4b84f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#afc830dd83363d37c5d07f055b0e4b84f">setViewport</a> (const <a class="el" href="classbs_1_1_rect2.html">Rect2</a> &amp;area, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:afc830dd83363d37c5d07f055b0e4b84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the active viewport that will be used for all render operations. <br />
  <a href="#afc830dd83363d37c5d07f055b0e4b84f">More...</a><br /></td></tr>
<tr class="separator:afc830dd83363d37c5d07f055b0e4b84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedff3bdfd598d4200f81d7433ac27307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#aedff3bdfd598d4200f81d7433ac27307">setScissorRect</a> (UINT32 left, UINT32 top, UINT32 right, UINT32 bottom, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:aedff3bdfd598d4200f81d7433ac27307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to set up a region in which rendering can take place. <br />
  <a href="#aedff3bdfd598d4200f81d7433ac27307">More...</a><br /></td></tr>
<tr class="separator:aedff3bdfd598d4200f81d7433ac27307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8812da33be62834c28e7933735d279"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a4d8812da33be62834c28e7933735d279">setStencilRef</a> (UINT32 value, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a4d8812da33be62834c28e7933735d279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a reference value that will be used for stencil compare operations. <br />
  <a href="#a4d8812da33be62834c28e7933735d279">More...</a><br /></td></tr>
<tr class="separator:a4d8812da33be62834c28e7933735d279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fd1d924e30098801bdb8fc72df380b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#ac6fd1d924e30098801bdb8fc72df380b">setVertexBuffers</a> (UINT32 index, <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vertex_buffer.html">VertexBuffer</a> &gt; *buffers, UINT32 numBuffers, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:ac6fd1d924e30098801bdb8fc72df380b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the provided vertex buffers starting at the specified source index. <br />
  <a href="#ac6fd1d924e30098801bdb8fc72df380b">More...</a><br /></td></tr>
<tr class="separator:ac6fd1d924e30098801bdb8fc72df380b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631b9a35f09b7ba4135ce2d4fad24f2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a631b9a35f09b7ba4135ce2d4fad24f2b">setIndexBuffer</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_index_buffer.html">IndexBuffer</a> &gt; &amp;buffer, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a631b9a35f09b7ba4135ce2d4fad24f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an index buffer to use when drawing. <br />
  <a href="#a631b9a35f09b7ba4135ce2d4fad24f2b">More...</a><br /></td></tr>
<tr class="separator:a631b9a35f09b7ba4135ce2d4fad24f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2f84b7fd7ec04c7de0073f923fcdb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#abc2f84b7fd7ec04c7de0073f923fcdb6">setVertexDeclaration</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vertex_declaration.html">VertexDeclaration</a> &gt; &amp;vertexDeclaration, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:abc2f84b7fd7ec04c7de0073f923fcdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex declaration to use when drawing. <br />
  <a href="#abc2f84b7fd7ec04c7de0073f923fcdb6">More...</a><br /></td></tr>
<tr class="separator:abc2f84b7fd7ec04c7de0073f923fcdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ce409ebfc2b11c4844de7940492b5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a43ce409ebfc2b11c4844de7940492b5b">setDrawOperation</a> (<a class="el" href="group___utility-_core.html#ga0a43fbead35d1ad167d465731c5c4c53">DrawOperationType</a> op, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a43ce409ebfc2b11c4844de7940492b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the draw operation that determines how to interpret the elements of the index or vertex buffers. <br />
  <a href="#a43ce409ebfc2b11c4844de7940492b5b">More...</a><br /></td></tr>
<tr class="separator:a43ce409ebfc2b11c4844de7940492b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642b62982d6728d871bc8539be665c77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a642b62982d6728d871bc8539be665c77">draw</a> (UINT32 vertexOffset, UINT32 vertexCount, UINT32 instanceCount=0, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a642b62982d6728d871bc8539be665c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an object based on currently bound GPU programs, vertex declaration and vertex buffers. <br />
  <a href="#a642b62982d6728d871bc8539be665c77">More...</a><br /></td></tr>
<tr class="separator:a642b62982d6728d871bc8539be665c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eba64fc575bb70517d8c35f2b77f66a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a8eba64fc575bb70517d8c35f2b77f66a">drawIndexed</a> (UINT32 startIndex, UINT32 indexCount, UINT32 vertexOffset, UINT32 vertexCount, UINT32 instanceCount=0, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a8eba64fc575bb70517d8c35f2b77f66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an object based on currently bound GPU programs, vertex declaration, vertex and index buffers. <br />
  <a href="#a8eba64fc575bb70517d8c35f2b77f66a">More...</a><br /></td></tr>
<tr class="separator:a8eba64fc575bb70517d8c35f2b77f66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9634714c4d37ce1a794787eda55570b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a9634714c4d37ce1a794787eda55570b1">dispatchCompute</a> (UINT32 numGroupsX, UINT32 numGroupsY=1, UINT32 numGroupsZ=1, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a9634714c4d37ce1a794787eda55570b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the currently bound compute shader. <br />
  <a href="#a9634714c4d37ce1a794787eda55570b1">More...</a><br /></td></tr>
<tr class="separator:a9634714c4d37ce1a794787eda55570b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45aa4fc19ef23ccacb2ad0de3b7d449e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a45aa4fc19ef23ccacb2ad0de3b7d449e">swapBuffers</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_target.html">RenderTarget</a> &gt; &amp;target, UINT32 syncMask=0xFFFFFFFF) override</td></tr>
<tr class="memdesc:a45aa4fc19ef23ccacb2ad0de3b7d449e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the front and back buffer of the specified render target. <br />
  <a href="#a45aa4fc19ef23ccacb2ad0de3b7d449e">More...</a><br /></td></tr>
<tr class="separator:a45aa4fc19ef23ccacb2ad0de3b7d449e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657c493f81508905b613366918c48420"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a657c493f81508905b613366918c48420">addCommands</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;secondary) override</td></tr>
<tr class="memdesc:a657c493f81508905b613366918c48420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all commands from the provided secondary command buffer into the primary command buffer. <br />
  <a href="#a657c493f81508905b613366918c48420">More...</a><br /></td></tr>
<tr class="separator:a657c493f81508905b613366918c48420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4028d9ce0fd012246b961b6751a764b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a4028d9ce0fd012246b961b6751a764b2">submitCommandBuffer</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer, UINT32 syncMask=0xFFFFFFFF) override</td></tr>
<tr class="memdesc:a4028d9ce0fd012246b961b6751a764b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes all commands in the provided command buffer. <br />
  <a href="#a4028d9ce0fd012246b961b6751a764b2">More...</a><br /></td></tr>
<tr class="separator:a4028d9ce0fd012246b961b6751a764b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52623f1583db791bf9fc12692e2c477"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#af52623f1583db791bf9fc12692e2c477">convertProjectionMatrix</a> (const <a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> &amp;matrix, <a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> &amp;dest) override</td></tr>
<tr class="memdesc:af52623f1583db791bf9fc12692e2c477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a default matrix into a matrix suitable for use by this specific render system. <br />
  <a href="#af52623f1583db791bf9fc12692e2c477">More...</a><br /></td></tr>
<tr class="separator:af52623f1583db791bf9fc12692e2c477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a90f56b153b7ff73d4171e675cd6ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbs_1_1_render_a_p_i_info.html">RenderAPIInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a35a90f56b153b7ff73d4171e675cd6ad">getAPIInfo</a> () const override</td></tr>
<tr class="memdesc:a35a90f56b153b7ff73d4171e675cd6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about the specific API implementation. <br />
  <a href="#a35a90f56b153b7ff73d4171e675cd6ad">More...</a><br /></td></tr>
<tr class="separator:a35a90f56b153b7ff73d4171e675cd6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a111d30df3a3ccd22861e61207a31e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbs_1_1_gpu_param_block_desc.html">GpuParamBlockDesc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a9a111d30df3a3ccd22861e61207a31e1">generateParamBlockDesc</a> (const <a class="el" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> &amp;name, <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="structbs_1_1_gpu_param_data_desc.html">GpuParamDataDesc</a> &gt; &amp;params) override</td></tr>
<tr class="memdesc:a9a111d30df3a3ccd22861e61207a31e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a parameter block description and calculates per-parameter offsets for the provided gpu data parameters. <br />
  <a href="#a9a111d30df3a3ccd22861e61207a31e1">More...</a><br /></td></tr>
<tr class="separator:a9a111d30df3a3ccd22861e61207a31e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Internal</div></td></tr>
<tr class="memitem:a54c47ef0e465bf9e289e4baef777752f"><td class="memItemLeft" align="right" valign="top">VkInstance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a54c47ef0e465bf9e289e4baef777752f">_getInstance</a> () const</td></tr>
<tr class="memdesc:a54c47ef0e465bf9e289e4baef777752f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal Vulkan instance object.  <a href="#a54c47ef0e465bf9e289e4baef777752f">More...</a><br /></td></tr>
<tr class="separator:a54c47ef0e465bf9e289e4baef777752f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25bf3d87c0a3199451d7b56e37c9909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vulkan_device.html">VulkanDevice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#ad25bf3d87c0a3199451d7b56e37c9909">_getDevice</a> (UINT32 idx) const</td></tr>
<tr class="memdesc:ad25bf3d87c0a3199451d7b56e37c9909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Vulkan device at the specified index.  <a href="#ad25bf3d87c0a3199451d7b56e37c9909">More...</a><br /></td></tr>
<tr class="separator:ad25bf3d87c0a3199451d7b56e37c9909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8cc91ec035a929f193bac87f0d34bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vulkan_device.html">VulkanDevice</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a2d8cc91ec035a929f193bac87f0d34bd">_getPresentDevice</a> () const</td></tr>
<tr class="memdesc:a2d8cc91ec035a929f193bac87f0d34bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the primary device that supports swap chain present operations.  <a href="#a2d8cc91ec035a929f193bac87f0d34bd">More...</a><br /></td></tr>
<tr class="separator:a2d8cc91ec035a929f193bac87f0d34bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbe378bfd5797866dd72ab7d8b2ba44"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a0fbe378bfd5797866dd72ab7d8b2ba44">_getNumDevices</a> () const</td></tr>
<tr class="memdesc:a0fbe378bfd5797866dd72ab7d8b2ba44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of Vulkan compatible devices available on this system.  <a href="#a0fbe378bfd5797866dd72ab7d8b2ba44">More...</a><br /></td></tr>
<tr class="separator:a0fbe378bfd5797866dd72ab7d8b2ba44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381827d97f6623a47a6b66fa52b692af"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vulkan_device.html">VulkanDevice</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a381827d97f6623a47a6b66fa52b692af">_getPrimaryDevices</a> () const</td></tr>
<tr class="memdesc:a381827d97f6623a47a6b66fa52b692af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one or multiple devices recognized as primary.  <a href="#a381827d97f6623a47a6b66fa52b692af">More...</a><br /></td></tr>
<tr class="separator:a381827d97f6623a47a6b66fa52b692af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28686defe17f923a18271aefde2cff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbs_1_1ct_1_1_vulkan_command_buffer.html">VulkanCommandBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#ae28686defe17f923a18271aefde2cff2">_getMainCommandBuffer</a> () const</td></tr>
<tr class="memdesc:ae28686defe17f923a18271aefde2cff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the main command buffer, executing on the graphics queue.  <a href="#ae28686defe17f923a18271aefde2cff2">More...</a><br /></td></tr>
<tr class="separator:ae28686defe17f923a18271aefde2cff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classbs_1_1ct_1_1_render_a_p_i')"><img src="closed.png" alt="-"/>&#160;Methods inherited from <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html">RenderAPI</a></td></tr>
<tr class="memitem:af4391aff66b3a8a6b9fa9f318b1e0763 inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbs_1_1_render_a_p_i_capabilities.html">RenderAPICapabilities</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#af4391aff66b3a8a6b9fa9f318b1e0763">getCapabilities</a> (UINT32 deviceIdx) const</td></tr>
<tr class="memdesc:af4391aff66b3a8a6b9fa9f318b1e0763 inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the capabilities of a specific GPU.  <a href="classbs_1_1ct_1_1_render_a_p_i.html#af4391aff66b3a8a6b9fa9f318b1e0763">More...</a><br /></td></tr>
<tr class="separator:af4391aff66b3a8a6b9fa9f318b1e0763 inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa47621db2c7fa844fd178af921b8f2 inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a2fa47621db2c7fa844fd178af921b8f2">getNumDevices</a> () const</td></tr>
<tr class="memdesc:a2fa47621db2c7fa844fd178af921b8f2 inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of devices supported by this render API.  <a href="classbs_1_1ct_1_1_render_a_p_i.html#a2fa47621db2c7fa844fd178af921b8f2">More...</a><br /></td></tr>
<tr class="separator:a2fa47621db2c7fa844fd178af921b8f2 inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e037344fde0e4cdb31d343fa158e7d inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbs_1_1_video_mode_info.html">VideoModeInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ad8e037344fde0e4cdb31d343fa158e7d">getVideoModeInfo</a> () const</td></tr>
<tr class="memdesc:ad8e037344fde0e4cdb31d343fa158e7d inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about available output devices and their video modes.  <a href="classbs_1_1ct_1_1_render_a_p_i.html#ad8e037344fde0e4cdb31d343fa158e7d">More...</a><br /></td></tr>
<tr class="separator:ad8e037344fde0e4cdb31d343fa158e7d inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classbs_1_1_module"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classbs_1_1_module')"><img src="closed.png" alt="-"/>&#160;Static methods inherited from <a class="el" href="classbs_1_1_module.html">Module&lt; RenderAPI &gt;</a></td></tr>
<tr class="memitem:a359703743cd890f1e3df60b6b06a5724 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbs_1_1_render_a_p_i.html">RenderAPI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a359703743cd890f1e3df60b6b06a5724">instance</a> ()</td></tr>
<tr class="memdesc:a359703743cd890f1e3df60b6b06a5724 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the module instance.  <a href="classbs_1_1_module.html#a359703743cd890f1e3df60b6b06a5724">More...</a><br /></td></tr>
<tr class="separator:a359703743cd890f1e3df60b6b06a5724 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affac4ec5f49e5e5561a027e3116e6f73 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbs_1_1_render_a_p_i.html">RenderAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#affac4ec5f49e5e5561a027e3116e6f73">instancePtr</a> ()</td></tr>
<tr class="memdesc:affac4ec5f49e5e5561a027e3116e6f73 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the module instance.  <a href="classbs_1_1_module.html#affac4ec5f49e5e5561a027e3116e6f73">More...</a><br /></td></tr>
<tr class="separator:affac4ec5f49e5e5561a027e3116e6f73 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b9d091b1b64652c94d5dd3b1c5017a inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a02b9d091b1b64652c94d5dd3b1c5017a">startUp</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a02b9d091b1b64652c94d5dd3b1c5017a inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and starts the module using the specified parameters.  <a href="classbs_1_1_module.html#a02b9d091b1b64652c94d5dd3b1c5017a">More...</a><br /></td></tr>
<tr class="separator:a02b9d091b1b64652c94d5dd3b1c5017a inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1a58af7a42d68c1ae45e40fbe8cebb inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a4d1a58af7a42d68c1ae45e40fbe8cebb">startUp</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a4d1a58af7a42d68c1ae45e40fbe8cebb inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and starts a specialized type of the module.  <a href="classbs_1_1_module.html#a4d1a58af7a42d68c1ae45e40fbe8cebb">More...</a><br /></td></tr>
<tr class="separator:a4d1a58af7a42d68c1ae45e40fbe8cebb inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ea87e87e28686a619551382f541433 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#aa4ea87e87e28686a619551382f541433">shutDown</a> ()</td></tr>
<tr class="memdesc:aa4ea87e87e28686a619551382f541433 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down this module and frees any resources it is using.  <a href="classbs_1_1_module.html#aa4ea87e87e28686a619551382f541433">More...</a><br /></td></tr>
<tr class="separator:aa4ea87e87e28686a619551382f541433 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289734510f3022acd240087478b994d9 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a289734510f3022acd240087478b994d9">isStarted</a> ()</td></tr>
<tr class="memdesc:a289734510f3022acd240087478b994d9 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if the module has been started.  <a href="classbs_1_1_module.html#a289734510f3022acd240087478b994d9">More...</a><br /></td></tr>
<tr class="separator:a289734510f3022acd240087478b994d9 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Method documentation</h2>
<a id="ad25bf3d87c0a3199451d7b56e37c9909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25bf3d87c0a3199451d7b56e37c9909">&#9670;&nbsp;</a></span>_getDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1ct_1_1_vulkan_device.html">VulkanDevice</a>&gt; _getDevice </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Vulkan device at the specified index. </p>
<p>Must be in range [0, <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a0fbe378bfd5797866dd72ab7d8b2ba44" title="Gets the total number of Vulkan compatible devices available on this system. ">_getNumDevices()</a>) </p>

</div>
</div>
<a id="a54c47ef0e465bf9e289e4baef777752f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c47ef0e465bf9e289e4baef777752f">&#9670;&nbsp;</a></span>_getInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkInstance _getInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the internal Vulkan instance object. </p>

</div>
</div>
<a id="ae28686defe17f923a18271aefde2cff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28686defe17f923a18271aefde2cff2">&#9670;&nbsp;</a></span>_getMainCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbs_1_1ct_1_1_vulkan_command_buffer.html">VulkanCommandBuffer</a>* _getMainCommandBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the main command buffer, executing on the graphics queue. </p>

</div>
</div>
<a id="a0fbe378bfd5797866dd72ab7d8b2ba44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbe378bfd5797866dd72ab7d8b2ba44">&#9670;&nbsp;</a></span>_getNumDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 _getNumDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the total number of Vulkan compatible devices available on this system. </p>

</div>
</div>
<a id="a2d8cc91ec035a929f193bac87f0d34bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8cc91ec035a929f193bac87f0d34bd">&#9670;&nbsp;</a></span>_getPresentDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1ct_1_1_vulkan_device.html">VulkanDevice</a>&gt; _getPresentDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the primary device that supports swap chain present operations. </p>

</div>
</div>
<a id="a381827d97f6623a47a6b66fa52b692af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381827d97f6623a47a6b66fa52b692af">&#9670;&nbsp;</a></span>_getPrimaryDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt;<a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1ct_1_1_vulkan_device.html">VulkanDevice</a>&gt; &gt; _getPrimaryDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one or multiple devices recognized as primary. </p>
<p>This will be a single device in most cases, or multiple devices if using some kind of a supported multi-GPU setup. </p>

</div>
</div>
<a id="a657c493f81508905b613366918c48420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657c493f81508905b613366918c48420">&#9670;&nbsp;</a></span>addCommands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addCommands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>secondary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all commands from the provided secondary command buffer into the primary command buffer. <br />
 </p>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a100a6f2c03e04d56355177a848d811aa">RenderAPI</a>.</p>

</div>
</div>
<a id="a91f0245bd3b64909cddab2a8f5d2ee80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f0245bd3b64909cddab2a8f5d2ee80">&#9670;&nbsp;</a></span>clearRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearRenderTarget </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em> = <code>Color::Black</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>stencil</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8&#160;</td>
          <td class="paramname"><em>targetMask</em> = <code>0xFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the currently active render target. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>Combination of one or more elements of FrameBufferType denoting which buffers are to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to clear the color buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>The value to initialize the depth buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stencil</td><td>The value to initialize the stencil buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetMask</td><td>In case multiple render targets are bound, this allows you to control which ones to clear (0x01 first, 0x02 second, 0x04 third, etc., and combinations). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#aa322bfe6a30f71ec423e6f08c8734458">RenderAPI</a>.</p>

</div>
</div>
<a id="a5c11c7d446f639196adf69b56308a228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c11c7d446f639196adf69b56308a228">&#9670;&nbsp;</a></span>clearViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearViewport </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em> = <code>Color::Black</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>stencil</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8&#160;</td>
          <td class="paramname"><em>targetMask</em> = <code>0xFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the currently active viewport (meaning it clears just a sub-area of a render-target that is covered by the viewport, as opposed to <a class="el" href="classbs_1_1ct_1_1_vulkan_render_a_p_i.html#a91f0245bd3b64909cddab2a8f5d2ee80" title="Clears the currently active render target.   ">clearRenderTarget()</a> which always clears the entire render target). <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>Combination of one or more elements of FrameBufferType denoting which buffers are to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to clear the color buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>The value to initialize the depth buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stencil</td><td>The value to initialize the stencil buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetMask</td><td>In case multiple render targets are bound, this allows you to control which ones to clear (0x01 first, 0x02 second, 0x04 third, etc., and combinations). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#aa18d21e36f2474fa6a76b27ab85124b0">RenderAPI</a>.</p>

</div>
</div>
<a id="af52623f1583db791bf9fc12692e2c477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52623f1583db791bf9fc12692e2c477">&#9670;&nbsp;</a></span>convertProjectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void convertProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains a default matrix into a matrix suitable for use by this specific render system. <br />
 </p>
<dl class="section note"><dt>Note</dt><dd>Thread safe. </dd></dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a39286473640751160bdb8536c859f413">RenderAPI</a>.</p>

</div>
</div>
<a id="ac8cf325a37d7e7f96eed609f7d426bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cf325a37d7e7f96eed609f7d426bba">&#9670;&nbsp;</a></span>destroyCore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void destroyCore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs render API system shutdown on the core thread. <br />
 </p>

<p>Reimplemented from <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a30aad4dcf6e2df219ea8d2eb6da62c9c">RenderAPI</a>.</p>

</div>
</div>
<a id="a9634714c4d37ce1a794787eda55570b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9634714c4d37ce1a794787eda55570b1">&#9670;&nbsp;</a></span>dispatchCompute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dispatchCompute </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numGroupsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numGroupsY</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numGroupsZ</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the currently bound compute shader. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numGroupsX</td><td>Number of groups to start in the X direction. Must be in range [1, 65535]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numGroupsY</td><td>Number of groups to start in the Y direction. Must be in range [1, 65535]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numGroupsZ</td><td>Number of groups to start in the Z direction. Must be in range [1, 64]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support compute or graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a54c8eb09649871e3ea3de65fa79bdf12">RenderAPI</a>.</p>

</div>
</div>
<a id="a642b62982d6728d871bc8539be665c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642b62982d6728d871bc8539be665c77">&#9670;&nbsp;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void draw </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>vertexOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>instanceCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw an object based on currently bound GPU programs, vertex declaration and vertex buffers. <br />
 </p>
<p>Draws directly from the vertex buffer without using indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexOffset</td><td>Offset into the currently bound vertex buffer to start drawing from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexCount</td><td>Number of vertices to draw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">instanceCount</td><td>Number of times to draw the provided geometry, each time with an (optionally) separate per-instance data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a1cc00f62de16b8141290d68cfe7b67a4">RenderAPI</a>.</p>

</div>
</div>
<a id="a8eba64fc575bb70517d8c35f2b77f66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eba64fc575bb70517d8c35f2b77f66a">&#9670;&nbsp;</a></span>drawIndexed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drawIndexed </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>indexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>vertexOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>instanceCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw an object based on currently bound GPU programs, vertex declaration, vertex and index buffers. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>Offset into the currently bound index buffer to start drawing from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexCount</td><td>Number of indices to draw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexOffset</td><td>Offset to apply to each vertex index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexCount</td><td>Number of vertices to draw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">instanceCount</td><td>Number of times to draw the provided geometry, each time with an (optionally) separate per-instance data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ae7f5b32d5f5e2f8016b5c9d5078d28e4">RenderAPI</a>.</p>

</div>
</div>
<a id="a9a111d30df3a3ccd22861e61207a31e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a111d30df3a3ccd22861e61207a31e1">&#9670;&nbsp;</a></span>generateParamBlockDesc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbs_1_1_gpu_param_block_desc.html">GpuParamBlockDesc</a> generateParamBlockDesc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="structbs_1_1_gpu_param_data_desc.html">GpuParamDataDesc</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a parameter block description and calculates per-parameter offsets for the provided gpu data parameters. <br />
 </p>
<p>The offsets are render API specific and correspond to std140 layout for OpenGL, and the default layout in DirectX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name to assign the parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>List of parameters in the parameter block. Only name, type and array size fields need to be populated, the rest will be populated when the method returns. If a parameter is a struct then the elementSize field needs to be populated with the size of the struct in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Descriptor for the parameter block holding the provided parameters as laid out by the default render API layout. </dd></dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a9400792256a05759150326c41b6b4c20">RenderAPI</a>.</p>

</div>
</div>
<a id="a35a90f56b153b7ff73d4171e675cd6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a90f56b153b7ff73d4171e675cd6ad">&#9670;&nbsp;</a></span>getAPIInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbs_1_1_render_a_p_i_info.html">RenderAPIInfo</a>&amp; getAPIInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns information about the specific API implementation. <br />
 </p>
<dl class="section note"><dt>Note</dt><dd>Thread safe. </dd></dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a0ab54829757e2024801388a91d50c8fd">RenderAPI</a>.</p>

</div>
</div>
<a id="addc35f858acc82d721d5bd5e6b4f80d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc35f858acc82d721d5bd5e6b4f80d2">&#9670;&nbsp;</a></span>getCB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbs_1_1ct_1_1_vulkan_command_buffer.html">VulkanCommandBuffer</a>* getCB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a valid command buffer. </p>
<p>Uses the provided buffer if not null. Otherwise returns the default command buffer. </p>

</div>
</div>
<a id="a5099169c5d5949d4a96279844ad545ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5099169c5d5949d4a96279844ad545ad">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbs_1_1_string_i_d.html">StringID</a>&amp; getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the rendering system. <br />
 </p>
<dl class="section note"><dt>Note</dt><dd>Thread safe. </dd></dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a293c9f17a04b517323dcab8d267ad62e">RenderAPI</a>.</p>

</div>
</div>
<a id="ad0b646d9c5cf048f14b8b2ea5d73924f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b646d9c5cf048f14b8b2ea5d73924f">&#9670;&nbsp;</a></span>initCapabilites()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initCapabilites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and populates a set of render system capabilities describing which functionality is available. </p>

</div>
</div>
<a id="a371caef26098f2a15df9fbee047b58f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371caef26098f2a15df9fbee047b58f2">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the render API system and creates a primary render window. <br />
 </p>
<dl class="section note"><dt>Note</dt><dd>Sim thread only. </dd></dl>

<p>Reimplemented from <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a6365dca5a7d8ddb694726a53b55a4c27">RenderAPI</a>.</p>

</div>
</div>
<a id="a5c3ee554197454cce52c13421779e3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3ee554197454cce52c13421779e3ac">&#9670;&nbsp;</a></span>setComputePipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setComputePipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_compute_pipeline_state.html">ComputePipelineState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pipelineState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a pipeline state that controls how will subsequent dispatch commands execute. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pipelineState</td><td>Pipeline state to bind, or null to unbind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#af1470f65f420f136d5b01f2a2b0df02c">RenderAPI</a>.</p>

</div>
</div>
<a id="a43ce409ebfc2b11c4844de7940492b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ce409ebfc2b11c4844de7940492b5b">&#9670;&nbsp;</a></span>setDrawOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setDrawOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga0a43fbead35d1ad167d465731c5c4c53">DrawOperationType</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the draw operation that determines how to interpret the elements of the index or vertex buffers. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Draw operation to enable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a70180438d34bfce5c147221ff1448ddf">RenderAPI</a>.</p>

</div>
</div>
<a id="abb90fad9397c2bad313abb1efa523845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb90fad9397c2bad313abb1efa523845">&#9670;&nbsp;</a></span>setGpuParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGpuParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_gpu_params.html">GpuParams</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpuParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a set of parameters that control execution of all currently bound GPU programs. <br />
 </p>
<p>These are the uniforms like textures, samplers, or uniform buffers. Caller is expected to ensure the provided parameters actually match the currently bound programs. </p>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ac882c9af0c546bd2405637a5373c0a99">RenderAPI</a>.</p>

</div>
</div>
<a id="a0d06bc7ba63d82065a37664ad3098434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d06bc7ba63d82065a37664ad3098434">&#9670;&nbsp;</a></span>setGraphicsPipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_graphics_pipeline_state.html">GraphicsPipelineState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pipelineState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a pipeline state that controls how will subsequent draw commands render primitives. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pipelineState</td><td>Pipeline state to bind, or null to unbind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbs_1_1ct_1_1_graphics_pipeline_state.html" title="Core thread version of a bs::GraphicsPipelineState. ">GraphicsPipelineState</a> </dd></dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a7d1aae55785c78bfac4e1e8326d34413">RenderAPI</a>.</p>

</div>
</div>
<a id="a631b9a35f09b7ba4135ce2d4fad24f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631b9a35f09b7ba4135ce2d4fad24f2b">&#9670;&nbsp;</a></span>setIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_index_buffer.html">IndexBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets an index buffer to use when drawing. <br />
 </p>
<p>Indices in an index buffer reference vertices in the vertex buffer, which increases cache coherency and reduces the size of vertex buffers by eliminating duplicate data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Index buffer to bind, null to unbind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ae5c209ee82baae076db87065569a5b5b">RenderAPI</a>.</p>

</div>
</div>
<a id="af25e6df723f29a5647adced8b644e06d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25e6df723f29a5647adced8b644e06d">&#9670;&nbsp;</a></span>setRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setRenderTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_target.html">RenderTarget</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>readOnlyFlags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbs_1_1_flags.html">RenderSurfaceMask</a>&#160;</td>
          <td class="paramname"><em>loadMask</em> = <code>RT_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the render target into which we want to draw. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Render target to draw to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">readOnlyFlags</td><td>Combination of one or more elements of FrameBufferType denoting which buffers will be bound for read-only operations. This is useful for depth or stencil buffers which need to be bound both for depth/stencil tests, as well as shader reads. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loadMask</td><td>Determines which render target surfaces will have their current contents preserved. By default when a render target is bound its contents will be lost. You might need to preserve contents if you need to perform blending or similar operations with the existing contents of the render target.</td></tr>
  </table>
  </dd>
</dl>
<p>Use the mask to select exactly which surfaces of the render target need their contents preserved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ace358e66fbeec1253cbd3211bbf1e2d1">RenderAPI</a>.</p>

</div>
</div>
<a id="aedff3bdfd598d4200f81d7433ac27307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedff3bdfd598d4200f81d7433ac27307">&#9670;&nbsp;</a></span>setScissorRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setScissorRect </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows you to set up a region in which rendering can take place. <br />
 </p>
<p>Coordinates are in pixels. No rendering will be done to render target pixels outside of the provided region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>Left border of the scissor rectangle, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Top border of the scissor rectangle, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Right border of the scissor rectangle, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>Bottom border of the scissor rectangle, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a9ded76085d80d960bd82a190708ad0d9">RenderAPI</a>.</p>

</div>
</div>
<a id="a4d8812da33be62834c28e7933735d279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8812da33be62834c28e7933735d279">&#9670;&nbsp;</a></span>setStencilRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setStencilRef </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a reference value that will be used for stencil compare operations. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Reference value to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a42c3728748c7fd95e861d7d1fc54a482">RenderAPI</a>.</p>

</div>
</div>
<a id="ac6fd1d924e30098801bdb8fc72df380b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fd1d924e30098801bdb8fc72df380b">&#9670;&nbsp;</a></span>setVertexBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setVertexBuffers </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vertex_buffer.html">VertexBuffer</a> &gt; *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the provided vertex buffers starting at the specified source index. <br />
 </p>
<p>Set buffer to nullptr to clear the buffer at the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index at which to start binding the vertex buffers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>A list of buffers to bind to the pipeline. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBuffers</td><td>Number of buffers in the <code>buffers</code> list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ab0e37a2417121c9cd5af10c81dc334ce">RenderAPI</a>.</p>

</div>
</div>
<a id="abc2f84b7fd7ec04c7de0073f923fcdb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2f84b7fd7ec04c7de0073f923fcdb6">&#9670;&nbsp;</a></span>setVertexDeclaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setVertexDeclaration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vertex_declaration.html">VertexDeclaration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the vertex declaration to use when drawing. <br />
 </p>
<p>Vertex declaration is used to decode contents of a single vertex in a vertex buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexDeclaration</td><td>Vertex declaration to bind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a0e6be919aec953bca0fad3f824645d18">RenderAPI</a>.</p>

</div>
</div>
<a id="afc830dd83363d37c5d07f055b0e4b84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc830dd83363d37c5d07f055b0e4b84f">&#9670;&nbsp;</a></span>setViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setViewport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_rect2.html">Rect2</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the active viewport that will be used for all render operations. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Area of the viewport, in normalized ([0,1] range) coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#afd7a3caf480306534477ca6b8ff4574f">RenderAPI</a>.</p>

</div>
</div>
<a id="a4028d9ce0fd012246b961b6751a764b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4028d9ce0fd012246b961b6751a764b2">&#9670;&nbsp;</a></span>submitCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void submitCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>syncMask</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes all commands in the provided command buffer. <br />
 </p>
<p>Command buffer cannot be secondary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Command buffer whose commands to execute. Set to null to submit the main command buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">syncMask</td><td>Optional synchronization mask that determines if the submitted command buffer depends on any other command buffers. Use the <a class="el" href="classbs_1_1ct_1_1_command_sync_mask.html" title="Mask that determines synchronization between command buffers executing on different hardware queues...">CommandSyncMask</a> class to generate a mask using existing command buffers.</td></tr>
  </table>
  </dd>
</dl>
<p>This mask is only relevant if your command buffers are executing on different hardware queues, and are somehow dependant. If they are executing on the same queue (default) then they will execute sequentially in the order they are submitted. Otherwise, if there is a dependency, you must make state it explicitly here.</p>
<dl class="section note"><dt>Note</dt><dd>Core thread only. </dd></dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a86bdd357983b845df4c0a070ed47669b">RenderAPI</a>.</p>

</div>
</div>
<a id="a45aa4fc19ef23ccacb2ad0de3b7d449e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45aa4fc19ef23ccacb2ad0de3b7d449e">&#9670;&nbsp;</a></span>swapBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swapBuffers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_target.html">RenderTarget</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>syncMask</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the front and back buffer of the specified render target. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Render target to perform the buffer swap on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">syncMask</td><td>Optional synchronization mask that determines for which queues should the system wait before performing the swap buffer operation. By default the system waits for all queues. However if certain queues are performing non-rendering operations, or operations not related to the provided render target, you can exclude them from the sync mask for potentially better performance. You can use <a class="el" href="classbs_1_1ct_1_1_command_sync_mask.html" title="Mask that determines synchronization between command buffers executing on different hardware queues...">CommandSyncMask</a> to generate a valid sync mask. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a0d047892af237e2bc3c3d0a73e2bb888">RenderAPI</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
