<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - Script objects</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='http://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="../SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="../SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Script objects </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#scriptObjects_a">Native interop class</a><ul><li class="level2"><a href="#scriptObjects_a_a">Creating script object instances</a></li>
<li class="level2"><a href="#scripting_a_b">Destroying script object instances</a></li>
</ul>
</li>
<li class="level1"><a href="#scripting_b">Managed wrapper object</a></li>
<li class="level1"><a href="#scripting_c">Assembly refresh</a></li>
<li class="level1"><a href="#scripting_d">Deriving from ScriptObject</a></li>
</ul>
</div>
<div class="textblock"><p>What we have shown in the previous manual is enough to expose an object to C# and communicate with it. However bs::f provides another API built on top of that functionality in the form of script objects. This API handles some of the boilerplate code required for exposing an object to C#, provides a common interface all script objects need to implement, handles assembly refresh (due to script hot-swap) and gracefully handles managed object lifetime and destruction.</p>
<p>To implement the script object interface for a particular type you need two classes:</p><ul>
<li>A native interop class (C++)</li>
<li>Managed wrapper class for the type (C#)</li>
</ul>
<h1><a class="anchor" id="scriptObjects_a"></a>
Native interop class</h1>
<p>This class is intended as a wrapper for the C++ class you're exposing to the scripting API. It will contain all the code needed for C++/C# interop. All such native interop objects must implement the ScriptObject&lt;T&gt; interface. The template parameter should be the type of the interop class itself. The implementation of the class must begin with SCRIPT_OBJ macro. The macro accepts (in order):</p><ul>
<li>the name of the assembly (.dll) the managed wrapper class is in, this is usually <code>ENGINE_ASSEMBLY</code> or <code>EDITOR_ASSEMBLY</code></li>
<li>the namespace the managed wrapper class</li>
<li>the name of the managed wrapper class</li>
</ul>
<p><b>ScriptObject</b> constructor accepts a <b>MonoObject</b> which must contain the managed instance of the object and should be provided when the script object is created. If a script object is wrapping a static class, then the constructor is of no relevance as the script object will never be constructed (but still needs to be present).</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ScriptMyObject : <span class="keyword">public</span> ScriptObject &lt;ScriptMyObject&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    SCRIPT_OBJ(ENGINE_ASSEMBLY, <span class="stringliteral">&quot;BansheeEngine&quot;</span>, <span class="stringliteral">&quot;MyObject&quot;</span>)</div><div class="line"></div><div class="line">    ScriptMyObject(MonoObject* instance)</div><div class="line">        :ScriptObject(instance)</div><div class="line">    { }</div><div class="line">};</div></div><!-- fragment --><p><b>SCRIPT_OBJ</b> macro defines a static <b>initRuntimeData()</b> method you need to implement. In this method you want to take care of hooking up managed internal methods to C++ functions. It gets called automatically on startup and whenever the assembly containing the related managed class is loaded.</p>
<p>Every <b>ScriptObject</b> provides a static metaData structure you can use for retrieving the <b>MonoClass</b> of the related managed class. You can use that <b>MonoClass</b> to register internal methods to it (as described earlier). </p><div class="fragment"><div class="line"><span class="keyword">class </span>ScriptMyObject : <span class="keyword">public</span> ScriptObject &lt;ScriptMyObject&gt;</div><div class="line">{</div><div class="line">    <span class="comment">// Other code ...</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> internal_CreateInstance(MonoObject* obj);</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">float</span> internal_GetSomeValue(MonoObject* obj);</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> internal_SetSomeObject(MonoObject* obj);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ScriptMyObject::initRuntimeData()</div><div class="line">{</div><div class="line">    metaData.scriptClass-&gt;addInternalCall(<span class="stringliteral">&quot;Internal_CreateInstance&quot;</span>, &amp;ScriptMyObject::internal_CreateInstance);</div><div class="line">    metaData.scriptClass-&gt;addInternalCall(<span class="stringliteral">&quot;Internal_GetSomeValue&quot;</span>, &amp;ScriptMyObject::internal_GetSomeValue);</div><div class="line">    metaData.scriptClass-&gt;addInternalCall(<span class="stringliteral">&quot;Internal_SetSomeObject&quot;</span>, &amp;ScriptMyObject::internal_SetSomeObject);</div><div class="line">}</div></div><!-- fragment --><p><b>initRuntimeData()</b> is also a good spot to retrieve <b>MonoMethod</b>s (or thunks) for managed methods that needed to be called by the script interop object, if any.</p>
<h2><a class="anchor" id="scriptObjects_a_a"></a>
Creating script object instances</h2>
<p>If your class is not static you will need to eventually create an instance of the script object. This can be done either from C# or C++, depending on what is needed. For example script interop objects for GUI will be created from managed code because user can add GUI elements himself, but a resource like <b>Font</b> will have its script interop object (and managed instance) created purely from C++ because such an object cannot be created directly in managed code.</p>
<p>For the first case you should set up an internal method that accepts the managed object instance, and is called in the managed constructor. This way the method gets called whenever the managed object gets created and you can create the related script interop object. </p><div class="fragment"><div class="line"><span class="comment">// This method should be called from the managed object&#39;s constructor, with &quot;this&quot; object as the parameter</span></div><div class="line"><span class="keywordtype">void</span> ScriptMyObject::internal_CreateInstance(MonoObject* obj)</div><div class="line">{</div><div class="line">    <span class="comment">// No need to store the created value anywhere, the system will clean it up automatically when the managed object is destroyed</span></div><div class="line">    bs_new&lt;ScriptMyObject&gt;(obj);</div><div class="line">}</div></div><!-- fragment --><p>For the second case where you want to create the interop object from C++ you can create a static <em>create()</em> method like so: </p><div class="fragment"><div class="line">MonoObject* ScriptMyObject::create()</div><div class="line">{</div><div class="line">    MonoObject* managedObj = metaData.scriptClass-&gt;createInstance();</div><div class="line">    bs_new&lt;ScriptMyObject&gt;(managedObj);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> managedObj;</div><div class="line">}</div></div><!-- fragment --><p>If you ever receive a <b>MonoObject</b> of the type you know that has a <b>ScriptObject</b> implemented, you can retrieve it by calling ScriptObject::toNative(MonoObject*) static method. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> ScriptMyObject::internal_SetSomeObject(MonoObject* obj)</div><div class="line">{</div><div class="line">    ScriptSomeObject* someObj = ScriptSomeObject::toNative(obj);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="scripting_a_b"></a>
Destroying script object instances</h2>
<p>When the managed object is destroyed (e.g. goes out of scope and gets garbage collected) the system will automatically take care of freeing the related <b>ScriptObject</b>. If you need to add onto or replace that functionality you can override ScriptObject::_onManagedInstanceDeleted() method. This is useful if you need to perform some additional cleanup.</p>
<h1><a class="anchor" id="scripting_b"></a>
Managed wrapper object</h1>
<p>Creating the script interop class is one half of the job done. You also need to create the managed counterpart, however that is significantly simpler.</p>
<p>Every managed script object must implement the <b>ScriptObject</b> interface. For example a C# version of the class we're using in this example would look like: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>BansheeEngine</div><div class="line">{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">class </span>MyObject : ScriptObject</div><div class="line">    {</div><div class="line">        <span class="keyword">public</span> MyObject()</div><div class="line">        {</div><div class="line">            Internal_CreateInstance(<span class="keyword">this</span>)</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keywordtype">float</span> SomeValue</div><div class="line">        {</div><div class="line">            <span class="keyword">get</span> { <span class="keywordflow">return</span> Internal_GetSomeValue(<span class="keyword">this</span>); }</div><div class="line">        }</div><div class="line"></div><div class="line">        [MethodImpl(MethodImplOptions.InternalCall)]</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keywordtype">void</span> Internal_CreateInstance(MyObject obj);</div><div class="line"></div><div class="line">        [MethodImpl(MethodImplOptions.InternalCall)]</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keywordtype">float</span> Internal_GetSomeValue(MyObject obj);</div><div class="line"></div><div class="line">        [MethodImpl(MethodImplOptions.InternalCall)]</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keywordtype">void</span> internal_SetSomeObject(SomeObject obj);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>That's all that needs to be done. You can now create the object in C# and use its property to retrieve the value from C++ code.</p>
<p>All managed <b>ScriptObject</b>s provide a <b>ScriptObject::GetCachedPtr()</b> method which returns an <b>IntPtr</b> which points to the script interop object described in previous sections. This can be used for passing a reference to the <b>ScriptObject</b> directly, rather than passing a <b>MonoObject</b> which then needs to be converted to <b>ScriptObject</b>.</p>
<p>For example, if we change the <em>Internal_GetSomeValue()</em> method in the example above to use this approach, it would look like so: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>BansheeEngine</div><div class="line">{</div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">float</span> SomeValue</div><div class="line">    {</div><div class="line">        <span class="keyword">get</span> { <span class="keywordflow">return</span> Internal_GetSomeValue(GetCachedPtr()); }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">class </span>MyObject : ScriptObject</div><div class="line">    {</div><div class="line">        [MethodImpl(MethodImplOptions.InternalCall)]</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keywordtype">float</span> Internal_GetSomeValue(IntPtr obj);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>And the corresponding C++ function would then accept the script object directly: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> ScriptMyObject::internal_GetSomeValue(ScriptMyObject* obj)</div><div class="line">{</div><div class="line">    <span class="comment">// No need to convert from MonoObject to ScriptMyObject</span></div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="scripting_c"></a>
Assembly refresh</h1>
<p>Assembly refresh is the process that happens when managed code is recompiled and scripts need to be reloaded. This is primarily used in Banshee 3D editor to hot-reload the scripts while the editor is still running. When assembly refresh happens all managed objects are effectively destroyed.</p>
<p>By default any script objects of such managed objects are destroyed as well. In many cases this is okay, for example GUI elements don't persist refresh, because they're just rebuilt from the managed code every time the refresh happens. However objects like resources, scene objects and components are persistent - we don't wish to reload the entire scene and all resources every time assembly refresh happens.</p>
<p>In order to make your script objects persist through refresh you need to inherit from a variation of <b>ScriptObject</b> that as its second template parameter takes a PersistentScriptObjectBase.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyScriptObject : <span class="keyword">public</span> ScriptObject&lt;MyScriptObject, PersistentScriptObjectBase&gt;</div><div class="line">{</div><div class="line">    ...</div><div class="line">};</div></div><!-- fragment --><p>This ensures that your object is treated properly during assembly refresh. Persistent object then needs to handle four different actions, represented by overrideable methods. These methods are called in order specified, during assembly refresh.</p><ul>
<li>ScriptObject::beginRefresh() - Called just before the refresh starts. The object is still alive here and you can use this time to save the contents of the managed object before it is destroyed.</li>
<li>ScriptObject::_onManagedInstanceDeleted() - Called after assembly unload happened and the managed object was destroyed. You should override this to prevent the <b>ScriptObject</b> itself from being deleted if the assembly refresh is in progress. If assembly refresh is not in progress this method should delete the <b>ScriptObject</b> as it likely got called due to standard reasons (managed object went out of scope).</li>
<li>ScriptObject::_createManagedInstance() - Creates the managed instance after new assemblies are loaded. You should override this if your managed class is constructed using a constructor with parameters. By default this will call <b>MonoClass::createInstance()</b> using the parameterless constructor.</li>
<li>ScriptObject::endRefresh() - Called after all assemblies are loaded, and after all script interop objects were either destroyed (non-persistent) or had their managed instances re-created (persistent). If you stored any data during <b>ScriptObject::beginRefresh()</b>, you should restore it here.</li>
</ul>
<h1><a class="anchor" id="scripting_d"></a>
Deriving from ScriptObject</h1>
<p>Sometimes script objects are polymorphic. For example a <b>GUIElement</b> is derived from <b>ScriptObject</b> in managed code, and <b>GUIButton</b> is derived from <b>GUIElement</b>, however they both have script interop objects of their own.</p>
<p>Due to the nature of how our script interop objects are defined we cannot follow the same simple chain of inheritance in C++ code. For example class definition for script interop object for <b>GUIElement</b> would be: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ScriptGUIElement : <span class="keyword">public</span> ScriptObject&lt;ScriptGUIElement&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    SCRIPT_OBJ(ENGINE_ASSEMBLY, <span class="stringliteral">&quot;BansheeEngine&quot;</span>, <span class="stringliteral">&quot;GUIElement&quot;</span>)</div><div class="line">...</div><div class="line">}</div></div><!-- fragment --><p>But what would it be for <b>GUIButton</b>? It also needs to implement <b>ScriptObject</b> with its own <b>SCRIPT_OBJ</b> macro so we cannot just inherit from <b>ScriptGUIElement</b> directly as it would clash.</p>
<p>The solution is to create a third class that will serve as a base for both. This third class will be a base class for <b>ScriptObject</b> (its second template parameter allows us to override its default <b>ScriptObjectBase</b> base class). The third class will need to inherit ScriptObjectBase and can implement any functionality common to all GUI elements (e.g. it might store a pointer to a native <b>GUIElement</b>).</p>
<p>Provided our common base class is defined as such: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ScriptGUIElementBase : <span class="keyword">public</span> ScriptObjectBase</div><div class="line">{</div><div class="line">    <span class="comment">// Functionality common to all GUI elements</span></div><div class="line">};</div></div><!-- fragment --><p>Then we can define script interop object for <b>GUIElement</b> as: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ScriptGUIElement : <span class="keyword">public</span> ScriptObject&lt;ScriptGUIElement, ScriptGUIElementBase&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    SCRIPT_OBJ(ENGINE_ASSEMBLY, <span class="stringliteral">&quot;BansheeEngine&quot;</span>, <span class="stringliteral">&quot;GUIElement&quot;</span>)</div><div class="line">...</div><div class="line">};</div></div><!-- fragment --><p>And interop object for <b>GUIButton</b> would then be: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ScriptGUIButton : <span class="keyword">public</span> ScriptObject&lt;ScriptGUIButton, ScriptGUIElementBase&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    SCRIPT_OBJ(ENGINE_ASSEMBLY, <span class="stringliteral">&quot;BansheeEngine&quot;</span>, <span class="stringliteral">&quot;GUIButton&quot;</span>)</div><div class="line">...</div><div class="line">};</div></div><!-- fragment --><p>This ensures that all GUI elements can now be accessed through the common <b>ScriptGUIElementBase</b> interface. Which is important if <b>GUIElement</b> provides some internal method calls shared between all GUI element types, otherwise we wouldn't know what to cast the interop object held by its managed object to. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
