<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - CoreObject Class Reference</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='http://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="../SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="../SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebs.html">bs</a></li><li class="navelem"><a class="el" href="classbs_1_1_core_object.html">CoreObject</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Methods</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="classbs_1_1_core_object-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CoreObject Class Reference<div class="ingroups"><a class="el" href="group___layers.html">Layers</a> &raquo; <a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___core_thread.html">Core thread</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Core objects provides functionality for dealing with objects that need to exist on both simulation and core thread. </p>
<p>It handles cross-thread initialization, destruction as well as syncing data between the two threads.</p>
<p>It also provides a standardized way to initialize/destroy objects, and a way to specify dependant <a class="el" href="classbs_1_1_core_object.html" title="Core objects provides functionality for dealing with objects that need to exist on both simulation an...">CoreObject</a>s. For those purposes it might also be used for objects that only exist on the core thread.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classbs_1_1ct_1_1_core_object.html" title="Represents counterpart of a CoreObject that is meant to be used specifically on the core thread...">ct::CoreObject</a> is a counterpart to <a class="el" href="classbs_1_1_core_object.html" title="Core objects provides functionality for dealing with objects that need to exist on both simulation an...">CoreObject</a> that is used exclusively on the core thread. <a class="el" href="classbs_1_1_core_object.html" title="Core objects provides functionality for dealing with objects that need to exist on both simulation an...">CoreObject</a> on the other hand should be used exclusively on the simulation thread. Types that exist on both threads need to implement both of these. </dd></dl>
</div>
<p>Inherited by <a class="el" href="classbs_1_1_animation.html">Animation</a>, <a class="el" href="classbs_1_1_blend_state.html">BlendState</a>, <a class="el" href="classbs_1_1_camera.html">Camera</a>, <a class="el" href="classbs_1_1_compute_pipeline_state.html">ComputePipelineState</a>, <a class="el" href="classbs_1_1_depth_stencil_state.html">DepthStencilState</a>, <a class="el" href="classbs_1_1_gpu_buffer.html">GpuBuffer</a>, <a class="el" href="classbs_1_1_gpu_param_block_buffer.html">GpuParamBlockBuffer</a>, <a class="el" href="classbs_1_1_gpu_params.html">GpuParams</a>, <a class="el" href="classbs_1_1_gpu_pipeline_param_info.html">GpuPipelineParamInfo</a>, <a class="el" href="classbs_1_1_gpu_program.html">GpuProgram</a>, <a class="el" href="classbs_1_1_graphics_pipeline_state.html">GraphicsPipelineState</a>, <a class="el" href="classbs_1_1_index_buffer.html">IndexBuffer</a>, <a class="el" href="classbs_1_1_light.html">Light</a>, <a class="el" href="classbs_1_1_light_probe_volume.html">LightProbeVolume</a>, <a class="el" href="classbs_1_1_mesh_heap.html">MeshHeap</a>, <a class="el" href="classbs_1_1_pass.html">Pass</a>, <a class="el" href="classbs_1_1_rasterizer_state.html">RasterizerState</a>, <a class="el" href="classbs_1_1_reflection_probe.html">ReflectionProbe</a>, <a class="el" href="classbs_1_1_renderable.html">Renderable</a>, <a class="el" href="classbs_1_1_render_target.html">RenderTarget</a>, <a class="el" href="classbs_1_1_resource.html">Resource</a>, <a class="el" href="classbs_1_1_sampler_state.html">SamplerState</a>, <a class="el" href="classbs_1_1_skybox.html">Skybox</a>, <a class="el" href="classbs_1_1_technique.html">Technique</a>, <a class="el" href="classbs_1_1_vertex_buffer.html">VertexBuffer</a>, <a class="el" href="classbs_1_1_vertex_declaration.html">VertexDeclaration</a>, and <a class="el" href="classbs_1_1_viewport.html">Viewport</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Internal</h2></td></tr>
<tr class="memitem:a88eb1662d24feef6cf3c96fcbc280d2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_core_object.html#a88eb1662d24feef6cf3c96fcbc280d2d">_setThisPtr</a> (<a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_core_object.html">CoreObject</a> &gt; ptrThis)</td></tr>
<tr class="memdesc:a88eb1662d24feef6cf3c96fcbc280d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a shared this pointer to this object.  <a href="#a88eb1662d24feef6cf3c96fcbc280d2d">More...</a><br /></td></tr>
<tr class="separator:a88eb1662d24feef6cf3c96fcbc280d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5325d0c57f8c0964461b3432e0153f"><td class="memTemplParams" colspan="2">template&lt;class T , class MemAlloc &gt; </td></tr>
<tr class="memitem:abd5325d0c57f8c0964461b3432e0153f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbs_1_1_core_object.html#abd5325d0c57f8c0964461b3432e0153f">_delete</a> (<a class="el" href="classbs_1_1_core_object.html">CoreObject</a> *obj)</td></tr>
<tr class="memdesc:abd5325d0c57f8c0964461b3432e0153f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules the object to be destroyed, and then deleted.  <a href="#abd5325d0c57f8c0964461b3432e0153f">More...</a><br /></td></tr>
<tr class="separator:abd5325d0c57f8c0964461b3432e0153f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Methods</h2></td></tr>
<tr class="memitem:aed2d208f4d304cc6def0a15b73f115bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_core_object.html#aed2d208f4d304cc6def0a15b73f115bf">destroy</a> ()</td></tr>
<tr class="memdesc:aed2d208f4d304cc6def0a15b73f115bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all the data held by this object.  <a href="#aed2d208f4d304cc6def0a15b73f115bf">More...</a><br /></td></tr>
<tr class="separator:aed2d208f4d304cc6def0a15b73f115bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6365dca5a7d8ddb694726a53b55a4c27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_core_object.html#a6365dca5a7d8ddb694726a53b55a4c27">initialize</a> ()</td></tr>
<tr class="memdesc:a6365dca5a7d8ddb694726a53b55a4c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes all the internal resources of this object.  <a href="#a6365dca5a7d8ddb694726a53b55a4c27">More...</a><br /></td></tr>
<tr class="separator:a6365dca5a7d8ddb694726a53b55a4c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161d75a220f87c68d6975112f0bff3f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_core_object.html#a161d75a220f87c68d6975112f0bff3f6">isInitialized</a> () const</td></tr>
<tr class="memdesc:a161d75a220f87c68d6975112f0bff3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the object has been initialized.  <a href="#a161d75a220f87c68d6975112f0bff3f6">More...</a><br /></td></tr>
<tr class="separator:a161d75a220f87c68d6975112f0bff3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cc529e41789e4d82596a170f6238b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_core_object.html#a24cc529e41789e4d82596a170f6238b4">isDestroyed</a> () const</td></tr>
<tr class="memdesc:a24cc529e41789e4d82596a170f6238b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the object has been destroyed.  <a href="#a24cc529e41789e4d82596a170f6238b4">More...</a><br /></td></tr>
<tr class="separator:a24cc529e41789e4d82596a170f6238b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4ce196b1df089d67cbcca776bb1e94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_core_object.html#adb4ce196b1df089d67cbcca776bb1e94">blockUntilCoreInitialized</a> () const</td></tr>
<tr class="memdesc:adb4ce196b1df089d67cbcca776bb1e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the current thread until the resource is fully initialized.  <a href="#adb4ce196b1df089d67cbcca776bb1e94">More...</a><br /></td></tr>
<tr class="separator:adb4ce196b1df089d67cbcca776bb1e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc719cf461ac359962da39366cbd75bf"><td class="memItemLeft" align="right" valign="top">UINT64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_core_object.html#abc719cf461ac359962da39366cbd75bf">getInternalID</a> () const</td></tr>
<tr class="memdesc:abc719cf461ac359962da39366cbd75bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an unique identifier for this object.  <a href="#abc719cf461ac359962da39366cbd75bf">More...</a><br /></td></tr>
<tr class="separator:abc719cf461ac359962da39366cbd75bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc5fbc235a8ccc43a3d603faaa62e1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_core_object.html">CoreObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_core_object.html#adfc5fbc235a8ccc43a3d603faaa62e1b">getThisPtr</a> () const</td></tr>
<tr class="memdesc:adfc5fbc235a8ccc43a3d603faaa62e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared_ptr version of "this" pointer.  <a href="#adfc5fbc235a8ccc43a3d603faaa62e1b">More...</a><br /></td></tr>
<tr class="separator:adfc5fbc235a8ccc43a3d603faaa62e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608f8b18e4310fab6879d2c43d6ad8e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_core_object.html">ct::CoreObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_core_object.html#a608f8b18e4310fab6879d2c43d6ad8e2">getCore</a> () const</td></tr>
<tr class="memdesc:a608f8b18e4310fab6879d2c43d6ad8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that contains a core thread specific implementation of this <a class="el" href="classbs_1_1_core_object.html" title="Core objects provides functionality for dealing with objects that need to exist on both simulation an...">CoreObject</a>.  <a href="#a608f8b18e4310fab6879d2c43d6ad8e2">More...</a><br /></td></tr>
<tr class="separator:a608f8b18e4310fab6879d2c43d6ad8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fab2b59659e39f92ea6b87eec00ca9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_core_object.html#ae5fab2b59659e39f92ea6b87eec00ca9">syncToCore</a> ()</td></tr>
<tr class="memdesc:ae5fab2b59659e39f92ea6b87eec00ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures all dirty syncable data is send to the core thread counterpart of this object (if any).  <a href="#ae5fab2b59659e39f92ea6b87eec00ca9">More...</a><br /></td></tr>
<tr class="separator:ae5fab2b59659e39f92ea6b87eec00ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:aa705cf7e79a21c2352b00ffe20cd295f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_core_object.html#aa705cf7e79a21c2352b00ffe20cd295f">Flags</a> { <a class="el" href="classbs_1_1_core_object.html#aa705cf7e79a21c2352b00ffe20cd295fac2eca33fdc92ae56061c02de45c656ce">CGO_DESTROYED</a> = 0x01, 
<a class="el" href="classbs_1_1_core_object.html#aa705cf7e79a21c2352b00ffe20cd295fa5c5ab6970a45269c82397675b81ed476">CGO_INIT_ON_CORE_THREAD</a> = 0x02, 
<a class="el" href="classbs_1_1_core_object.html#aa705cf7e79a21c2352b00ffe20cd295faafc1f64d5c0cd3dc18182fc947e59d0a">CGO_INITIALIZED</a> = 0x04
 }</td></tr>
<tr class="memdesc:aa705cf7e79a21c2352b00ffe20cd295f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values that represent current state of the core object.  <a href="classbs_1_1_core_object.html#aa705cf7e79a21c2352b00ffe20cd295f">More...</a><br /></td></tr>
<tr class="separator:aa705cf7e79a21c2352b00ffe20cd295f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Method documentation</h2>
<a id="abd5325d0c57f8c0964461b3432e0153f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5325d0c57f8c0964461b3432e0153f">&#9670;&nbsp;</a></span>_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void _delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbs_1_1_core_object.html">CoreObject</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedules the object to be destroyed, and then deleted. </p>

</div>
</div>
<a id="a88eb1662d24feef6cf3c96fcbc280d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88eb1662d24feef6cf3c96fcbc280d2d">&#9670;&nbsp;</a></span>_setThisPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _setThisPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_core_object.html">CoreObject</a> &gt;&#160;</td>
          <td class="paramname"><em>ptrThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a shared this pointer to this object. </p>
<p>This must be called immediately after construction, but before <a class="el" href="classbs_1_1_core_object.html#a6365dca5a7d8ddb694726a53b55a4c27" title="Initializes all the internal resources of this object. ">initialize()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This should be called by the factory creation methods so user doesn't have to call it manually. </dd></dl>

</div>
</div>
<a id="adb4ce196b1df089d67cbcca776bb1e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4ce196b1df089d67cbcca776bb1e94">&#9670;&nbsp;</a></span>blockUntilCoreInitialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blockUntilCoreInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the current thread until the resource is fully initialized. </p>
<dl class="section note"><dt>Note</dt><dd><br />
If you call this without calling initialize first a deadlock will occur. You should not call this from core thread. </dd></dl>

</div>
</div>
<a id="a13e6e4b42edbb7b4d94726aafb7f09cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e6e4b42edbb7b4d94726aafb7f09cd">&#9670;&nbsp;</a></span>createCore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1ct_1_1_core_object.html">ct::CoreObject</a>&gt; createCore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an object that contains core thread specific data and methods for this <a class="el" href="classbs_1_1_core_object.html" title="Core objects provides functionality for dealing with objects that need to exist on both simulation an...">CoreObject</a>. </p>
<p>Can be null if such object is not required. </p>

<p>Reimplemented in <a class="el" href="classbs_1_1_camera.html#ac221909347bb971a2653ad1138729ef8">Camera</a>, <a class="el" href="classbs_1_1_gpu_params.html#ac221909347bb971a2653ad1138729ef8">GpuParams</a>, <a class="el" href="classbs_1_1_texture.html#ac221909347bb971a2653ad1138729ef8">Texture</a>, <a class="el" href="classbs_1_1_compute_pipeline_state.html#a13e6e4b42edbb7b4d94726aafb7f09cd">ComputePipelineState</a>, <a class="el" href="classbs_1_1_light.html#ac221909347bb971a2653ad1138729ef8">Light</a>, <a class="el" href="classbs_1_1_vertex_declaration.html#ac221909347bb971a2653ad1138729ef8">VertexDeclaration</a>, <a class="el" href="classbs_1_1_light_probe_volume.html#ac221909347bb971a2653ad1138729ef8">LightProbeVolume</a>, <a class="el" href="classbs_1_1_graphics_pipeline_state.html#a13e6e4b42edbb7b4d94726aafb7f09cd">GraphicsPipelineState</a>, <a class="el" href="classbs_1_1_blend_state.html#ac221909347bb971a2653ad1138729ef8">BlendState</a>, <a class="el" href="classbs_1_1_depth_stencil_state.html#ac221909347bb971a2653ad1138729ef8">DepthStencilState</a>, <a class="el" href="classbs_1_1_renderable.html#ac221909347bb971a2653ad1138729ef8">Renderable</a>, <a class="el" href="classbs_1_1_pass.html#ac221909347bb971a2653ad1138729ef8">Pass</a>, <a class="el" href="classbs_1_1_viewport.html#ac221909347bb971a2653ad1138729ef8">Viewport</a>, <a class="el" href="classbs_1_1_sampler_state.html#ac221909347bb971a2653ad1138729ef8">SamplerState</a>, <a class="el" href="classbs_1_1_reflection_probe.html#ac221909347bb971a2653ad1138729ef8">ReflectionProbe</a>, <a class="el" href="classbs_1_1_rasterizer_state.html#ac221909347bb971a2653ad1138729ef8">RasterizerState</a>, <a class="el" href="classbs_1_1_mesh.html#ac221909347bb971a2653ad1138729ef8">Mesh</a>, <a class="el" href="classbs_1_1_technique.html#ac221909347bb971a2653ad1138729ef8">Technique</a>, <a class="el" href="classbs_1_1_gpu_buffer.html#ac221909347bb971a2653ad1138729ef8">GpuBuffer</a>, <a class="el" href="classbs_1_1_mac_o_s_render_window.html#a67e86c88b8c6f3e2cc64ec2c411e7a8d">MacOSRenderWindow</a>, <a class="el" href="classbs_1_1_gpu_program.html#ac221909347bb971a2653ad1138729ef8">GpuProgram</a>, <a class="el" href="classbs_1_1_render_texture.html#ac221909347bb971a2653ad1138729ef8">RenderTexture</a>, <a class="el" href="classbs_1_1_skybox.html#ac221909347bb971a2653ad1138729ef8">Skybox</a>, <a class="el" href="classbs_1_1_index_buffer.html#a13e6e4b42edbb7b4d94726aafb7f09cd">IndexBuffer</a>, <a class="el" href="classbs_1_1_vertex_buffer.html#a13e6e4b42edbb7b4d94726aafb7f09cd">VertexBuffer</a>, <a class="el" href="classbs_1_1_gpu_param_block_buffer.html#ac221909347bb971a2653ad1138729ef8">GpuParamBlockBuffer</a>, <a class="el" href="classbs_1_1_linux_render_window.html#ac221909347bb971a2653ad1138729ef8">LinuxRenderWindow</a>, <a class="el" href="classbs_1_1_linux_render_window.html#ac221909347bb971a2653ad1138729ef8">LinuxRenderWindow</a>, <a class="el" href="classbs_1_1_win32_render_window.html#ac221909347bb971a2653ad1138729ef8">Win32RenderWindow</a>, <a class="el" href="classbs_1_1_win32_render_window.html#ac221909347bb971a2653ad1138729ef8">Win32RenderWindow</a>, <a class="el" href="group___d3_d11.html#gac221909347bb971a2653ad1138729ef8">D3D11RenderWindow</a>, and <a class="el" href="classbs_1_1_transient_mesh.html#ac221909347bb971a2653ad1138729ef8">TransientMesh</a>.</p>

</div>
</div>
<a id="aed2d208f4d304cc6def0a15b73f115bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2d208f4d304cc6def0a15b73f115bf">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees all the data held by this object. </p>
<dl class="section note"><dt>Note</dt><dd><br />
If this object require initialization on core thread destruction is not done immediately, and is instead just scheduled on the core thread. Otherwise the object is destroyed immediately. </dd></dl>

<p>Reimplemented in <a class="el" href="classbs_1_1_camera.html#ae1cf30cae681d95a94934492ae7ea627">Camera</a>, <a class="el" href="classbs_1_1_render_window.html#ae1cf30cae681d95a94934492ae7ea627">RenderWindow</a>, and <a class="el" href="classbs_1_1_mac_o_s_render_window.html#ae1cf30cae681d95a94934492ae7ea627">MacOSRenderWindow</a>.</p>

</div>
</div>
<a id="a608f8b18e4310fab6879d2c43d6ad8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608f8b18e4310fab6879d2c43d6ad8e2">&#9670;&nbsp;</a></span>getCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1ct_1_1_core_object.html">ct::CoreObject</a>&gt; getCore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an object that contains a core thread specific implementation of this <a class="el" href="classbs_1_1_core_object.html" title="Core objects provides functionality for dealing with objects that need to exist on both simulation an...">CoreObject</a>. </p>
<p>Null is a valid return value in case object requires no core thread implementation.</p>
<dl class="section note"><dt>Note</dt><dd>Thread safe to retrieve, but its data is only valid on the core thread. </dd></dl>

</div>
</div>
<a id="a1da0d98e4d8064ae00f7da2b61ee0574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da0d98e4d8064ae00f7da2b61ee0574">&#9670;&nbsp;</a></span>getCoreDependencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void getCoreDependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="classbs_1_1_core_object.html">CoreObject</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dependencies</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populates the provided array with all core objects that this core object depends upon. </p>
<p>Dependencies are required for syncing to the core thread, so the system can be aware to update the dependant objects if a dependency is marked as dirty (for example updating a camera's viewport should also trigger an update on camera so it has a chance to potentially update its data). </p>

<p>Reimplemented in <a class="el" href="classbs_1_1_camera.html#aefe5c2c9e65da433b5a6f66eed932569">Camera</a>, <a class="el" href="classbs_1_1_renderable.html#aefe5c2c9e65da433b5a6f66eed932569">Renderable</a>, <a class="el" href="classbs_1_1_viewport.html#aefe5c2c9e65da433b5a6f66eed932569">Viewport</a>, <a class="el" href="classbs_1_1_technique.html#aefe5c2c9e65da433b5a6f66eed932569">Technique</a>, and <a class="el" href="classbs_1_1_font.html#aefe5c2c9e65da433b5a6f66eed932569">Font</a>.</p>

</div>
</div>
<a id="abc719cf461ac359962da39366cbd75bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc719cf461ac359962da39366cbd75bf">&#9670;&nbsp;</a></span>getInternalID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT64 getInternalID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an unique identifier for this object. </p>

</div>
</div>
<a id="adfc5fbc235a8ccc43a3d603faaa62e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc5fbc235a8ccc43a3d603faaa62e1b">&#9670;&nbsp;</a></span>getThisPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_core_object.html">CoreObject</a>&gt; getThisPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a shared_ptr version of "this" pointer. </p>

</div>
</div>
<a id="a6365dca5a7d8ddb694726a53b55a4c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6365dca5a7d8ddb694726a53b55a4c27">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes all the internal resources of this object. </p>
<p>Must be called right after construction. Generally you should call this from a factory method to avoid the issue where user forgets to call it.</p>
<dl class="section note"><dt>Note</dt><dd><br />
If this object require initialization on core thread initialization is not done immediately, and is instead just scheduled on the core thread. Otherwise the object is initialized immediately. </dd></dl>

<p>Reimplemented in <a class="el" href="classbs_1_1_material.html#a371caef26098f2a15df9fbee047b58f2">Material</a>, <a class="el" href="classbs_1_1_camera.html#a371caef26098f2a15df9fbee047b58f2">Camera</a>, <a class="el" href="classbs_1_1_texture.html#a371caef26098f2a15df9fbee047b58f2">Texture</a>, <a class="el" href="classbs_1_1_animation_clip.html#a371caef26098f2a15df9fbee047b58f2">AnimationClip</a>, <a class="el" href="classbs_1_1_renderable.html#a371caef26098f2a15df9fbee047b58f2">Renderable</a>, <a class="el" href="classbs_1_1_audio_clip.html#a371caef26098f2a15df9fbee047b58f2">AudioClip</a>, <a class="el" href="classbs_1_1_mac_o_s_render_window.html#a371caef26098f2a15df9fbee047b58f2">MacOSRenderWindow</a>, <a class="el" href="classbs_1_1_mesh.html#a371caef26098f2a15df9fbee047b58f2">Mesh</a>, <a class="el" href="classbs_1_1_physics_mesh.html#a371caef26098f2a15df9fbee047b58f2">PhysicsMesh</a>, <a class="el" href="classbs_1_1_f_m_o_d_audio_clip.html#a371caef26098f2a15df9fbee047b58f2">FMODAudioClip</a>, and <a class="el" href="classbs_1_1_o_a_audio_clip.html#a371caef26098f2a15df9fbee047b58f2">OAAudioClip</a>.</p>

</div>
</div>
<a id="a51489d9eba7cad0dfa8bb97c42bf7dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51489d9eba7cad0dfa8bb97c42bf7dd4">&#9670;&nbsp;</a></span>isCoreDirty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isCoreDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks is the core dirty flag set. </p>
<p>This is used by external systems to know when internal data has changed and core thread potentially needs to be notified. </p>

</div>
</div>
<a id="a24cc529e41789e4d82596a170f6238b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cc529e41789e4d82596a170f6238b4">&#9670;&nbsp;</a></span>isDestroyed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isDestroyed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the object has been destroyed. </p>
<p>Destroyed object should not be used. </p>

</div>
</div>
<a id="a161d75a220f87c68d6975112f0bff3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161d75a220f87c68d6975112f0bff3f6">&#9670;&nbsp;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the object has been initialized. </p>
<p>Non-initialized object should not be used. </p>

</div>
</div>
<a id="a12b763f1677c4dec9796dbcd72cb0c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b763f1677c4dec9796dbcd72cb0c7c">&#9670;&nbsp;</a></span>markCoreClean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void markCoreClean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the core data as clean. </p>
<p>Normally called right after <a class="el" href="classbs_1_1_core_object.html#ae5fab2b59659e39f92ea6b87eec00ca9" title="Ensures all dirty syncable data is send to the core thread counterpart of this object (if any)...">syncToCore()</a> has been called. </p>

</div>
</div>
<a id="aede3db47ff03f7f5e6b908b74df4f2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede3db47ff03f7f5e6b908b74df4f2c7">&#9670;&nbsp;</a></span>markCoreDirty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void markCoreDirty </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0xFFFFFFFF</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the core data as dirty. </p>
<p>This causes the <a class="el" href="classbs_1_1_core_object.html#ae5fab2b59659e39f92ea6b87eec00ca9" title="Ensures all dirty syncable data is send to the core thread counterpart of this object (if any)...">syncToCore()</a> method to trigger the next time objects are synced between core and sim threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>(optional) <a class="el" href="classbs_1_1_flags.html" title="Wrapper around an enum that allows simple use of bitwise logic operations. ">Flags</a> in case you want to signal that only part of the internal data is dirty. <a class="el" href="classbs_1_1_core_object.html#ae5fab2b59659e39f92ea6b87eec00ca9" title="Ensures all dirty syncable data is send to the core thread counterpart of this object (if any)...">syncToCore()</a> will be called regardless and it's up to the implementation to read the flags value if needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4687021eec4a1bad83dcdd953cd0145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4687021eec4a1bad83dcdd953cd0145">&#9670;&nbsp;</a></span>markDependenciesDirty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void markDependenciesDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the core object manager that this object is dependant on some other CoreObject(s), and the dependencies changed since the last call to this method. </p>
<p>This will trigger a call to <a class="el" href="classbs_1_1_core_object.html#a1da0d98e4d8064ae00f7da2b61ee0574" title="Populates the provided array with all core objects that this core object depends upon. ">getCoreDependencies()</a> to collect the new dependencies. </p>

</div>
</div>
<a id="a5c08eb329ca551603ccef1af2f924032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c08eb329ca551603ccef1af2f924032">&#9670;&nbsp;</a></span>queueGpuCommand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void queueGpuCommand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_core_object.html">ct::CoreObject</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a command to be executed on the core thread, without a return value. </p>
<dl class="section note"><dt>Note</dt><dd><br />
Requires a shared pointer to the object this function will be executed on, in order to make sure the object is not deleted before the command executes. Can be null if the function is static or global. </dd></dl>

</div>
</div>
<a id="a877da849b18b5419106f42ba476089d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877da849b18b5419106f42ba476089d2">&#9670;&nbsp;</a></span>queueReturnGpuCommand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbs_1_1_async_op.html">AsyncOp</a> queueReturnGpuCommand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_core_object.html">ct::CoreObject</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classbs_1_1_async_op.html">AsyncOp</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a command to be executed on the core thread, with a return value in the form of <a class="el" href="classbs_1_1_async_op.html" title="Object you may use to check on the results of an asynchronous operation. ">AsyncOp</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbs_1_1_async_op.html" title="Object you may use to check on the results of an asynchronous operation. ">AsyncOp</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd><br />
Requires a shared pointer to the object this function will be executed on, in order to make sure the object is not deleted before the command executes. Can be null if the function is static or global. </dd></dl>

</div>
</div>
<a id="ae5fab2b59659e39f92ea6b87eec00ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fab2b59659e39f92ea6b87eec00ca9">&#9670;&nbsp;</a></span>syncToCore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void syncToCore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures all dirty syncable data is send to the core thread counterpart of this object (if any). </p>
<dl class="section note"><dt>Note</dt><dd>Call this if you have modified the object and need to make sure core thread has an up to date version. Normally this is done automatically at the end of a frame. </dd>
<dd>
This is an <a class="el" href="async_method.html">asynchronous method</a>. </dd></dl>

</div>
</div>
<a id="a24f97046d00ba3347243ce4208884979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f97046d00ba3347243ce4208884979">&#9670;&nbsp;</a></span>syncToCore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbs_1_1_core_sync_data.html">CoreSyncData</a> syncToCore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbs_1_1_frame_alloc.html">FrameAlloc</a> *&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy internal dirty data to a memory buffer that will be used for updating core thread version of that data. </p>
<dl class="section note"><dt>Note</dt><dd><br />
This generally happens at the end of every sim thread frame. Synced data becomes available to the core thread the start of the next core thread frame. </dd></dl>

<p>Reimplemented in <a class="el" href="classbs_1_1_camera.html#af3aad7b28093358d7bbadee1d3b46de8">Camera</a>, <a class="el" href="classbs_1_1_gpu_params.html#af3aad7b28093358d7bbadee1d3b46de8">GpuParams</a>, <a class="el" href="classbs_1_1_light.html#af3aad7b28093358d7bbadee1d3b46de8">Light</a>, <a class="el" href="classbs_1_1_renderable.html#af3aad7b28093358d7bbadee1d3b46de8">Renderable</a>, <a class="el" href="classbs_1_1_light_probe_volume.html#af3aad7b28093358d7bbadee1d3b46de8">LightProbeVolume</a>, <a class="el" href="classbs_1_1_reflection_probe.html#af3aad7b28093358d7bbadee1d3b46de8">ReflectionProbe</a>, <a class="el" href="classbs_1_1_pass.html#af3aad7b28093358d7bbadee1d3b46de8">Pass</a>, <a class="el" href="classbs_1_1_viewport.html#af3aad7b28093358d7bbadee1d3b46de8">Viewport</a>, <a class="el" href="classbs_1_1_mesh_base.html#af3aad7b28093358d7bbadee1d3b46de8">MeshBase</a>, <a class="el" href="classbs_1_1_skybox.html#af3aad7b28093358d7bbadee1d3b46de8">Skybox</a>, <a class="el" href="classbs_1_1_render_texture.html#af3aad7b28093358d7bbadee1d3b46de8">RenderTexture</a>, and <a class="el" href="classbs_1_1_gpu_param_block_buffer.html#af3aad7b28093358d7bbadee1d3b46de8">GpuParamBlockBuffer</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa705cf7e79a21c2352b00ffe20cd295f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa705cf7e79a21c2352b00ffe20cd295f">&#9670;&nbsp;</a></span>Flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbs_1_1_core_object.html#aa705cf7e79a21c2352b00ffe20cd295f">Flags</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Values that represent current state of the core object. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa705cf7e79a21c2352b00ffe20cd295fac2eca33fdc92ae56061c02de45c656ce"></a>CGO_DESTROYED&#160;</td><td class="fielddoc"><p>Object has been destroyed and shouldn't be used. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa705cf7e79a21c2352b00ffe20cd295fa5c5ab6970a45269c82397675b81ed476"></a>CGO_INIT_ON_CORE_THREAD&#160;</td><td class="fielddoc"><p>Object requires initialization on core thread. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa705cf7e79a21c2352b00ffe20cd295faafc1f64d5c0cd3dc18182fc947e59d0a"></a>CGO_INITIALIZED&#160;</td><td class="fielddoc"><p>Object's <a class="el" href="classbs_1_1_core_object.html#a6365dca5a7d8ddb694726a53b55a4c27" title="Initializes all the internal resources of this object. ">initialize()</a> method has been called. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a74f934399a1deeb90fa1ede3d2630d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f934399a1deeb90fa1ede3d2630d3e">&#9670;&nbsp;</a></span>CoreObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbs_1_1_core_object.html">CoreObject</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requiresCoreInit</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new core object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">requiresCoreInit</td><td>(optional) Determines if the <a class="el" href="classbs_1_1ct_1_1_core_object.html" title="Represents counterpart of a CoreObject that is meant to be used specifically on the core thread...">ct::CoreObject</a> counterpart of this object (if it has any, see <a class="el" href="classbs_1_1_core_object.html#a13e6e4b42edbb7b4d94726aafb7f09cd" title="Creates an object that contains core thread specific data and methods for this CoreObject. ">createCore()</a>) requires initialization and destruction on the core thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
