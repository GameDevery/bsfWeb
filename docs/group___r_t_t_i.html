<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - RTTI</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='https://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">RTTI<div class="ingroups"><a class="el" href="group___layers.html">Layers</a> &raquo; <a class="el" href="group___utility.html">Utility</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Run-time type information defining and querying. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbs_1_1_r_t_t_i_plain_type.html">RTTIPlainType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template that you may specialize with a class if you want to provide simple serialization for it.  <a href="structbs_1_1_r_t_t_i_plain_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_i_reflectable.html">IReflectable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface implemented by classes that provide run time type information.  <a href="classbs_1_1_i_reflectable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_r_t_t_i_type.html">RTTIType&lt; Type, BaseType, MyRTTIType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to provide a run-time type information for a specific class, along with support for serialization/deserialization.  <a href="classbs_1_1_r_t_t_i_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga50db378ae7a89c0f117c81c8d364cd22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga50db378ae7a89c0f117c81c8d364cd22">BS_ALLOW_MEMCPY_SERIALIZATION</a>(type)</td></tr>
<tr class="memdesc:ga50db378ae7a89c0f117c81c8d364cd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the RTTI system that the specified type may be serialized just by using a memcpy.  <a href="#ga50db378ae7a89c0f117c81c8d364cd22">More...</a><br /></td></tr>
<tr class="separator:ga50db378ae7a89c0f117c81c8d364cd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8e8acce6f16b1ccbd812ef554eabd72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#gab8e8acce6f16b1ccbd812ef554eabd72">BS_BEGIN_RTTI_MEMBERS</a></td></tr>
<tr class="memdesc:gab8e8acce6f16b1ccbd812ef554eabd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts definitions for member fields within a RTTI type.  <a href="#gab8e8acce6f16b1ccbd812ef554eabd72">More...</a><br /></td></tr>
<tr class="separator:gab8e8acce6f16b1ccbd812ef554eabd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a70edc53502ab790f0796941f242487"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga7a70edc53502ab790f0796941f242487">BS_RTTI_MEMBER_PLAIN</a>(name,  id)</td></tr>
<tr class="memdesc:ga7a70edc53502ab790f0796941f242487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new member field in the RTTI type.  <a href="#ga7a70edc53502ab790f0796941f242487">More...</a><br /></td></tr>
<tr class="separator:ga7a70edc53502ab790f0796941f242487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0bdd12ad072be17a697e8a545011692"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#gaa0bdd12ad072be17a697e8a545011692">BS_RTTI_MEMBER_PLAIN_NAMED</a>(name,  field,  id)</td></tr>
<tr class="memdesc:gaa0bdd12ad072be17a697e8a545011692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as BS_RTTI_MEMBER_PLAIN, but allows you to specify separate names for the field name and the member variable.  <a href="#gaa0bdd12ad072be17a697e8a545011692">More...</a><br /></td></tr>
<tr class="separator:gaa0bdd12ad072be17a697e8a545011692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301fd8881543499ca3ed82fc98e24e94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga301fd8881543499ca3ed82fc98e24e94">BS_RTTI_MEMBER_PLAIN_ARRAY</a>(name,  id)</td></tr>
<tr class="memdesc:ga301fd8881543499ca3ed82fc98e24e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new member field in the RTTI type.  <a href="#ga301fd8881543499ca3ed82fc98e24e94">More...</a><br /></td></tr>
<tr class="separator:ga301fd8881543499ca3ed82fc98e24e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga226a81abbfc40ebf6490dbfec8b2992f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga226a81abbfc40ebf6490dbfec8b2992f">BS_RTTI_MEMBER_PLAIN_ARRAY_NAMED</a>(name,  field,  id)</td></tr>
<tr class="memdesc:ga226a81abbfc40ebf6490dbfec8b2992f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as BS_RTTI_MEMBER_PLAIN_ARRAY, but allows you to specify separate names for the field name and the member variable.  <a href="#ga226a81abbfc40ebf6490dbfec8b2992f">More...</a><br /></td></tr>
<tr class="separator:ga226a81abbfc40ebf6490dbfec8b2992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad59fcf7b0a063e510dd8055e29571a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#gaad59fcf7b0a063e510dd8055e29571a9">BS_RTTI_MEMBER_REFL</a>(name,  id)</td></tr>
<tr class="memdesc:gaad59fcf7b0a063e510dd8055e29571a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new member field in the RTTI type.  <a href="#gaad59fcf7b0a063e510dd8055e29571a9">More...</a><br /></td></tr>
<tr class="separator:gaad59fcf7b0a063e510dd8055e29571a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37d97bd1e094a0454f548585e18b7f7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga37d97bd1e094a0454f548585e18b7f7e">BS_RTTI_MEMBER_REFL_NAMED</a>(name,  field,  id)</td></tr>
<tr class="memdesc:ga37d97bd1e094a0454f548585e18b7f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as BS_RTTI_MEMBER_REFL, but allows you to specify separate names for the field name and the member variable.  <a href="#ga37d97bd1e094a0454f548585e18b7f7e">More...</a><br /></td></tr>
<tr class="separator:ga37d97bd1e094a0454f548585e18b7f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9048b3d3129ac0cb8380a018604afee4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga9048b3d3129ac0cb8380a018604afee4">BS_RTTI_MEMBER_REFL_ARRAY</a>(name,  id)</td></tr>
<tr class="memdesc:ga9048b3d3129ac0cb8380a018604afee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new member field in the RTTI type.  <a href="#ga9048b3d3129ac0cb8380a018604afee4">More...</a><br /></td></tr>
<tr class="separator:ga9048b3d3129ac0cb8380a018604afee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6cec6fedb14b9caf60560369ad31aab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#gaf6cec6fedb14b9caf60560369ad31aab">BS_RTTI_MEMBER_REFL_ARRAY_NAMED</a>(name,  field,  id)</td></tr>
<tr class="memdesc:gaf6cec6fedb14b9caf60560369ad31aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as BS_RTTI_MEMBER_REFL_ARRAY, but allows you to specify separate names for the field name and the member variable.  <a href="#gaf6cec6fedb14b9caf60560369ad31aab">More...</a><br /></td></tr>
<tr class="separator:gaf6cec6fedb14b9caf60560369ad31aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa62b0935cc5d822b27f54cc2636a8083"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#gaa62b0935cc5d822b27f54cc2636a8083">BS_RTTI_MEMBER_REFLPTR</a>(name,  id)</td></tr>
<tr class="memdesc:gaa62b0935cc5d822b27f54cc2636a8083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new member field in the RTTI type.  <a href="#gaa62b0935cc5d822b27f54cc2636a8083">More...</a><br /></td></tr>
<tr class="separator:gaa62b0935cc5d822b27f54cc2636a8083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a9ba1e73a3ce5e5aa9248019dfae9ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga0a9ba1e73a3ce5e5aa9248019dfae9ed">BS_RTTI_MEMBER_REFLPTR_NAMED</a>(name,  field,  id)</td></tr>
<tr class="memdesc:ga0a9ba1e73a3ce5e5aa9248019dfae9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as BS_RTTI_MEMBER_REFLPTR, but allows you to specify separate names for the field name and the member variable.  <a href="#ga0a9ba1e73a3ce5e5aa9248019dfae9ed">More...</a><br /></td></tr>
<tr class="separator:ga0a9ba1e73a3ce5e5aa9248019dfae9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d4cd69ef007b27720f5582cb7a98d5f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga1d4cd69ef007b27720f5582cb7a98d5f">BS_RTTI_MEMBER_REFLPTR_ARRAY</a>(name,  id)</td></tr>
<tr class="memdesc:ga1d4cd69ef007b27720f5582cb7a98d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new member field in the RTTI type.  <a href="#ga1d4cd69ef007b27720f5582cb7a98d5f">More...</a><br /></td></tr>
<tr class="separator:ga1d4cd69ef007b27720f5582cb7a98d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b5a958643096472d89a290026df509"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga69b5a958643096472d89a290026df509">BS_RTTI_MEMBER_REFLPTR_ARRAY_NAMED</a>(name,  field,  id)</td></tr>
<tr class="memdesc:ga69b5a958643096472d89a290026df509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as BS_RTTI_MEMBER_REFLPTR_ARRAY, but allows you to specify separate names for the field name and the member variable.  <a href="#ga69b5a958643096472d89a290026df509">More...</a><br /></td></tr>
<tr class="separator:ga69b5a958643096472d89a290026df509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac9cddd263f03da4f7180f09c1082fa4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#gaac9cddd263f03da4f7180f09c1082fa4">BS_END_RTTI_MEMBERS</a></td></tr>
<tr class="memdesc:gaac9cddd263f03da4f7180f09c1082fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends definitions for member fields with a RTTI type.  <a href="#gaac9cddd263f03da4f7180f09c1082fa4">More...</a><br /></td></tr>
<tr class="separator:gaac9cddd263f03da4f7180f09c1082fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2ee64a2167a4fa8d74d99f6566b010cc"><td class="memTemplParams" colspan="2">template&lt;class ElemType &gt; </td></tr>
<tr class="memitem:ga2ee64a2167a4fa8d74d99f6566b010cc"><td class="memTemplItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga2ee64a2167a4fa8d74d99f6566b010cc">rttiGetElemSize</a> (const ElemType &amp;data)</td></tr>
<tr class="memdesc:ga2ee64a2167a4fa8d74d99f6566b010cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method when serializing known data types that have valid <a class="el" href="structbs_1_1_r_t_t_i_plain_type.html" title="Template that you may specialize with a class if you want to provide simple serialization for it...">RTTIPlainType</a> specialization.  <a href="group___r_t_t_i.html#ga2ee64a2167a4fa8d74d99f6566b010cc">More...</a><br /></td></tr>
<tr class="separator:ga2ee64a2167a4fa8d74d99f6566b010cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b4188e84935159696af9fe97de503f"><td class="memTemplParams" colspan="2">template&lt;class ElemType &gt; </td></tr>
<tr class="memitem:gaf3b4188e84935159696af9fe97de503f"><td class="memTemplItemLeft" align="right" valign="top">char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#gaf3b4188e84935159696af9fe97de503f">rttiWriteElem</a> (const ElemType &amp;data, char *memory)</td></tr>
<tr class="memdesc:gaf3b4188e84935159696af9fe97de503f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method when serializing known data types that have valid <a class="el" href="structbs_1_1_r_t_t_i_plain_type.html" title="Template that you may specialize with a class if you want to provide simple serialization for it...">RTTIPlainType</a> specialization.  <a href="group___r_t_t_i.html#gaf3b4188e84935159696af9fe97de503f">More...</a><br /></td></tr>
<tr class="separator:gaf3b4188e84935159696af9fe97de503f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab78adba38c2c63fa6a81ffdca68eed3a"><td class="memTemplParams" colspan="2">template&lt;class ElemType &gt; </td></tr>
<tr class="memitem:gab78adba38c2c63fa6a81ffdca68eed3a"><td class="memTemplItemLeft" align="right" valign="top">char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#gab78adba38c2c63fa6a81ffdca68eed3a">rttiWriteElem</a> (const ElemType &amp;data, char *memory, UINT32 &amp;size)</td></tr>
<tr class="memdesc:gab78adba38c2c63fa6a81ffdca68eed3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method when serializing known data types that have valid <a class="el" href="structbs_1_1_r_t_t_i_plain_type.html" title="Template that you may specialize with a class if you want to provide simple serialization for it...">RTTIPlainType</a> specialization.  <a href="group___r_t_t_i.html#gab78adba38c2c63fa6a81ffdca68eed3a">More...</a><br /></td></tr>
<tr class="separator:gab78adba38c2c63fa6a81ffdca68eed3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b0469ba3081cd9ddefb77efe177f862"><td class="memTemplParams" colspan="2">template&lt;class ElemType &gt; </td></tr>
<tr class="memitem:ga4b0469ba3081cd9ddefb77efe177f862"><td class="memTemplItemLeft" align="right" valign="top">char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga4b0469ba3081cd9ddefb77efe177f862">rttiReadElem</a> (ElemType &amp;data, char *memory)</td></tr>
<tr class="memdesc:ga4b0469ba3081cd9ddefb77efe177f862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method when serializing known data types that have valid <a class="el" href="structbs_1_1_r_t_t_i_plain_type.html" title="Template that you may specialize with a class if you want to provide simple serialization for it...">RTTIPlainType</a> specialization.  <a href="group___r_t_t_i.html#ga4b0469ba3081cd9ddefb77efe177f862">More...</a><br /></td></tr>
<tr class="separator:ga4b0469ba3081cd9ddefb77efe177f862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7f96465b528db3afa4c9ba4b2f37aa"><td class="memTemplParams" colspan="2">template&lt;class ElemType &gt; </td></tr>
<tr class="memitem:ga7a7f96465b528db3afa4c9ba4b2f37aa"><td class="memTemplItemLeft" align="right" valign="top">char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga7a7f96465b528db3afa4c9ba4b2f37aa">rttiReadElem</a> (ElemType &amp;data, char *memory, UINT32 &amp;size)</td></tr>
<tr class="memdesc:ga7a7f96465b528db3afa4c9ba4b2f37aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method when serializing known data types that have valid <a class="el" href="structbs_1_1_r_t_t_i_plain_type.html" title="Template that you may specialize with a class if you want to provide simple serialization for it...">RTTIPlainType</a> specialization.  <a href="group___r_t_t_i.html#ga7a7f96465b528db3afa4c9ba4b2f37aa">More...</a><br /></td></tr>
<tr class="separator:ga7a7f96465b528db3afa4c9ba4b2f37aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47005b30a7bcd500c107e381483f1ba0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga47005b30a7bcd500c107e381483f1ba0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga47005b30a7bcd500c107e381483f1ba0">rtti_is_of_type</a> (<a class="el" href="classbs_1_1_i_reflectable.html">IReflectable</a> *object)</td></tr>
<tr class="memdesc:ga47005b30a7bcd500c107e381483f1ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided object can be safely cast into type T.  <a href="group___r_t_t_i.html#ga47005b30a7bcd500c107e381483f1ba0">More...</a><br /></td></tr>
<tr class="separator:ga47005b30a7bcd500c107e381483f1ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c93113c477fa40802a72c0b851fcc9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae7c93113c477fa40802a72c0b851fcc9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#gae7c93113c477fa40802a72c0b851fcc9">rtti_is_of_type</a> (<a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_i_reflectable.html">IReflectable</a> &gt; object)</td></tr>
<tr class="memdesc:gae7c93113c477fa40802a72c0b851fcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided object can be safely cast into type T.  <a href="group___r_t_t_i.html#gae7c93113c477fa40802a72c0b851fcc9">More...</a><br /></td></tr>
<tr class="separator:gae7c93113c477fa40802a72c0b851fcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476d9ab59f3da41184283cdaf90a9e50"><td class="memItemLeft" align="right" valign="top">BS_UTILITY_EXPORT <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_i_reflectable.html">IReflectable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga476d9ab59f3da41184283cdaf90a9e50">rtti_create</a> (UINT32 rttiId)</td></tr>
<tr class="memdesc:ga476d9ab59f3da41184283cdaf90a9e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object just from its type ID.  <a href="group___r_t_t_i.html#ga476d9ab59f3da41184283cdaf90a9e50">More...</a><br /></td></tr>
<tr class="separator:ga476d9ab59f3da41184283cdaf90a9e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e43021544200f240102893f41e4eed"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga95e43021544200f240102893f41e4eed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___r_t_t_i.html#ga95e43021544200f240102893f41e4eed">rtti_is_subclass</a> (<a class="el" href="classbs_1_1_i_reflectable.html">IReflectable</a> *object)</td></tr>
<tr class="memdesc:ga95e43021544200f240102893f41e4eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks is the current object a subclass of some type.  <a href="group___r_t_t_i.html#ga95e43021544200f240102893f41e4eed">More...</a><br /></td></tr>
<tr class="separator:ga95e43021544200f240102893f41e4eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga8fa647da67afe81b5d87a75b1df7349a"><td class="memItemLeft" align="right" valign="top"><a id="ga8fa647da67afe81b5d87a75b1df7349a"></a>
static <a class="el" href="structbs_1_1_init_r_t_t_i_on_start.html">InitRTTIOnStart</a>&lt; Type, BaseType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>initOnStart</b></td></tr>
<tr class="separator:ga8fa647da67afe81b5d87a75b1df7349a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga50db378ae7a89c0f117c81c8d364cd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50db378ae7a89c0f117c81c8d364cd22">&#9670;&nbsp;</a></span>BS_ALLOW_MEMCPY_SERIALIZATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_ALLOW_MEMCPY_SERIALIZATION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">static_assert (std::is_trivially_copyable&lt;type&gt;()==<span class="keyword">true</span>,            \</div><div class="line">                        #type <span class="stringliteral">&quot; is not trivially copyable&quot;</span>);            \</div><div class="line">    template&lt;&gt; <span class="keyword">struct </span>RTTIPlainType&lt;type&gt;                               \</div><div class="line">    {   <span class="keyword">enum</span> { <span class="keywordtype">id</span>=0 }; <span class="keyword">enum</span> { hasDynamicSize = 0 };                     \</div><div class="line">        static <span class="keywordtype">void</span> toMemory(<span class="keyword">const</span> type&amp; data, <span class="keywordtype">char</span>* memory)            \</div><div class="line">        { memcpy(memory, &amp;data, <span class="keyword">sizeof</span>(type)); }                        \</div><div class="line">        static UINT32 fromMemory(type&amp; data, <span class="keywordtype">char</span>* memory)              \</div><div class="line">        { memcpy(&amp;data, memory, <span class="keyword">sizeof</span>(type)); <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(type); }   \</div><div class="line">        static UINT32 getDynamicSize(<span class="keyword">const</span> type&amp; data)                  \</div><div class="line">        { <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(type); }                                        \</div><div class="line">    };</div></div><!-- fragment -->
<p>Notify the RTTI system that the specified type may be serialized just by using a memcpy. </p>
<dl class="section note"><dt>Note</dt><dd>Internally this creates a basic RTTIPlainType&lt;T&gt; specialization for the type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>RTTIPlainType&lt;T&gt; </dd></dl>

</div>
</div>
<a id="gab8e8acce6f16b1ccbd812ef554eabd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8e8acce6f16b1ccbd812ef554eabd72">&#9670;&nbsp;</a></span>BS_BEGIN_RTTI_MEMBERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_BEGIN_RTTI_MEMBERS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">struct </span>META_FirstEntry {};                                                                  \</div><div class="line">    void META_InitPrevEntry(META_FirstEntry typeId) { }                                         \</div><div class="line">                                                                                                \</div><div class="line">    typedef META_FirstEntry</div></div><!-- fragment -->
<p>Starts definitions for member fields within a RTTI type. </p>
<p>Follow this with calls to BS_RTTI_MEMBER* calls, and finish by calling BS_END_RTTI_MEMBERS. </p>

</div>
</div>
<a id="gaac9cddd263f03da4f7180f09c1082fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac9cddd263f03da4f7180f09c1082fa4">&#9670;&nbsp;</a></span>BS_END_RTTI_MEMBERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_END_RTTI_MEMBERS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">META_LastEntry;                                                                             \</div><div class="line">                                                                                                \</div><div class="line">    struct META_InitAllMembers                                                                  \</div><div class="line">    {                                                                                           \</div><div class="line">        META_InitAllMembers(MyType* owner)                                                      \</div><div class="line">        {                                                                                       \</div><div class="line">            owner-&gt;META_InitPrevEntry(META_LastEntry());                                        \</div><div class="line">        }                                                                                       \</div><div class="line">    };                                                                                          \</div><div class="line">                                                                                                \</div><div class="line">    META_InitAllMembers mInitMembers{<span class="keyword">this</span>};</div></div><!-- fragment -->
<p>Ends definitions for member fields with a RTTI type. </p>
<p>Must follow BS_BEGIN_RTTI_MEMBERS. </p>

</div>
</div>
<a id="ga7a70edc53502ab790f0796941f242487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a70edc53502ab790f0796941f242487">&#9670;&nbsp;</a></span>BS_RTTI_MEMBER_PLAIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_RTTI_MEMBER_PLAIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">META_Entry_##name;                                                                          \</div><div class="line">                                                                                                \</div><div class="line">    decltype(OwnerType::name)&amp; <span class="keyword">get</span>##name(OwnerType* obj) { <span class="keywordflow">return</span> obj-&gt;name; }                  \</div><div class="line">    void <span class="keyword">set</span>##name(OwnerType* obj, decltype(OwnerType::name)&amp; val) { obj-&gt;name = val; }         \</div><div class="line">                                                                                                \</div><div class="line">    struct META_NextEntry_##name{};                                                             \</div><div class="line">    void META_InitPrevEntry(META_NextEntry_##name typeId)                                       \</div><div class="line">    {                                                                                           \</div><div class="line">        addPlainField(#name, <span class="keywordtype">id</span>, &amp;MyType::get##name, &amp;MyType::set##name);                       \</div><div class="line">        META_InitPrevEntry(META_Entry_##name());                                                \</div><div class="line">    }                                                                                           \</div><div class="line">                                                                                                \</div><div class="line">    typedef META_NextEntry_##name</div></div><!-- fragment -->
<p>Registers a new member field in the RTTI type. </p>
<p>The field references the <code>name</code> member in the owner class. The type of the member must be a valid plain type. Each field must specify a unique ID for <code>id</code>. </p>

</div>
</div>
<a id="ga301fd8881543499ca3ed82fc98e24e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga301fd8881543499ca3ed82fc98e24e94">&#9670;&nbsp;</a></span>BS_RTTI_MEMBER_PLAIN_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_RTTI_MEMBER_PLAIN_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">META_Entry_##name;                                                                          \</div><div class="line">                                                                                                \</div><div class="line">    std::common_type&lt;decltype(OwnerType::name)&gt;::type::value_type&amp; <span class="keyword">get</span>##name(OwnerType* obj, UINT32 idx) { <span class="keywordflow">return</span> obj-&gt;name[idx]; }                 \</div><div class="line">    void <span class="keyword">set</span>##name(OwnerType* obj, UINT32 idx, std::common_type&lt;decltype(OwnerType::name)&gt;::type::value_type&amp; val) { obj-&gt;name[idx] = val; }        \</div><div class="line">    UINT32 getSize##name(OwnerType* obj) { <span class="keywordflow">return</span> (UINT32)obj-&gt;name.size(); }                                                                       \</div><div class="line">    void setSize##name(OwnerType* obj, UINT32 val) { obj-&gt;name.resize(val); }                                                                       \</div><div class="line">                                                                                                \</div><div class="line">    struct META_NextEntry_##name{};                                                             \</div><div class="line">    void META_InitPrevEntry(META_NextEntry_##name typeId)                                       \</div><div class="line">    {                                                                                           \</div><div class="line">        addPlainArrayField(#name, <span class="keywordtype">id</span>, &amp;MyType::get##name, &amp;MyType::getSize##name, &amp;MyType::set##name, &amp;MyType::setSize##name);                      \</div><div class="line">        META_InitPrevEntry(META_Entry_##name());                                                \</div><div class="line">    }                                                                                           \</div><div class="line">                                                                                                \</div><div class="line">    typedef META_NextEntry_##name</div></div><!-- fragment -->
<p>Registers a new member field in the RTTI type. </p>
<p>The field references the <code>name</code> member in the owner class. The type of the member must be an array of valid plain types. Each field must specify a unique ID for <code>id</code>. </p>

</div>
</div>
<a id="ga226a81abbfc40ebf6490dbfec8b2992f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga226a81abbfc40ebf6490dbfec8b2992f">&#9670;&nbsp;</a></span>BS_RTTI_MEMBER_PLAIN_ARRAY_NAMED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_RTTI_MEMBER_PLAIN_ARRAY_NAMED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">META_Entry_##name;                                                                          \</div><div class="line">                                                                                                \</div><div class="line">    std::common_type&lt;decltype(OwnerType::field)&gt;::type::value_type&amp; <span class="keyword">get</span>##name(OwnerType* obj, UINT32 idx) { <span class="keywordflow">return</span> obj-&gt;field[idx]; }                   \</div><div class="line">    void <span class="keyword">set</span>##name(OwnerType* obj, UINT32 idx, std::common_type&lt;decltype(OwnerType::field)&gt;::type::value_type&amp; val) { obj-&gt;field[idx] = val; }      \</div><div class="line">    UINT32 getSize##name(OwnerType* obj) { <span class="keywordflow">return</span> (UINT32)obj-&gt;field.size(); }                                                                      \</div><div class="line">    void setSize##name(OwnerType* obj, UINT32 val) { obj-&gt;field.resize(val); }                                                                      \</div><div class="line">                                                                                                \</div><div class="line">    struct META_NextEntry_##name{};                                                             \</div><div class="line">    void META_InitPrevEntry(META_NextEntry_##name typeId)                                       \</div><div class="line">    {                                                                                           \</div><div class="line">        addPlainArrayField(#name, <span class="keywordtype">id</span>, &amp;MyType::get##name, &amp;MyType::getSize##name, &amp;MyType::set##name, &amp;MyType::setSize##name);                      \</div><div class="line">        META_InitPrevEntry(META_Entry_##name());                                                \</div><div class="line">    }                                                                                           \</div><div class="line">                                                                                                \</div><div class="line">    typedef META_NextEntry_##name</div></div><!-- fragment -->
<p>Same as BS_RTTI_MEMBER_PLAIN_ARRAY, but allows you to specify separate names for the field name and the member variable. </p>

</div>
</div>
<a id="gaa0bdd12ad072be17a697e8a545011692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0bdd12ad072be17a697e8a545011692">&#9670;&nbsp;</a></span>BS_RTTI_MEMBER_PLAIN_NAMED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_RTTI_MEMBER_PLAIN_NAMED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">META_Entry_##name;                                                                          \</div><div class="line">                                                                                                \</div><div class="line">    decltype(OwnerType::field)&amp; <span class="keyword">get</span>##name(OwnerType* obj) { <span class="keywordflow">return</span> obj-&gt;field; }                \</div><div class="line">    void <span class="keyword">set</span>##name(OwnerType* obj, decltype(OwnerType::field)&amp; val) { obj-&gt;field = val; }       \</div><div class="line">                                                                                                \</div><div class="line">    struct META_NextEntry_##name{};                                                             \</div><div class="line">    void META_InitPrevEntry(META_NextEntry_##name typeId)                                       \</div><div class="line">    {                                                                                           \</div><div class="line">        addPlainField(#name, <span class="keywordtype">id</span>, &amp;MyType::get##name, &amp;MyType::set##name);                       \</div><div class="line">        META_InitPrevEntry(META_Entry_##name());                                                \</div><div class="line">    }                                                                                           \</div><div class="line">                                                                                                \</div><div class="line">    typedef META_NextEntry_##name</div></div><!-- fragment -->
<p>Same as BS_RTTI_MEMBER_PLAIN, but allows you to specify separate names for the field name and the member variable. </p>

</div>
</div>
<a id="gaad59fcf7b0a063e510dd8055e29571a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad59fcf7b0a063e510dd8055e29571a9">&#9670;&nbsp;</a></span>BS_RTTI_MEMBER_REFL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_RTTI_MEMBER_REFL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">META_Entry_##name;                                                                          \</div><div class="line">                                                                                                \</div><div class="line">    decltype(OwnerType::name)&amp; <span class="keyword">get</span>##name(OwnerType* obj) { <span class="keywordflow">return</span> obj-&gt;name; }                  \</div><div class="line">    void <span class="keyword">set</span>##name(OwnerType* obj, decltype(OwnerType::name)&amp; val) { obj-&gt;name = val; }         \</div><div class="line">                                                                                                \</div><div class="line">    struct META_NextEntry_##name{};                                                             \</div><div class="line">    void META_InitPrevEntry(META_NextEntry_##name typeId)                                       \</div><div class="line">    {                                                                                           \</div><div class="line">        addReflectableField(#name, <span class="keywordtype">id</span>, &amp;MyType::get##name, &amp;MyType::set##name);                 \</div><div class="line">        META_InitPrevEntry(META_Entry_##name());                                                \</div><div class="line">    }                                                                                           \</div><div class="line">                                                                                                \</div><div class="line">    typedef META_NextEntry_##name</div></div><!-- fragment -->
<p>Registers a new member field in the RTTI type. </p>
<p>The field references the <code>name</code> member in the owner class. The type of the member must be a valid reflectable (non-pointer) type. Each field must specify a unique ID for <code>id</code>. </p>

</div>
</div>
<a id="ga9048b3d3129ac0cb8380a018604afee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9048b3d3129ac0cb8380a018604afee4">&#9670;&nbsp;</a></span>BS_RTTI_MEMBER_REFL_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_RTTI_MEMBER_REFL_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">META_Entry_##name;                                                                          \</div><div class="line">                                                                                                \</div><div class="line">    std::common_type&lt;decltype(OwnerType::name)&gt;::type::value_type&amp; <span class="keyword">get</span>##name(OwnerType* obj, UINT32 idx) { <span class="keywordflow">return</span> obj-&gt;name[idx]; }                 \</div><div class="line">    void <span class="keyword">set</span>##name(OwnerType* obj, UINT32 idx, std::common_type&lt;decltype(OwnerType::name)&gt;::type::value_type&amp; val) { obj-&gt;name[idx] = val; }        \</div><div class="line">    UINT32 getSize##name(OwnerType* obj) { <span class="keywordflow">return</span> (UINT32)obj-&gt;name.size(); }                   \</div><div class="line">    void setSize##name(OwnerType* obj, UINT32 val) { obj-&gt;name.resize(val); }                   \</div><div class="line">                                                                                                \</div><div class="line">    struct META_NextEntry_##name{};                                                             \</div><div class="line">    void META_InitPrevEntry(META_NextEntry_##name typeId)                                       \</div><div class="line">    {                                                                                           \</div><div class="line">        addReflectableArrayField(#name, <span class="keywordtype">id</span>, &amp;MyType::get##name, &amp;MyType::getSize##name, &amp;MyType::set##name, &amp;MyType::setSize##name);                \</div><div class="line">        META_InitPrevEntry(META_Entry_##name());                                                \</div><div class="line">    }                                                                                           \</div><div class="line">                                                                                                \</div><div class="line">    typedef META_NextEntry_##name</div></div><!-- fragment -->
<p>Registers a new member field in the RTTI type. </p>
<p>The field references the <code>name</code> member in the owner class. The type of the member must be an array of valid reflectable (non-pointer) types. Each field must specify a unique ID for <code>id</code>. </p>

</div>
</div>
<a id="gaf6cec6fedb14b9caf60560369ad31aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6cec6fedb14b9caf60560369ad31aab">&#9670;&nbsp;</a></span>BS_RTTI_MEMBER_REFL_ARRAY_NAMED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_RTTI_MEMBER_REFL_ARRAY_NAMED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">META_Entry_##name;                                                                          \</div><div class="line">                                                                                                \</div><div class="line">    std::common_type&lt;decltype(OwnerType::field)&gt;::type::value_type&amp; <span class="keyword">get</span>##name(OwnerType* obj, UINT32 idx) { <span class="keywordflow">return</span> obj-&gt;field[idx]; }               \</div><div class="line">    void <span class="keyword">set</span>##name(OwnerType* obj, UINT32 idx, std::common_type&lt;decltype(OwnerType::field)&gt;::type::value_type&amp; val) { obj-&gt;field[idx] = val; }      \</div><div class="line">    UINT32 getSize##name(OwnerType* obj) { <span class="keywordflow">return</span> (UINT32)obj-&gt;field.size(); }                  \</div><div class="line">    void setSize##name(OwnerType* obj, UINT32 val) { obj-&gt;field.resize(val); }                  \</div><div class="line">                                                                                                \</div><div class="line">    struct META_NextEntry_##name{};                                                             \</div><div class="line">    void META_InitPrevEntry(META_NextEntry_##name typeId)                                       \</div><div class="line">    {                                                                                           \</div><div class="line">        addReflectableArrayField(#name, <span class="keywordtype">id</span>, &amp;MyType::get##name, &amp;MyType::getSize##name, &amp;MyType::set##name, &amp;MyType::setSize##name);                \</div><div class="line">        META_InitPrevEntry(META_Entry_##name());                                                \</div><div class="line">    }                                                                                           \</div><div class="line">                                                                                                \</div><div class="line">    typedef META_NextEntry_##name</div></div><!-- fragment -->
<p>Same as BS_RTTI_MEMBER_REFL_ARRAY, but allows you to specify separate names for the field name and the member variable. </p>

</div>
</div>
<a id="ga37d97bd1e094a0454f548585e18b7f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37d97bd1e094a0454f548585e18b7f7e">&#9670;&nbsp;</a></span>BS_RTTI_MEMBER_REFL_NAMED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_RTTI_MEMBER_REFL_NAMED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">META_Entry_##name;                                                                          \</div><div class="line">                                                                                                \</div><div class="line">    decltype(OwnerType::field)&amp; <span class="keyword">get</span>##name(OwnerType* obj) { <span class="keywordflow">return</span> obj-&gt;field; }                \</div><div class="line">    void <span class="keyword">set</span>##name(OwnerType* obj, decltype(OwnerType::field)&amp; val) { obj-&gt;field = val; }       \</div><div class="line">                                                                                                \</div><div class="line">    struct META_NextEntry_##name{};                                                             \</div><div class="line">    void META_InitPrevEntry(META_NextEntry_##name typeId)                                       \</div><div class="line">    {                                                                                           \</div><div class="line">        addReflectableField(#name, <span class="keywordtype">id</span>, &amp;MyType::get##name, &amp;MyType::set##name);                 \</div><div class="line">        META_InitPrevEntry(META_Entry_##name());                                                \</div><div class="line">    }                                                                                           \</div><div class="line">                                                                                                \</div><div class="line">    typedef META_NextEntry_##name</div></div><!-- fragment -->
<p>Same as BS_RTTI_MEMBER_REFL, but allows you to specify separate names for the field name and the member variable. </p>

</div>
</div>
<a id="gaa62b0935cc5d822b27f54cc2636a8083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa62b0935cc5d822b27f54cc2636a8083">&#9670;&nbsp;</a></span>BS_RTTI_MEMBER_REFLPTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_RTTI_MEMBER_REFLPTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">META_Entry_##name;                                                                          \</div><div class="line">                                                                                                \</div><div class="line">    decltype(OwnerType::name) <span class="keyword">get</span>##name(OwnerType* obj) { <span class="keywordflow">return</span> obj-&gt;name; }                   \</div><div class="line">    void <span class="keyword">set</span>##name(OwnerType* obj, decltype(OwnerType::name) val) { obj-&gt;name = val; }          \</div><div class="line">                                                                                                \</div><div class="line">    struct META_NextEntry_##name{};                                                             \</div><div class="line">    void META_InitPrevEntry(META_NextEntry_##name typeId)                                       \</div><div class="line">    {                                                                                           \</div><div class="line">        addReflectablePtrField(#name, <span class="keywordtype">id</span>, &amp;MyType::get##name, &amp;MyType::set##name);              \</div><div class="line">        META_InitPrevEntry(META_Entry_##name());                                                \</div><div class="line">    }                                                                                           \</div><div class="line">                                                                                                \</div><div class="line">    typedef META_NextEntry_##name</div></div><!-- fragment -->
<p>Registers a new member field in the RTTI type. </p>
<p>The field references the <code>name</code> member in the owner class. The type of the member must be a valid reflectable pointer type. Each field must specify a unique ID for <code>id</code>. </p>

</div>
</div>
<a id="ga1d4cd69ef007b27720f5582cb7a98d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d4cd69ef007b27720f5582cb7a98d5f">&#9670;&nbsp;</a></span>BS_RTTI_MEMBER_REFLPTR_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_RTTI_MEMBER_REFLPTR_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">META_Entry_##name;                                                                          \</div><div class="line">                                                                                                \</div><div class="line">    std::common_type&lt;decltype(OwnerType::name)&gt;::type::value_type <span class="keyword">get</span>##name(OwnerType* obj, UINT32 idx) { <span class="keywordflow">return</span> obj-&gt;name[idx]; }              \</div><div class="line">    void <span class="keyword">set</span>##name(OwnerType* obj, UINT32 idx, std::common_type&lt;decltype(OwnerType::name)&gt;::type::value_type val) { obj-&gt;name[idx] = val; }     \</div><div class="line">    UINT32 getSize##name(OwnerType* obj) { <span class="keywordflow">return</span> (UINT32)obj-&gt;name.size(); }                   \</div><div class="line">    void setSize##name(OwnerType* obj, UINT32 val) { obj-&gt;name.resize(val); }                   \</div><div class="line">                                                                                                \</div><div class="line">    struct META_NextEntry_##name{};                                                             \</div><div class="line">    void META_InitPrevEntry(META_NextEntry_##name typeId)                                       \</div><div class="line">    {                                                                                           \</div><div class="line">        addReflectablePtrArrayField(#name, <span class="keywordtype">id</span>, &amp;MyType::get##name, &amp;MyType::getSize##name, &amp;MyType::set##name, &amp;MyType::setSize##name);         \</div><div class="line">        META_InitPrevEntry(META_Entry_##name());                                                \</div><div class="line">    }                                                                                           \</div><div class="line">                                                                                                \</div><div class="line">    typedef META_NextEntry_##name</div></div><!-- fragment -->
<p>Registers a new member field in the RTTI type. </p>
<p>The field references the <code>name</code> member in the owner class. The type of the member must be a valid reflectable pointer type. Each field must specify a unique ID for <code>id</code>. </p>

</div>
</div>
<a id="ga69b5a958643096472d89a290026df509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69b5a958643096472d89a290026df509">&#9670;&nbsp;</a></span>BS_RTTI_MEMBER_REFLPTR_ARRAY_NAMED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_RTTI_MEMBER_REFLPTR_ARRAY_NAMED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">META_Entry_##name;                                                                          \</div><div class="line">                                                                                                \</div><div class="line">    std::common_type&lt;decltype(OwnerType::field)&gt;::type::value_type <span class="keyword">get</span>##name(OwnerType* obj, UINT32 idx) { <span class="keywordflow">return</span> obj-&gt;field[idx]; }                \</div><div class="line">    void <span class="keyword">set</span>##name(OwnerType* obj, UINT32 idx, std::common_type&lt;decltype(OwnerType::field)&gt;::type::value_type val) { obj-&gt;field[idx] = val; }       \</div><div class="line">    UINT32 getSize##name(OwnerType* obj) { <span class="keywordflow">return</span> (UINT32)obj-&gt;field.size(); }                  \</div><div class="line">    void setSize##name(OwnerType* obj, UINT32 val) { obj-&gt;field.resize(val); }                  \</div><div class="line">                                                                                                \</div><div class="line">    struct META_NextEntry_##name{};                                                             \</div><div class="line">    void META_InitPrevEntry(META_NextEntry_##name typeId)                                       \</div><div class="line">    {                                                                                           \</div><div class="line">        addReflectablePtrArrayField(#name, <span class="keywordtype">id</span>, &amp;MyType::get##name, &amp;MyType::getSize##name, &amp;MyType::set##name, &amp;MyType::setSize##name);         \</div><div class="line">        META_InitPrevEntry(META_Entry_##name());                                                \</div><div class="line">    }                                                                                           \</div><div class="line">                                                                                                \</div><div class="line">    typedef META_NextEntry_##name</div></div><!-- fragment -->
<p>Same as BS_RTTI_MEMBER_REFLPTR_ARRAY, but allows you to specify separate names for the field name and the member variable. </p>

</div>
</div>
<a id="ga0a9ba1e73a3ce5e5aa9248019dfae9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a9ba1e73a3ce5e5aa9248019dfae9ed">&#9670;&nbsp;</a></span>BS_RTTI_MEMBER_REFLPTR_NAMED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_RTTI_MEMBER_REFLPTR_NAMED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">META_Entry_##name;                                                                          \</div><div class="line">                                                                                                \</div><div class="line">    decltype(OwnerType::field) <span class="keyword">get</span>##name(OwnerType* obj) { <span class="keywordflow">return</span> obj-&gt;field; }                 \</div><div class="line">    void <span class="keyword">set</span>##name(OwnerType* obj, decltype(OwnerType::field) val) { obj-&gt;field = val; }        \</div><div class="line">                                                                                                \</div><div class="line">    struct META_NextEntry_##name{};                                                             \</div><div class="line">    void META_InitPrevEntry(META_NextEntry_##name typeId)                                       \</div><div class="line">    {                                                                                           \</div><div class="line">        addReflectablePtrField(#name, <span class="keywordtype">id</span>, &amp;MyType::get##name, &amp;MyType::set##name);              \</div><div class="line">        META_InitPrevEntry(META_Entry_##name());                                                \</div><div class="line">    }                                                                                           \</div><div class="line">                                                                                                \</div><div class="line">    typedef META_NextEntry_##name</div></div><!-- fragment -->
<p>Same as BS_RTTI_MEMBER_REFLPTR, but allows you to specify separate names for the field name and the member variable. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga476d9ab59f3da41184283cdaf90a9e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga476d9ab59f3da41184283cdaf90a9e50">&#9670;&nbsp;</a></span>rtti_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BS_UTILITY_EXPORT <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1_i_reflectable.html">IReflectable</a>&gt; bs::rtti_create </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>rttiId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new object just from its type ID. </p>

</div>
</div>
<a id="ga47005b30a7bcd500c107e381483f1ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47005b30a7bcd500c107e381483f1ba0">&#9670;&nbsp;</a></span>rtti_is_of_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bs::rtti_is_of_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbs_1_1_i_reflectable.html">IReflectable</a> *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the provided object can be safely cast into type T. </p>

</div>
</div>
<a id="gae7c93113c477fa40802a72c0b851fcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7c93113c477fa40802a72c0b851fcc9">&#9670;&nbsp;</a></span>rtti_is_of_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bs::rtti_is_of_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1_i_reflectable.html">IReflectable</a> &gt;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the provided object can be safely cast into type T. </p>

</div>
</div>
<a id="ga95e43021544200f240102893f41e4eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95e43021544200f240102893f41e4eed">&#9670;&nbsp;</a></span>rtti_is_subclass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bs::rtti_is_subclass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbs_1_1_i_reflectable.html">IReflectable</a> *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks is the current object a subclass of some type. </p>

</div>
</div>
<a id="ga2ee64a2167a4fa8d74d99f6566b010cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ee64a2167a4fa8d74d99f6566b010cc">&#9670;&nbsp;</a></span>rttiGetElemSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 bs::rttiGetElemSize </td>
          <td>(</td>
          <td class="paramtype">const ElemType &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method when serializing known data types that have valid <a class="el" href="structbs_1_1_r_t_t_i_plain_type.html" title="Template that you may specialize with a class if you want to provide simple serialization for it...">RTTIPlainType</a> specialization. </p>
<p>Returns the size of the element. If elements serializable type is specialized with hasDynamicSize == true, the dynamic size is calculated, otherwise sizeof() is used. </p>

</div>
</div>
<a id="ga4b0469ba3081cd9ddefb77efe177f862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b0469ba3081cd9ddefb77efe177f862">&#9670;&nbsp;</a></span>rttiReadElem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* bs::rttiReadElem </td>
          <td>(</td>
          <td class="paramtype">ElemType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method when serializing known data types that have valid <a class="el" href="structbs_1_1_r_t_t_i_plain_type.html" title="Template that you may specialize with a class if you want to provide simple serialization for it...">RTTIPlainType</a> specialization. </p>
<p>Reads the specified data into memory, advances the memory pointer by the bytes read and returns pointer to new memory. </p>

</div>
</div>
<a id="ga7a7f96465b528db3afa4c9ba4b2f37aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a7f96465b528db3afa4c9ba4b2f37aa">&#9670;&nbsp;</a></span>rttiReadElem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* bs::rttiReadElem </td>
          <td>(</td>
          <td class="paramtype">ElemType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32 &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method when serializing known data types that have valid <a class="el" href="structbs_1_1_r_t_t_i_plain_type.html" title="Template that you may specialize with a class if you want to provide simple serialization for it...">RTTIPlainType</a> specialization. </p>
<p>Reads the specified data into memory, advances the memory pointer by the bytes read and returns pointer to new memory. Also increases the size value by the size of the read element. </p>

</div>
</div>
<a id="gaf3b4188e84935159696af9fe97de503f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3b4188e84935159696af9fe97de503f">&#9670;&nbsp;</a></span>rttiWriteElem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* bs::rttiWriteElem </td>
          <td>(</td>
          <td class="paramtype">const ElemType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method when serializing known data types that have valid <a class="el" href="structbs_1_1_r_t_t_i_plain_type.html" title="Template that you may specialize with a class if you want to provide simple serialization for it...">RTTIPlainType</a> specialization. </p>
<p>Writes the specified data into memory, advances the memory pointer by the bytes written and returns pointer to new memory. </p>

</div>
</div>
<a id="gab78adba38c2c63fa6a81ffdca68eed3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab78adba38c2c63fa6a81ffdca68eed3a">&#9670;&nbsp;</a></span>rttiWriteElem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* bs::rttiWriteElem </td>
          <td>(</td>
          <td class="paramtype">const ElemType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32 &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method when serializing known data types that have valid <a class="el" href="structbs_1_1_r_t_t_i_plain_type.html" title="Template that you may specialize with a class if you want to provide simple serialization for it...">RTTIPlainType</a> specialization. </p>
<p>Writes the specified data into memory, advances the memory pointer by the bytes written and returns pointer to new memory. Also increases the size value by the size of the written element. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
