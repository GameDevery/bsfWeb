<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - GLGpuBuffer Class Reference</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='http://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="../SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="../SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebs.html">bs</a></li><li class="navelem"><b>ct</b></li><li class="navelem"><a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html">GLGpuBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Methods</a> &#124;
<a href="classbs_1_1ct_1_1_g_l_gpu_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GLGpuBuffer Class Reference<div class="ingroups"><a class="el" href="group___plugins.html">Plugins</a> &raquo; <a class="el" href="group___g_l.html">BansheeGLRenderAPI</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>OpenGL implementation of a generic GPU buffer. </p>
</div>
<p>Inherits <a class="el" href="classbs_1_1ct_1_1_gpu_buffer.html">GpuBuffer</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Methods</h2></td></tr>
<tr class="memitem:a26b30626f079fec8c0f519ad82d7241c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#a26b30626f079fec8c0f519ad82d7241c">lock</a> (UINT32 offset, UINT32 length, <a class="el" href="group___utility-_core.html#gab3f183d1c687b60796c72dda0073e2f3">GpuLockOptions</a> options, UINT32 deviceIdx=0, UINT32 queueIdx=0) override</td></tr>
<tr class="memdesc:a26b30626f079fec8c0f519ad82d7241c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks a portion of the buffer and returns pointer to the locked area. <br />
  <a href="#a26b30626f079fec8c0f519ad82d7241c">More...</a><br /></td></tr>
<tr class="separator:a26b30626f079fec8c0f519ad82d7241c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333677ac769a10df2775f24893e07c21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#a333677ac769a10df2775f24893e07c21">unlock</a> () override</td></tr>
<tr class="memdesc:a333677ac769a10df2775f24893e07c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock on this buffer. <br />
  <a href="#a333677ac769a10df2775f24893e07c21">More...</a><br /></td></tr>
<tr class="separator:a333677ac769a10df2775f24893e07c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e39463e9ce0f7d3875682503f0eb529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#a0e39463e9ce0f7d3875682503f0eb529">readData</a> (UINT32 offset, UINT32 length, void *dest, UINT32 deviceIdx=0, UINT32 queueIdx=0) override</td></tr>
<tr class="memdesc:a0e39463e9ce0f7d3875682503f0eb529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from a portion of the buffer and copies it to the destination buffer. <br />
  <a href="#a0e39463e9ce0f7d3875682503f0eb529">More...</a><br /></td></tr>
<tr class="separator:a0e39463e9ce0f7d3875682503f0eb529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ab1f124cb7354ab62b5453562f32a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#ac0ab1f124cb7354ab62b5453562f32a9">writeData</a> (UINT32 offset, UINT32 length, const void *source, <a class="el" href="group___utility-_core.html#gaa97ce01a8dbe96664979215009cc2c29">BufferWriteType</a> writeFlags=<a class="el" href="group___utility-_core.html#ggaa97ce01a8dbe96664979215009cc2c29ac9486c8284a168cdbce33184a6c34dff">BWT_NORMAL</a>, UINT32 queueIdx=0) override</td></tr>
<tr class="memdesc:ac0ab1f124cb7354ab62b5453562f32a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data into a portion of the buffer from the source memory. <br />
  <a href="#ac0ab1f124cb7354ab62b5453562f32a9">More...</a><br /></td></tr>
<tr class="separator:ac0ab1f124cb7354ab62b5453562f32a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e96b45491574ea98f700b18d8b0441"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#a94e96b45491574ea98f700b18d8b0441">copyData</a> (<a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;srcBuffer, UINT32 srcOffset, UINT32 dstOffset, UINT32 length, bool discardWholeBuffer=false, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a94e96b45491574ea98f700b18d8b0441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a specific portion of the source buffer into a specific portion of this buffer. <br />
  <a href="#a94e96b45491574ea98f700b18d8b0441">More...</a><br /></td></tr>
<tr class="separator:a94e96b45491574ea98f700b18d8b0441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff7a52ffd0d513e818d398c262b2847"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#a5ff7a52ffd0d513e818d398c262b2847">getGLBufferId</a> () const</td></tr>
<tr class="memdesc:a5ff7a52ffd0d513e818d398c262b2847"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Returns internal OpenGL buffer ID.  <a href="#a5ff7a52ffd0d513e818d398c262b2847">More...</a><br /></td></tr>
<tr class="separator:a5ff7a52ffd0d513e818d398c262b2847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cb5a73418825115086d85bb987a9cd"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#a17cb5a73418825115086d85bb987a9cd">getGLTextureId</a> () const</td></tr>
<tr class="memdesc:a17cb5a73418825115086d85bb987a9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal OpenGL texture ID.  <a href="#a17cb5a73418825115086d85bb987a9cd">More...</a><br /></td></tr>
<tr class="separator:a17cb5a73418825115086d85bb987a9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6719b2c629cad8a97395c38f83b9e33a"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#a6719b2c629cad8a97395c38f83b9e33a">getGLFormat</a> () const</td></tr>
<tr class="memdesc:a6719b2c629cad8a97395c38f83b9e33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal OpenGL format used by the elements of the buffer.  <a href="#a6719b2c629cad8a97395c38f83b9e33a">More...</a><br /></td></tr>
<tr class="separator:a6719b2c629cad8a97395c38f83b9e33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classbs_1_1ct_1_1_gpu_buffer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classbs_1_1ct_1_1_gpu_buffer')"><img src="closed.png" alt="-"/>&#160;Methods inherited from <a class="el" href="classbs_1_1ct_1_1_gpu_buffer.html">GpuBuffer</a></td></tr>
<tr class="memitem:a09c9adab3cb3f8c79b4315576360a299 inherit pub_methods_classbs_1_1ct_1_1_gpu_buffer"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbs_1_1_gpu_buffer_properties.html">GpuBufferProperties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_gpu_buffer.html#a09c9adab3cb3f8c79b4315576360a299">getProperties</a> () const</td></tr>
<tr class="memdesc:a09c9adab3cb3f8c79b4315576360a299 inherit pub_methods_classbs_1_1ct_1_1_gpu_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns properties describing the buffer.  <a href="classbs_1_1ct_1_1_gpu_buffer.html#a09c9adab3cb3f8c79b4315576360a299">More...</a><br /></td></tr>
<tr class="separator:a09c9adab3cb3f8c79b4315576360a299 inherit pub_methods_classbs_1_1ct_1_1_gpu_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classbs_1_1ct_1_1_core_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classbs_1_1ct_1_1_core_object')"><img src="closed.png" alt="-"/>&#160;Methods inherited from <a class="el" href="classbs_1_1ct_1_1_core_object.html">CoreObject</a></td></tr>
<tr class="memitem:adfc5fbc235a8ccc43a3d603faaa62e1b inherit pub_methods_classbs_1_1ct_1_1_core_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_core_object.html">CoreObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_core_object.html#adfc5fbc235a8ccc43a3d603faaa62e1b">getThisPtr</a> () const</td></tr>
<tr class="memdesc:adfc5fbc235a8ccc43a3d603faaa62e1b inherit pub_methods_classbs_1_1ct_1_1_core_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared_ptr version of "this" pointer.  <a href="classbs_1_1ct_1_1_core_object.html#adfc5fbc235a8ccc43a3d603faaa62e1b">More...</a><br /></td></tr>
<tr class="separator:adfc5fbc235a8ccc43a3d603faaa62e1b inherit pub_methods_classbs_1_1ct_1_1_core_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88eb1662d24feef6cf3c96fcbc280d2d inherit pub_methods_classbs_1_1ct_1_1_core_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_core_object.html#a88eb1662d24feef6cf3c96fcbc280d2d">_setThisPtr</a> (<a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_core_object.html">CoreObject</a> &gt; ptrThis)</td></tr>
<tr class="memdesc:a88eb1662d24feef6cf3c96fcbc280d2d inherit pub_methods_classbs_1_1ct_1_1_core_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a shared this pointer to this object.  <a href="classbs_1_1ct_1_1_core_object.html#a88eb1662d24feef6cf3c96fcbc280d2d">More...</a><br /></td></tr>
<tr class="separator:a88eb1662d24feef6cf3c96fcbc280d2d inherit pub_methods_classbs_1_1ct_1_1_core_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classbs_1_1_hardware_buffer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classbs_1_1_hardware_buffer')"><img src="closed.png" alt="-"/>&#160;Methods inherited from <a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a></td></tr>
<tr class="memitem:a6f10c4c910370528770f31eeb68937fe inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#a6f10c4c910370528770f31eeb68937fe">lock</a> (<a class="el" href="group___utility-_core.html#gab3f183d1c687b60796c72dda0073e2f3">GpuLockOptions</a> options, UINT32 deviceIdx=0, UINT32 queueIdx=0)</td></tr>
<tr class="memdesc:a6f10c4c910370528770f31eeb68937fe inherit pub_methods_classbs_1_1_hardware_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the entire buffer and returns pointer to the locked area.  <a href="classbs_1_1_hardware_buffer.html#a6f10c4c910370528770f31eeb68937fe">More...</a><br /></td></tr>
<tr class="separator:a6f10c4c910370528770f31eeb68937fe inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2db96da569923dd85906763e9b92479 inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#af2db96da569923dd85906763e9b92479">copyData</a> (<a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;srcBuffer, UINT32 srcOffset, UINT32 dstOffset, UINT32 length, bool discardWholeBuffer=false, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">ct::CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)=0</td></tr>
<tr class="memdesc:af2db96da569923dd85906763e9b92479 inherit pub_methods_classbs_1_1_hardware_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a specific portion of the source buffer into a specific portion of this buffer.  <a href="classbs_1_1_hardware_buffer.html#af2db96da569923dd85906763e9b92479">More...</a><br /></td></tr>
<tr class="separator:af2db96da569923dd85906763e9b92479 inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e45e589fe2a5541b6f0d410bb310fe8 inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#a5e45e589fe2a5541b6f0d410bb310fe8">copyData</a> (<a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;srcBuffer, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">ct::CommandBuffer</a> &gt; &amp;commandBuffer=nullptr)</td></tr>
<tr class="memdesc:a5e45e589fe2a5541b6f0d410bb310fe8 inherit pub_methods_classbs_1_1_hardware_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the provided buffer into this buffer.  <a href="classbs_1_1_hardware_buffer.html#a5e45e589fe2a5541b6f0d410bb310fe8">More...</a><br /></td></tr>
<tr class="separator:a5e45e589fe2a5541b6f0d410bb310fe8 inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee07b35f394554713293253d46e4260d inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#aee07b35f394554713293253d46e4260d">getSize</a> () const</td></tr>
<tr class="memdesc:aee07b35f394554713293253d46e4260d inherit pub_methods_classbs_1_1_hardware_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of this buffer in bytes.  <a href="classbs_1_1_hardware_buffer.html#aee07b35f394554713293253d46e4260d">More...</a><br /></td></tr>
<tr class="separator:aee07b35f394554713293253d46e4260d inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43966e19963e4bcb7f7f9b5327ec732b inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_hardware_buffer.html#a43966e19963e4bcb7f7f9b5327ec732b">isLocked</a> () const</td></tr>
<tr class="memdesc:a43966e19963e4bcb7f7f9b5327ec732b inherit pub_methods_classbs_1_1_hardware_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this buffer is currently locked.  <a href="classbs_1_1_hardware_buffer.html#a43966e19963e4bcb7f7f9b5327ec732b">More...</a><br /></td></tr>
<tr class="separator:a43966e19963e4bcb7f7f9b5327ec732b inherit pub_methods_classbs_1_1_hardware_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classbs_1_1ct_1_1_gpu_buffer"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classbs_1_1ct_1_1_gpu_buffer')"><img src="closed.png" alt="-"/>&#160;Static methods inherited from <a class="el" href="classbs_1_1ct_1_1_gpu_buffer.html">GpuBuffer</a></td></tr>
<tr class="memitem:a32527e7732d133bf68b222d2bbc3d922 inherit pub_static_methods_classbs_1_1ct_1_1_gpu_buffer"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_gpu_buffer.html">GpuBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_gpu_buffer.html#a32527e7732d133bf68b222d2bbc3d922">create</a> (const <a class="el" href="structbs_1_1_g_p_u___b_u_f_f_e_r___d_e_s_c.html">GPU_BUFFER_DESC</a> &amp;desc, <a class="el" href="group___utility-_core.html#ga0745ef733b8fba5e9585b5840131a81f">GpuDeviceFlags</a> deviceMask=<a class="el" href="group___utility-_core.html#gga0745ef733b8fba5e9585b5840131a81fa21db95975b89a15c0f3425f1c596d62b">GDF_DEFAULT</a>)</td></tr>
<tr class="memdesc:a32527e7732d133bf68b222d2bbc3d922 inherit pub_static_methods_classbs_1_1ct_1_1_gpu_buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a generic buffer that can be passed as a parameter to a GPU program. <br />
  <a href="classbs_1_1ct_1_1_gpu_buffer.html#a32527e7732d133bf68b222d2bbc3d922">More...</a><br /></td></tr>
<tr class="separator:a32527e7732d133bf68b222d2bbc3d922 inherit pub_static_methods_classbs_1_1ct_1_1_gpu_buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classbs_1_1ct_1_1_core_object"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classbs_1_1ct_1_1_core_object')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classbs_1_1ct_1_1_core_object.html">CoreObject</a></td></tr>
<tr class="memitem:aa705cf7e79a21c2352b00ffe20cd295f inherit pro_types_classbs_1_1ct_1_1_core_object"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_core_object.html#aa705cf7e79a21c2352b00ffe20cd295f">Flags</a> { <a class="el" href="classbs_1_1ct_1_1_core_object.html#aa705cf7e79a21c2352b00ffe20cd295fad33d965f4de028b957ab68c55384a987">CGCO_INITIALIZED</a> = 0x01, 
<a class="el" href="classbs_1_1ct_1_1_core_object.html#aa705cf7e79a21c2352b00ffe20cd295fa4de0a2b5fe7ab92df75f4b4245993379">CGCO_SCHEDULED_FOR_INIT</a> = 0x02
 }</td></tr>
<tr class="memdesc:aa705cf7e79a21c2352b00ffe20cd295f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values that represent current state of the object.  <a href="classbs_1_1ct_1_1_core_object.html#aa705cf7e79a21c2352b00ffe20cd295f">More...</a><br /></td></tr>
<tr class="separator:aa705cf7e79a21c2352b00ffe20cd295f inherit pro_types_classbs_1_1ct_1_1_core_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Method documentation</h2>
<a id="a94e96b45491574ea98f700b18d8b0441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e96b45491574ea98f700b18d8b0441">&#9670;&nbsp;</a></span>copyData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbs_1_1_hardware_buffer.html">HardwareBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>srcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>dstOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>discardWholeBuffer</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a specific portion of the source buffer into a specific portion of this buffer. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBuffer</td><td>Buffer to copy from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcOffset</td><td>Offset into the source buffer to start copying from, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstOffset</td><td>Offset into this buffer to start copying to, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Size of the data to copy, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">discardWholeBuffer</td><td>Specify true if the data in the current buffer can be entirely discarded. This may improve performance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Command buffer to queue the copy operation on. If null, main command buffer is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ff7a52ffd0d513e818d398c262b2847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff7a52ffd0d513e818d398c262b2847">&#9670;&nbsp;</a></span>getGLBufferId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint getGLBufferId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
Returns internal OpenGL buffer ID. </p>
<p>If binding the buffer to the pipeline, bind the texture using <a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#a17cb5a73418825115086d85bb987a9cd" title="Returns internal OpenGL texture ID. ">getGLTextureId()</a> instead. </p>

</div>
</div>
<a id="a6719b2c629cad8a97395c38f83b9e33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6719b2c629cad8a97395c38f83b9e33a">&#9670;&nbsp;</a></span>getGLFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint getGLFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the internal OpenGL format used by the elements of the buffer. </p>

</div>
</div>
<a id="a17cb5a73418825115086d85bb987a9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17cb5a73418825115086d85bb987a9cd">&#9670;&nbsp;</a></span>getGLTextureId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint getGLTextureId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns internal OpenGL texture ID. </p>

</div>
</div>
<a id="a371caef26098f2a15df9fbee047b58f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371caef26098f2a15df9fbee047b58f2">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called on the core thread when the object is first created. <br />
 </p>

<p>Reimplemented from <a class="el" href="classbs_1_1ct_1_1_core_object.html#a6365dca5a7d8ddb694726a53b55a4c27">CoreObject</a>.</p>

</div>
</div>
<a id="a26b30626f079fec8c0f519ad82d7241c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b30626f079fec8c0f519ad82d7241c">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* lock </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gab3f183d1c687b60796c72dda0073e2f3">GpuLockOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>deviceIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>queueIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks a portion of the buffer and returns pointer to the locked area. <br />
 </p>
<p>You must call <a class="el" href="classbs_1_1ct_1_1_g_l_gpu_buffer.html#a333677ac769a10df2775f24893e07c21" title="Releases the lock on this buffer.   ">unlock()</a> when done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes from which to lock the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the area you want to lock, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Signifies what you want to do with the returned pointer. Caller must ensure not to do anything he hasn't requested (for example don't try to read from the buffer unless you requested it here). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceIdx</td><td>Index of the device whose memory to map. If the buffer doesn't exist on this device, the method returns null. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueIdx</td><td>Device queue to perform any read/write operations on. See <a class="el" href="queues_doc.html">Device queues</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classbs_1_1_hardware_buffer.html#a0cbc193b72c0af3780c5f354dd4c821f">HardwareBuffer</a>.</p>

</div>
</div>
<a id="a0e39463e9ce0f7d3875682503f0eb529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e39463e9ce0f7d3875682503f0eb529">&#9670;&nbsp;</a></span>readData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void readData </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>deviceIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>queueIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data from a portion of the buffer and copies it to the destination buffer. <br />
 </p>
<p>Caller must ensure destination buffer is large enough.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes from which to copy the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the area you want to copy, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Destination buffer large enough to store the read data. Data is written from the start of the buffer (<code>offset</code> is only applied to the source). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceIdx</td><td>Index of the device whose memory to read. If the buffer doesn't exist on this device, no data will be read. <br />
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueIdx</td><td>Device queue to perform the read operation on. See <a class="el" href="queues_doc.html">Device queues</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1_hardware_buffer.html#a533ab13e635c42121fec740dc7b695cc">HardwareBuffer</a>.</p>

</div>
</div>
<a id="a333677ac769a10df2775f24893e07c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333677ac769a10df2775f24893e07c21">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock on this buffer. <br />
 </p>

<p>Reimplemented from <a class="el" href="classbs_1_1_hardware_buffer.html#ae6f018536d482152b993f522d8d2942d">HardwareBuffer</a>.</p>

</div>
</div>
<a id="ac0ab1f124cb7354ab62b5453562f32a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ab1f124cb7354ab62b5453562f32a9">&#9670;&nbsp;</a></span>writeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeData </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gaa97ce01a8dbe96664979215009cc2c29">BufferWriteType</a>&#160;</td>
          <td class="paramname"><em>writeFlags</em> = <code><a class="el" href="group___utility-_core.html#ggaa97ce01a8dbe96664979215009cc2c29ac9486c8284a168cdbce33184a6c34dff">BWT_NORMAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>queueIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data into a portion of the buffer from the source memory. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes from which to copy the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the area you want to copy, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source buffer containing the data to write. Data is read from the start of the buffer (<code>offset</code> is only applied to the destination). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">writeFlags</td><td>Optional write flags that may affect performance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueIdx</td><td>Device queue to perform the write operation on. See <a class="el" href="queues_doc.html">Device queues</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1_hardware_buffer.html#aed63b4da7c915f4b42e08824c4e60020">HardwareBuffer</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
