<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-120676613-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-120676613-1');
</script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - GLRenderAPI Class Reference</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='https://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebs.html">bs</a></li><li class="navelem"><b>ct</b></li><li class="navelem"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html">GLRenderAPI</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Methods</a> &#124;
<a href="classbs_1_1ct_1_1_g_l_render_a_p_i-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GLRenderAPI Class Reference<div class="ingroups"><a class="el" href="group___plugins.html">Plugins</a> &raquo; <a class="el" href="group___g_l.html">BansheeGLRenderAPI</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Implementation of a render system using OpenGL. </p>
<p>Provides abstracted access to various low level OpenGL methods. </p>
</div>
<p>Inherits <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html">RenderAPI</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Methods</h2></td></tr>
<tr class="memitem:a5099169c5d5949d4a96279844ad545ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbs_1_1_string_i_d.html">StringID</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a5099169c5d5949d4a96279844ad545ad">getName</a> () const override</td></tr>
<tr class="memdesc:a5099169c5d5949d4a96279844ad545ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the rendering system. <br />
  <a href="#a5099169c5d5949d4a96279844ad545ad">More...</a><br /></td></tr>
<tr class="separator:a5099169c5d5949d4a96279844ad545ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d06bc7ba63d82065a37664ad3098434"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a0d06bc7ba63d82065a37664ad3098434">setGraphicsPipeline</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_graphics_pipeline_state.html">GraphicsPipelineState</a> &gt; &amp;pipelineState, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a0d06bc7ba63d82065a37664ad3098434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a pipeline state that controls how will subsequent draw commands render primitives. <br />
  <a href="#a0d06bc7ba63d82065a37664ad3098434">More...</a><br /></td></tr>
<tr class="separator:a0d06bc7ba63d82065a37664ad3098434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3ee554197454cce52c13421779e3ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a5c3ee554197454cce52c13421779e3ac">setComputePipeline</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_compute_pipeline_state.html">ComputePipelineState</a> &gt; &amp;pipelineState, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a5c3ee554197454cce52c13421779e3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a pipeline state that controls how will subsequent dispatch commands execute. <br />
  <a href="#a5c3ee554197454cce52c13421779e3ac">More...</a><br /></td></tr>
<tr class="separator:a5c3ee554197454cce52c13421779e3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb90fad9397c2bad313abb1efa523845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#abb90fad9397c2bad313abb1efa523845">setGpuParams</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_gpu_params.html">GpuParams</a> &gt; &amp;gpuParams, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:abb90fad9397c2bad313abb1efa523845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a set of parameters that control execution of all currently bound GPU programs. <br />
  <a href="#abb90fad9397c2bad313abb1efa523845">More...</a><br /></td></tr>
<tr class="separator:abb90fad9397c2bad313abb1efa523845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc830dd83363d37c5d07f055b0e4b84f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#afc830dd83363d37c5d07f055b0e4b84f">setViewport</a> (const <a class="el" href="classbs_1_1_rect2.html">Rect2</a> &amp;area, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:afc830dd83363d37c5d07f055b0e4b84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the active viewport that will be used for all render operations. <br />
  <a href="#afc830dd83363d37c5d07f055b0e4b84f">More...</a><br /></td></tr>
<tr class="separator:afc830dd83363d37c5d07f055b0e4b84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedff3bdfd598d4200f81d7433ac27307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#aedff3bdfd598d4200f81d7433ac27307">setScissorRect</a> (UINT32 left, UINT32 top, UINT32 right, UINT32 bottom, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:aedff3bdfd598d4200f81d7433ac27307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows you to set up a region in which rendering can take place. <br />
  <a href="#aedff3bdfd598d4200f81d7433ac27307">More...</a><br /></td></tr>
<tr class="separator:aedff3bdfd598d4200f81d7433ac27307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8812da33be62834c28e7933735d279"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a4d8812da33be62834c28e7933735d279">setStencilRef</a> (UINT32 value, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a4d8812da33be62834c28e7933735d279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a reference value that will be used for stencil compare operations. <br />
  <a href="#a4d8812da33be62834c28e7933735d279">More...</a><br /></td></tr>
<tr class="separator:a4d8812da33be62834c28e7933735d279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fd1d924e30098801bdb8fc72df380b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#ac6fd1d924e30098801bdb8fc72df380b">setVertexBuffers</a> (UINT32 index, <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vertex_buffer.html">VertexBuffer</a> &gt; *buffers, UINT32 numBuffers, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:ac6fd1d924e30098801bdb8fc72df380b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the provided vertex buffers starting at the specified source index. <br />
  <a href="#ac6fd1d924e30098801bdb8fc72df380b">More...</a><br /></td></tr>
<tr class="separator:ac6fd1d924e30098801bdb8fc72df380b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631b9a35f09b7ba4135ce2d4fad24f2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a631b9a35f09b7ba4135ce2d4fad24f2b">setIndexBuffer</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_index_buffer.html">IndexBuffer</a> &gt; &amp;buffer, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a631b9a35f09b7ba4135ce2d4fad24f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an index buffer to use when drawing. <br />
  <a href="#a631b9a35f09b7ba4135ce2d4fad24f2b">More...</a><br /></td></tr>
<tr class="separator:a631b9a35f09b7ba4135ce2d4fad24f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2f84b7fd7ec04c7de0073f923fcdb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#abc2f84b7fd7ec04c7de0073f923fcdb6">setVertexDeclaration</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vertex_declaration.html">VertexDeclaration</a> &gt; &amp;vertexDeclaration, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:abc2f84b7fd7ec04c7de0073f923fcdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex declaration to use when drawing. <br />
  <a href="#abc2f84b7fd7ec04c7de0073f923fcdb6">More...</a><br /></td></tr>
<tr class="separator:abc2f84b7fd7ec04c7de0073f923fcdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ce409ebfc2b11c4844de7940492b5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a43ce409ebfc2b11c4844de7940492b5b">setDrawOperation</a> (<a class="el" href="group___utility-_core.html#ga0a43fbead35d1ad167d465731c5c4c53">DrawOperationType</a> op, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a43ce409ebfc2b11c4844de7940492b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the draw operation that determines how to interpret the elements of the index or vertex buffers. <br />
  <a href="#a43ce409ebfc2b11c4844de7940492b5b">More...</a><br /></td></tr>
<tr class="separator:a43ce409ebfc2b11c4844de7940492b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642b62982d6728d871bc8539be665c77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a642b62982d6728d871bc8539be665c77">draw</a> (UINT32 vertexOffset, UINT32 vertexCount, UINT32 instanceCount=0, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a642b62982d6728d871bc8539be665c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an object based on currently bound GPU programs, vertex declaration and vertex buffers. <br />
  <a href="#a642b62982d6728d871bc8539be665c77">More...</a><br /></td></tr>
<tr class="separator:a642b62982d6728d871bc8539be665c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eba64fc575bb70517d8c35f2b77f66a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a8eba64fc575bb70517d8c35f2b77f66a">drawIndexed</a> (UINT32 startIndex, UINT32 indexCount, UINT32 vertexOffset, UINT32 vertexCount, UINT32 instanceCount=0, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a8eba64fc575bb70517d8c35f2b77f66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an object based on currently bound GPU programs, vertex declaration, vertex and index buffers. <br />
  <a href="#a8eba64fc575bb70517d8c35f2b77f66a">More...</a><br /></td></tr>
<tr class="separator:a8eba64fc575bb70517d8c35f2b77f66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9634714c4d37ce1a794787eda55570b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a9634714c4d37ce1a794787eda55570b1">dispatchCompute</a> (UINT32 numGroupsX, UINT32 numGroupsY=1, UINT32 numGroupsZ=1, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a9634714c4d37ce1a794787eda55570b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the currently bound compute shader. <br />
  <a href="#a9634714c4d37ce1a794787eda55570b1">More...</a><br /></td></tr>
<tr class="separator:a9634714c4d37ce1a794787eda55570b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45aa4fc19ef23ccacb2ad0de3b7d449e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a45aa4fc19ef23ccacb2ad0de3b7d449e">swapBuffers</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_target.html">RenderTarget</a> &gt; &amp;target, UINT32 syncMask=0xFFFFFFFF) override</td></tr>
<tr class="memdesc:a45aa4fc19ef23ccacb2ad0de3b7d449e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the front and back buffer of the specified render target. <br />
  <a href="#a45aa4fc19ef23ccacb2ad0de3b7d449e">More...</a><br /></td></tr>
<tr class="separator:a45aa4fc19ef23ccacb2ad0de3b7d449e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25e6df723f29a5647adced8b644e06d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#af25e6df723f29a5647adced8b644e06d">setRenderTarget</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_target.html">RenderTarget</a> &gt; &amp;target, UINT32 readOnlyFlags=0, <a class="el" href="classbs_1_1_flags.html">RenderSurfaceMask</a> loadMask=RT_NONE, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:af25e6df723f29a5647adced8b644e06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the render target into which we want to draw. <br />
  <a href="#af25e6df723f29a5647adced8b644e06d">More...</a><br /></td></tr>
<tr class="separator:af25e6df723f29a5647adced8b644e06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f0245bd3b64909cddab2a8f5d2ee80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a91f0245bd3b64909cddab2a8f5d2ee80">clearRenderTarget</a> (UINT32 buffers, const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;color=Color::Black, float depth=1.0f, UINT16 stencil=0, UINT8 targetMask=0xFF, const SPtr&lt; CommandBuffer &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a91f0245bd3b64909cddab2a8f5d2ee80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the currently active render target. <br />
  <a href="#a91f0245bd3b64909cddab2a8f5d2ee80">More...</a><br /></td></tr>
<tr class="separator:a91f0245bd3b64909cddab2a8f5d2ee80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c11c7d446f639196adf69b56308a228"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a5c11c7d446f639196adf69b56308a228">clearViewport</a> (UINT32 buffers, const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;color=Color::Black, float depth=1.0f, UINT16 stencil=0, UINT8 targetMask=0xFF, const SPtr&lt; CommandBuffer &gt; &amp;commandBuffer=nullptr) override</td></tr>
<tr class="memdesc:a5c11c7d446f639196adf69b56308a228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the currently active viewport (meaning it clears just a sub-area of a render-target that is covered by the viewport, as opposed to <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a91f0245bd3b64909cddab2a8f5d2ee80" title="Clears the currently active render target.   ">clearRenderTarget()</a> which always clears the entire render target). <br />
  <a href="#a5c11c7d446f639196adf69b56308a228">More...</a><br /></td></tr>
<tr class="separator:a5c11c7d446f639196adf69b56308a228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657c493f81508905b613366918c48420"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a657c493f81508905b613366918c48420">addCommands</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer, const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;secondary) override</td></tr>
<tr class="memdesc:a657c493f81508905b613366918c48420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all commands from the provided secondary command buffer into the primary command buffer. <br />
  <a href="#a657c493f81508905b613366918c48420">More...</a><br /></td></tr>
<tr class="separator:a657c493f81508905b613366918c48420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4028d9ce0fd012246b961b6751a764b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a4028d9ce0fd012246b961b6751a764b2">submitCommandBuffer</a> (const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;commandBuffer, UINT32 syncMask=0xFFFFFFFF) override</td></tr>
<tr class="memdesc:a4028d9ce0fd012246b961b6751a764b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes all commands in the provided command buffer. <br />
  <a href="#a4028d9ce0fd012246b961b6751a764b2">More...</a><br /></td></tr>
<tr class="separator:a4028d9ce0fd012246b961b6751a764b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52623f1583db791bf9fc12692e2c477"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#af52623f1583db791bf9fc12692e2c477">convertProjectionMatrix</a> (const <a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> &amp;matrix, <a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> &amp;dest) override</td></tr>
<tr class="memdesc:af52623f1583db791bf9fc12692e2c477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a default matrix into a matrix suitable for use by this specific render system. <br />
  <a href="#af52623f1583db791bf9fc12692e2c477">More...</a><br /></td></tr>
<tr class="separator:af52623f1583db791bf9fc12692e2c477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a90f56b153b7ff73d4171e675cd6ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbs_1_1_render_a_p_i_info.html">RenderAPIInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a35a90f56b153b7ff73d4171e675cd6ad">getAPIInfo</a> () const override</td></tr>
<tr class="memdesc:a35a90f56b153b7ff73d4171e675cd6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about the specific API implementation. <br />
  <a href="#a35a90f56b153b7ff73d4171e675cd6ad">More...</a><br /></td></tr>
<tr class="separator:a35a90f56b153b7ff73d4171e675cd6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a111d30df3a3ccd22861e61207a31e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbs_1_1_gpu_param_block_desc.html">GpuParamBlockDesc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a9a111d30df3a3ccd22861e61207a31e1">generateParamBlockDesc</a> (const <a class="el" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> &amp;name, <a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="structbs_1_1_gpu_param_data_desc.html">GpuParamDataDesc</a> &gt; &amp;params) override</td></tr>
<tr class="memdesc:a9a111d30df3a3ccd22861e61207a31e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a parameter block description and calculates per-parameter offsets for the provided gpu data parameters. <br />
  <a href="#a9a111d30df3a3ccd22861e61207a31e1">More...</a><br /></td></tr>
<tr class="separator:a9a111d30df3a3ccd22861e61207a31e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d57ecf072ffb0356b551735530afdee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a6d57ecf072ffb0356b551735530afdee">_isContextInitialized</a> () const</td></tr>
<tr class="memdesc:a6d57ecf072ffb0356b551735530afdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query has the main context been initialized.  <a href="#a6d57ecf072ffb0356b551735530afdee">More...</a><br /></td></tr>
<tr class="separator:a6d57ecf072ffb0356b551735530afdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b031063f1ceea4c499ef7d3f5e314a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_g_l_context.html">GLContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a7b031063f1ceea4c499ef7d3f5e314a5">_getMainContext</a> () const</td></tr>
<tr class="memdesc:a7b031063f1ceea4c499ef7d3f5e314a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns main context.  <a href="#a7b031063f1ceea4c499ef7d3f5e314a5">More...</a><br /></td></tr>
<tr class="separator:a7b031063f1ceea4c499ef7d3f5e314a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e2315ca5c8b6b4c06f746c6c538de9"><td class="memItemLeft" align="right" valign="top"><a id="a70e2315ca5c8b6b4c06f746c6c538de9"></a>
<a class="el" href="classbs_1_1ct_1_1_g_l_support.html">GLSupport</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a70e2315ca5c8b6b4c06f746c6c538de9">getGLSupport</a> () const</td></tr>
<tr class="memdesc:a70e2315ca5c8b6b4c06f746c6c538de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a support object you may use for creating. <br /></td></tr>
<tr class="separator:a70e2315ca5c8b6b4c06f746c6c538de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classbs_1_1ct_1_1_render_a_p_i')"><img src="closed.png" alt="-"/>&#160;Methods inherited from <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html">RenderAPI</a></td></tr>
<tr class="memitem:af4391aff66b3a8a6b9fa9f318b1e0763 inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbs_1_1_render_a_p_i_capabilities.html">RenderAPICapabilities</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#af4391aff66b3a8a6b9fa9f318b1e0763">getCapabilities</a> (UINT32 deviceIdx) const</td></tr>
<tr class="memdesc:af4391aff66b3a8a6b9fa9f318b1e0763 inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the capabilities of a specific GPU.  <a href="classbs_1_1ct_1_1_render_a_p_i.html#af4391aff66b3a8a6b9fa9f318b1e0763">More...</a><br /></td></tr>
<tr class="separator:af4391aff66b3a8a6b9fa9f318b1e0763 inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa47621db2c7fa844fd178af921b8f2 inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a2fa47621db2c7fa844fd178af921b8f2">getNumDevices</a> () const</td></tr>
<tr class="memdesc:a2fa47621db2c7fa844fd178af921b8f2 inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of devices supported by this render API.  <a href="classbs_1_1ct_1_1_render_a_p_i.html#a2fa47621db2c7fa844fd178af921b8f2">More...</a><br /></td></tr>
<tr class="separator:a2fa47621db2c7fa844fd178af921b8f2 inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e037344fde0e4cdb31d343fa158e7d inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbs_1_1_video_mode_info.html">VideoModeInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ad8e037344fde0e4cdb31d343fa158e7d">getVideoModeInfo</a> () const</td></tr>
<tr class="memdesc:ad8e037344fde0e4cdb31d343fa158e7d inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about available output devices and their video modes.  <a href="classbs_1_1ct_1_1_render_a_p_i.html#ad8e037344fde0e4cdb31d343fa158e7d">More...</a><br /></td></tr>
<tr class="separator:ad8e037344fde0e4cdb31d343fa158e7d inherit pub_methods_classbs_1_1ct_1_1_render_a_p_i"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classbs_1_1_module"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classbs_1_1_module')"><img src="closed.png" alt="-"/>&#160;Static methods inherited from <a class="el" href="classbs_1_1_module.html">Module&lt; RenderAPI &gt;</a></td></tr>
<tr class="memitem:a359703743cd890f1e3df60b6b06a5724 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbs_1_1_render_a_p_i.html">RenderAPI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a359703743cd890f1e3df60b6b06a5724">instance</a> ()</td></tr>
<tr class="memdesc:a359703743cd890f1e3df60b6b06a5724 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the module instance.  <a href="classbs_1_1_module.html#a359703743cd890f1e3df60b6b06a5724">More...</a><br /></td></tr>
<tr class="separator:a359703743cd890f1e3df60b6b06a5724 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affac4ec5f49e5e5561a027e3116e6f73 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbs_1_1_render_a_p_i.html">RenderAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#affac4ec5f49e5e5561a027e3116e6f73">instancePtr</a> ()</td></tr>
<tr class="memdesc:affac4ec5f49e5e5561a027e3116e6f73 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the module instance.  <a href="classbs_1_1_module.html#affac4ec5f49e5e5561a027e3116e6f73">More...</a><br /></td></tr>
<tr class="separator:affac4ec5f49e5e5561a027e3116e6f73 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b9d091b1b64652c94d5dd3b1c5017a inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a02b9d091b1b64652c94d5dd3b1c5017a">startUp</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a02b9d091b1b64652c94d5dd3b1c5017a inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and starts the module using the specified parameters.  <a href="classbs_1_1_module.html#a02b9d091b1b64652c94d5dd3b1c5017a">More...</a><br /></td></tr>
<tr class="separator:a02b9d091b1b64652c94d5dd3b1c5017a inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1a58af7a42d68c1ae45e40fbe8cebb inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a4d1a58af7a42d68c1ae45e40fbe8cebb">startUp</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a4d1a58af7a42d68c1ae45e40fbe8cebb inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and starts a specialized type of the module.  <a href="classbs_1_1_module.html#a4d1a58af7a42d68c1ae45e40fbe8cebb">More...</a><br /></td></tr>
<tr class="separator:a4d1a58af7a42d68c1ae45e40fbe8cebb inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ea87e87e28686a619551382f541433 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#aa4ea87e87e28686a619551382f541433">shutDown</a> ()</td></tr>
<tr class="memdesc:aa4ea87e87e28686a619551382f541433 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down this module and frees any resources it is using.  <a href="classbs_1_1_module.html#aa4ea87e87e28686a619551382f541433">More...</a><br /></td></tr>
<tr class="separator:aa4ea87e87e28686a619551382f541433 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289734510f3022acd240087478b994d9 inherit pub_static_methods_classbs_1_1_module"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbs_1_1_module.html#a289734510f3022acd240087478b994d9">isStarted</a> ()</td></tr>
<tr class="memdesc:a289734510f3022acd240087478b994d9 inherit pub_static_methods_classbs_1_1_module"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if the module has been started.  <a href="classbs_1_1_module.html#a289734510f3022acd240087478b994d9">More...</a><br /></td></tr>
<tr class="separator:a289734510f3022acd240087478b994d9 inherit pub_static_methods_classbs_1_1_module"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Method documentation</h2>
<a id="a7b031063f1ceea4c499ef7d3f5e314a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b031063f1ceea4c499ef7d3f5e314a5">&#9670;&nbsp;</a></span>_getMainContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1ct_1_1_g_l_context.html">GLContext</a>&gt; _getMainContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns main context. </p>
<p>Caller must ensure the context has been initialized. </p>

</div>
</div>
<a id="a6d57ecf072ffb0356b551735530afdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d57ecf072ffb0356b551735530afdee">&#9670;&nbsp;</a></span>_isContextInitialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _isContextInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query has the main context been initialized. </p>

</div>
</div>
<a id="aead459b322c5bbbab42b917096509aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead459b322c5bbbab42b917096509aa8">&#9670;&nbsp;</a></span>activateGLTextureUnit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool activateGLTextureUnit </td>
          <td>(</td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>unit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the currently active texture unit. </p>
<p><a class="el" href="classbs_1_1_any.html" title="Class capable of storing any general type, and safely extracting the proper type from the internal da...">Any</a> texture related operations will then be performed on this unit. </p>

</div>
</div>
<a id="a657c493f81508905b613366918c48420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657c493f81508905b613366918c48420">&#9670;&nbsp;</a></span>addCommands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addCommands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>secondary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all commands from the provided secondary command buffer into the primary command buffer. <br />
 </p>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a100a6f2c03e04d56355177a848d811aa">RenderAPI</a>.</p>

</div>
</div>
<a id="aa04ff5477adc7719d09766ac8ec33be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04ff5477adc7719d09766ac8ec33be1">&#9670;&nbsp;</a></span>beginDraw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void beginDraw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call before doing a draw operation, this method sets everything up. </p>

</div>
</div>
<a id="ab78c7cef1334e922f744bc9d13cb2578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78c7cef1334e922f744bc9d13cb2578">&#9670;&nbsp;</a></span>clearArea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearArea </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em> = <code>Color::Black</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>stencil</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_rect2_i.html">Rect2I</a> &amp;&#160;</td>
          <td class="paramname"><em>clearArea</em> = <code>Rect2I::EMPTY</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8&#160;</td>
          <td class="paramname"><em>targetMask</em> = <code>0xFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a part of a render target. </p>

</div>
</div>
<a id="a91f0245bd3b64909cddab2a8f5d2ee80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f0245bd3b64909cddab2a8f5d2ee80">&#9670;&nbsp;</a></span>clearRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearRenderTarget </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em> = <code>Color::Black</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>stencil</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8&#160;</td>
          <td class="paramname"><em>targetMask</em> = <code>0xFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the currently active render target. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>Combination of one or more elements of FrameBufferType denoting which buffers are to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to clear the color buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>The value to initialize the depth buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stencil</td><td>The value to initialize the stencil buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetMask</td><td>In case multiple render targets are bound, this allows you to control which ones to clear (0x01 first, 0x02 second, 0x04 third, etc., and combinations). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#aa322bfe6a30f71ec423e6f08c8734458">RenderAPI</a>.</p>

</div>
</div>
<a id="a5c11c7d446f639196adf69b56308a228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c11c7d446f639196adf69b56308a228">&#9670;&nbsp;</a></span>clearViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clearViewport </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em> = <code>Color::Black</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>stencil</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8&#160;</td>
          <td class="paramname"><em>targetMask</em> = <code>0xFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the currently active viewport (meaning it clears just a sub-area of a render-target that is covered by the viewport, as opposed to <a class="el" href="classbs_1_1ct_1_1_g_l_render_a_p_i.html#a91f0245bd3b64909cddab2a8f5d2ee80" title="Clears the currently active render target.   ">clearRenderTarget()</a> which always clears the entire render target). <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>Combination of one or more elements of FrameBufferType denoting which buffers are to be cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>The color to clear the color buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>The value to initialize the depth buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stencil</td><td>The value to initialize the stencil buffer with, if enabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetMask</td><td>In case multiple render targets are bound, this allows you to control which ones to clear (0x01 first, 0x02 second, 0x04 third, etc., and combinations). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#aa18d21e36f2474fa6a76b27ab85124b0">RenderAPI</a>.</p>

</div>
</div>
<a id="aa163f864a984803ecc3c7892aadf5bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa163f864a984803ecc3c7892aadf5bed">&#9670;&nbsp;</a></span>convertCompareFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLint convertCompareFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga36e1a5e792be24b3d1ed4f5fabea818d">CompareFunction</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the engine depth/stencil compare function into OpenGL representation. </p>

</div>
</div>
<a id="af52623f1583db791bf9fc12692e2c477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52623f1583db791bf9fc12692e2c477">&#9670;&nbsp;</a></span>convertProjectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void convertProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains a default matrix into a matrix suitable for use by this specific render system. <br />
 </p>
<dl class="section note"><dt>Note</dt><dd>Thread safe. </dd></dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a39286473640751160bdb8536c859f413">RenderAPI</a>.</p>

</div>
</div>
<a id="a56de5f7c1348290be51929e502cb254d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56de5f7c1348290be51929e502cb254d">&#9670;&nbsp;</a></span>convertStencilOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLint convertStencilOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gac692ecc1ffb4255c8c8628a3ce6f7a4b">StencilOperation</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convers the engine stencil operation in OpenGL representation. </p>

</div>
</div>
<a id="ac8cf325a37d7e7f96eed609f7d426bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cf325a37d7e7f96eed609f7d426bba">&#9670;&nbsp;</a></span>destroyCore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void destroyCore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs render API system shutdown on the core thread. <br />
 </p>

<p>Reimplemented from <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a30aad4dcf6e2df219ea8d2eb6da62c9c">RenderAPI</a>.</p>

</div>
</div>
<a id="a9634714c4d37ce1a794787eda55570b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9634714c4d37ce1a794787eda55570b1">&#9670;&nbsp;</a></span>dispatchCompute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dispatchCompute </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numGroupsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numGroupsY</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numGroupsZ</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the currently bound compute shader. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numGroupsX</td><td>Number of groups to start in the X direction. Must be in range [1, 65535]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numGroupsY</td><td>Number of groups to start in the Y direction. Must be in range [1, 65535]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numGroupsZ</td><td>Number of groups to start in the Z direction. Must be in range [1, 64]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support compute or graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a54c8eb09649871e3ea3de65fa79bdf12">RenderAPI</a>.</p>

</div>
</div>
<a id="a642b62982d6728d871bc8539be665c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642b62982d6728d871bc8539be665c77">&#9670;&nbsp;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void draw </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>vertexOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>instanceCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw an object based on currently bound GPU programs, vertex declaration and vertex buffers. <br />
 </p>
<p>Draws directly from the vertex buffer without using indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexOffset</td><td>Offset into the currently bound vertex buffer to start drawing from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexCount</td><td>Number of vertices to draw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">instanceCount</td><td>Number of times to draw the provided geometry, each time with an (optionally) separate per-instance data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a1cc00f62de16b8141290d68cfe7b67a4">RenderAPI</a>.</p>

</div>
</div>
<a id="a8eba64fc575bb70517d8c35f2b77f66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eba64fc575bb70517d8c35f2b77f66a">&#9670;&nbsp;</a></span>drawIndexed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drawIndexed </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>startIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>indexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>vertexOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>instanceCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw an object based on currently bound GPU programs, vertex declaration, vertex and index buffers. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>Offset into the currently bound index buffer to start drawing from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexCount</td><td>Number of indices to draw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexOffset</td><td>Offset to apply to each vertex index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexCount</td><td>Number of vertices to draw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">instanceCount</td><td>Number of times to draw the provided geometry, each time with an (optionally) separate per-instance data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ae7f5b32d5f5e2f8016b5c9d5078d28e4">RenderAPI</a>.</p>

</div>
</div>
<a id="aca0a43412c6d957fdbd9a63ccefb090c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0a43412c6d957fdbd9a63ccefb090c">&#9670;&nbsp;</a></span>endDraw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void endDraw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Needs to accompany every beginDraw after you are done with a single draw operation. </p>

</div>
</div>
<a id="a9a111d30df3a3ccd22861e61207a31e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a111d30df3a3ccd22861e61207a31e1">&#9670;&nbsp;</a></span>generateParamBlockDesc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbs_1_1_gpu_param_block_desc.html">GpuParamBlockDesc</a> generateParamBlockDesc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___containers.html#ga7eff25c8c62ee478cb8e5909eb8c2c46">Vector</a>&lt; <a class="el" href="structbs_1_1_gpu_param_data_desc.html">GpuParamDataDesc</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a parameter block description and calculates per-parameter offsets for the provided gpu data parameters. <br />
 </p>
<p>The offsets are render API specific and correspond to std140 layout for OpenGL, and the default layout in DirectX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name to assign the parameter block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>List of parameters in the parameter block. Only name, type and array size fields need to be populated, the rest will be populated when the method returns. If a parameter is a struct then the elementSize field needs to be populated with the size of the struct in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Descriptor for the parameter block holding the provided parameters as laid out by the default render API layout. </dd></dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a9400792256a05759150326c41b6b4c20">RenderAPI</a>.</p>

</div>
</div>
<a id="ae72e1f04d2fe33329b842261763610f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72e1f04d2fe33329b842261763610f6">&#9670;&nbsp;</a></span>getActiveProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;<a class="el" href="classbs_1_1ct_1_1_g_l_s_l_gpu_program.html">GLSLGpuProgram</a>&gt; getActiveProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gaf388801ddd39d30124c0da064556415a">GpuProgramType</a>&#160;</td>
          <td class="paramname"><em>gptype</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the active GPU program of the specified type. </p>

</div>
</div>
<a id="a35a90f56b153b7ff73d4171e675cd6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a90f56b153b7ff73d4171e675cd6ad">&#9670;&nbsp;</a></span>getAPIInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbs_1_1_render_a_p_i_info.html">RenderAPIInfo</a>&amp; getAPIInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns information about the specific API implementation. <br />
 </p>
<dl class="section note"><dt>Note</dt><dd>Thread safe. </dd></dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a0ab54829757e2024801388a91d50c8fd">RenderAPI</a>.</p>

</div>
</div>
<a id="ac170bc04c63c72fc9009344424fe2c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac170bc04c63c72fc9009344424fe2c2a">&#9670;&nbsp;</a></span>getBlendMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLint getBlendMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga39e43a2b0694d3f59c3ae3b942651d88">BlendFactor</a>&#160;</td>
          <td class="paramname"><em>blendMode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts Banshee blend mode to OpenGL blend mode. </p>

</div>
</div>
<a id="aad3282e2975492b41bbf98f972802d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3282e2975492b41bbf98f972802d84">&#9670;&nbsp;</a></span>getCombinedMinMipFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint getCombinedMinMipFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a combined min/mip filter value usable by OpenGL from the currently set min and mip filters. </p>

</div>
</div>
<a id="a5df4a1d72d84e82d398d451601113b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df4a1d72d84e82d398d451601113b6d">&#9670;&nbsp;</a></span>getCurrentAnisotropy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat getCurrentAnisotropy </td>
          <td>(</td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>unit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets anisotropy value for the specified texture unit. </p>

</div>
</div>
<a id="ab158c99ca59b6f4a0cb382caf3ad0829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab158c99ca59b6f4a0cb382caf3ad0829">&#9670;&nbsp;</a></span>getGLDrawMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLint getGLDrawMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the OpenGL specific mode used for drawing, depending on the currently set draw operation. </p>

</div>
</div>
<a id="a5099169c5d5949d4a96279844ad545ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5099169c5d5949d4a96279844ad545ad">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbs_1_1_string_i_d.html">StringID</a>&amp; getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the rendering system. <br />
 </p>
<dl class="section note"><dt>Note</dt><dd>Thread safe. </dd></dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a293c9f17a04b517323dcab8d267ad62e">RenderAPI</a>.</p>

</div>
</div>
<a id="afc3395c0aff7c31a98f646f99214ed0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3395c0aff7c31a98f646f99214ed0d">&#9670;&nbsp;</a></span>getTextureAddressingMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLint getTextureAddressingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gab7c99aeb6d200d2b9931c3025ae2ac90">TextureAddressingMode</a>&#160;</td>
          <td class="paramname"><em>tam</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts Banshee texture addressing mode to OpenGL texture addressing mode. </p>

</div>
</div>
<a id="a34f5df02c0dfef87e87a2db53661a970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f5df02c0dfef87e87a2db53661a970">&#9670;&nbsp;</a></span>initCapabilities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initCapabilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbs_1_1_render_a_p_i_capabilities.html">RenderAPICapabilities</a> &amp;&#160;</td>
          <td class="paramname"><em>caps</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates render system capabilities that specify which features are or aren't supported. </p>

</div>
</div>
<a id="a39efbd5b4e840b7a28ab2c210dfe4cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39efbd5b4e840b7a28ab2c210dfe4cc8">&#9670;&nbsp;</a></span>initFromCaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initFromCaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbs_1_1_render_a_p_i_capabilities.html">RenderAPICapabilities</a> *&#160;</td>
          <td class="paramname"><em>caps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish initialization by setting up any systems dependant on render systemcapabilities. </p>

</div>
</div>
<a id="a371caef26098f2a15df9fbee047b58f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371caef26098f2a15df9fbee047b58f2">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the render API system and creates a primary render window. <br />
 </p>
<dl class="section note"><dt>Note</dt><dd>Sim thread only. </dd></dl>

<p>Reimplemented from <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a6365dca5a7d8ddb694726a53b55a4c27">RenderAPI</a>.</p>

</div>
</div>
<a id="a9083c27929f2a6bd82ed2a0a2b85d6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9083c27929f2a6bd82ed2a0a2b85d6e8">&#9670;&nbsp;</a></span>initializeWithWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initializeWithWindow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_window.html">RenderWindow</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>primaryWindow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs (optional) secondary initialization of the render API system. <br />
 </p>
<p>Called after the render window is created. </p>

<p>Reimplemented from <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a4f1e854425d376ef7af76ed83a942c96">RenderAPI</a>.</p>

</div>
</div>
<a id="a819afff698d513660490df02667bc8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819afff698d513660490df02667bc8c0">&#9670;&nbsp;</a></span>makeGLMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void makeGLMatrix </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>gl_matrix</em>[16], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the provided matrix m into a representation usable by OpenGL. </p>

</div>
</div>
<a id="a3707fd8f6d661477c5f191545792872f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3707fd8f6d661477c5f191545792872f">&#9670;&nbsp;</a></span>setAlphaToCoverage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setAlphaToCoverage </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable alpha to coverage. </p>
<p>Alpha to coverage allows you to perform blending without needing to worry about order of rendering like regular blending does. It requires multi-sampling to be active in order to work, and you need to supply an alpha texture that determines object transparency. </p>

</div>
</div>
<a id="abbbf64d820729cb3f379ffed05f2d197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbf64d820729cb3f379ffed05f2d197">&#9670;&nbsp;</a></span>setAntialiasedLineEnable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setAntialiasedLineEnable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables antialiased line rendering. </p>

</div>
</div>
<a id="ac6df480208233f4434e01abfdfd31c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6df480208233f4434e01abfdfd31c86">&#9670;&nbsp;</a></span>setColorBufferWriteEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setColorBufferWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables writing to certain color channels of the render target. </p>

</div>
</div>
<a id="a5c3ee554197454cce52c13421779e3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3ee554197454cce52c13421779e3ac">&#9670;&nbsp;</a></span>setComputePipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setComputePipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_compute_pipeline_state.html">ComputePipelineState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pipelineState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a pipeline state that controls how will subsequent dispatch commands execute. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pipelineState</td><td>Pipeline state to bind, or null to unbind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#af1470f65f420f136d5b01f2a2b0df02c">RenderAPI</a>.</p>

</div>
</div>
<a id="a6ecfa40c4d00bcdcc5175cea8d4a44a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ecfa40c4d00bcdcc5175cea8d4a44a2">&#9670;&nbsp;</a></span>setCullingMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setCullingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga75343d54117298210d7b858147c3486e">CullingMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets vertex winding order. </p>
<p>Normally you would use this to cull back facing polygons. </p>

</div>
</div>
<a id="a4ee5181222596c40ba7bb31bdbb32857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee5181222596c40ba7bb31bdbb32857">&#9670;&nbsp;</a></span>setDepthBias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setDepthBias </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>constantBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>slopeScaleBias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a depth bias that will offset the depth values of new pixels by the specified amount. </p>
<p>Final depth bias value is a combination of the constant depth bias and slope depth bias. Slope depth bias has more effect the higher the slope of the rendered polygon.</p>
<dl class="section note"><dt>Note</dt><dd>This is useful if you want to avoid z fighting for objects at the same or similar depth. </dd></dl>

</div>
</div>
<a id="aaaf4efdd9c96433c7e7f5ecab4024732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf4efdd9c96433c7e7f5ecab4024732">&#9670;&nbsp;</a></span>setDepthBufferCheckEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setDepthBufferCheckEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should new pixels perform depth testing using the set depth comparison function before being written. </p>

</div>
</div>
<a id="a7c3f2f14f6934846a2cc4a618ef5a8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3f2f14f6934846a2cc4a618ef5a8dd">&#9670;&nbsp;</a></span>setDepthBufferFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setDepthBufferFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga36e1a5e792be24b3d1ed4f5fabea818d">CompareFunction</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="group___utility-_core.html#gga36e1a5e792be24b3d1ed4f5fabea818da0d0e567bb16bc64272650e86885e2e58">CMPF_LESS_EQUAL</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets comparison function used for depth testing. </p>
<p>Determines how are new and existing pixel values compared - if comparison function returns true the new pixel is written. </p>

</div>
</div>
<a id="a6e07e030fb67653d80e89aadafb3e1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e07e030fb67653d80e89aadafb3e1cd">&#9670;&nbsp;</a></span>setDepthBufferWriteEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setDepthBufferWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should new pixels write to the depth buffer. </p>

</div>
</div>
<a id="aef83b82057b7d2dcd2e2b7ba6680d3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef83b82057b7d2dcd2e2b7ba6680d3c7">&#9670;&nbsp;</a></span>setDepthClipEnable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setDepthClipEnable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables depth clipping (near/fear plane clipping). </p>

</div>
</div>
<a id="a43ce409ebfc2b11c4844de7940492b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ce409ebfc2b11c4844de7940492b5b">&#9670;&nbsp;</a></span>setDrawOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setDrawOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga0a43fbead35d1ad167d465731c5c4c53">DrawOperationType</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the draw operation that determines how to interpret the elements of the index or vertex buffers. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Draw operation to enable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a70180438d34bfce5c147221ff1448ddf">RenderAPI</a>.</p>

</div>
</div>
<a id="abb90fad9397c2bad313abb1efa523845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb90fad9397c2bad313abb1efa523845">&#9670;&nbsp;</a></span>setGpuParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGpuParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_gpu_params.html">GpuParams</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpuParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a set of parameters that control execution of all currently bound GPU programs. <br />
 </p>
<p>These are the uniforms like textures, samplers, or uniform buffers. Caller is expected to ensure the provided parameters actually match the currently bound programs. </p>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ac882c9af0c546bd2405637a5373c0a99">RenderAPI</a>.</p>

</div>
</div>
<a id="a0d06bc7ba63d82065a37664ad3098434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d06bc7ba63d82065a37664ad3098434">&#9670;&nbsp;</a></span>setGraphicsPipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGraphicsPipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_graphics_pipeline_state.html">GraphicsPipelineState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pipelineState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a pipeline state that controls how will subsequent draw commands render primitives. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pipelineState</td><td>Pipeline state to bind, or null to unbind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbs_1_1ct_1_1_graphics_pipeline_state.html" title="Core thread version of a bs::GraphicsPipelineState. ">GraphicsPipelineState</a> </dd></dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a7d1aae55785c78bfac4e1e8326d34413">RenderAPI</a>.</p>

</div>
</div>
<a id="a631b9a35f09b7ba4135ce2d4fad24f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631b9a35f09b7ba4135ce2d4fad24f2b">&#9670;&nbsp;</a></span>setIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_index_buffer.html">IndexBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets an index buffer to use when drawing. <br />
 </p>
<p>Indices in an index buffer reference vertices in the vertex buffer, which increases cache coherency and reduces the size of vertex buffers by eliminating duplicate data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Index buffer to bind, null to unbind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ae5c209ee82baae076db87065569a5b5b">RenderAPI</a>.</p>

</div>
</div>
<a id="a39a5629b707a52a9269fec2903055717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a5629b707a52a9269fec2903055717">&#9670;&nbsp;</a></span>setMultisamplingEnable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setMultisamplingEnable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables multisample antialiasing. </p>

</div>
</div>
<a id="ae8375e06a6767598601718248d337936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8375e06a6767598601718248d337936">&#9670;&nbsp;</a></span>setPolygonMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setPolygonMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gaa2371b6569c7a782419ffaeb50b97fa7">PolygonMode</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the polygon rasterization mode. </p>
<p>Determines how are polygons interpreted. </p>

</div>
</div>
<a id="af25e6df723f29a5647adced8b644e06d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25e6df723f29a5647adced8b644e06d">&#9670;&nbsp;</a></span>setRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setRenderTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_target.html">RenderTarget</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>readOnlyFlags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbs_1_1_flags.html">RenderSurfaceMask</a>&#160;</td>
          <td class="paramname"><em>loadMask</em> = <code>RT_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the render target into which we want to draw. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Render target to draw to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">readOnlyFlags</td><td>Combination of one or more elements of FrameBufferType denoting which buffers will be bound for read-only operations. This is useful for depth or stencil buffers which need to be bound both for depth/stencil tests, as well as shader reads. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loadMask</td><td>Determines which render target surfaces will have their current contents preserved. By default when a render target is bound its contents will be lost. You might need to preserve contents if you need to perform blending or similar operations with the existing contents of the render target.</td></tr>
  </table>
  </dd>
</dl>
<p>Use the mask to select exactly which surfaces of the render target need their contents preserved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ace358e66fbeec1253cbd3211bbf1e2d1">RenderAPI</a>.</p>

</div>
</div>
<a id="a2720fe1e0a12d4921ecce75677a0de9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2720fe1e0a12d4921ecce75677a0de9f">&#9670;&nbsp;</a></span>setSceneBlending() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setSceneBlending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga39e43a2b0694d3f59c3ae3b942651d88">BlendFactor</a>&#160;</td>
          <td class="paramname"><em>sourceFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga39e43a2b0694d3f59c3ae3b942651d88">BlendFactor</a>&#160;</td>
          <td class="paramname"><em>destFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gad3316ff174eff6a45c45f0e90d84eabe">BlendOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up blending mode that allows you to combine new pixels with pixels already in the render target. </p>
<p>Final pixel value = (renderTargetPixel * sourceFactor) op (pixel * destFactor). </p>

</div>
</div>
<a id="a89fd2a332695b1672b8c68b1369358bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89fd2a332695b1672b8c68b1369358bc">&#9670;&nbsp;</a></span>setSceneBlending() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setSceneBlending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga39e43a2b0694d3f59c3ae3b942651d88">BlendFactor</a>&#160;</td>
          <td class="paramname"><em>sourceFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga39e43a2b0694d3f59c3ae3b942651d88">BlendFactor</a>&#160;</td>
          <td class="paramname"><em>destFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga39e43a2b0694d3f59c3ae3b942651d88">BlendFactor</a>&#160;</td>
          <td class="paramname"><em>sourceFactorAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga39e43a2b0694d3f59c3ae3b942651d88">BlendFactor</a>&#160;</td>
          <td class="paramname"><em>destFactorAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gad3316ff174eff6a45c45f0e90d84eabe">BlendOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gad3316ff174eff6a45c45f0e90d84eabe">BlendOperation</a>&#160;</td>
          <td class="paramname"><em>alphaOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up blending mode that allows you to combine new pixels with pixels already in the render target. </p>
<p>Allows you to set up separate blend operations for alpha values.</p>
<p>Final pixel value = (renderTargetPixel * sourceFactor) op (pixel * destFactor). (And the same for alpha) </p>

</div>
</div>
<a id="aedff3bdfd598d4200f81d7433ac27307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedff3bdfd598d4200f81d7433ac27307">&#9670;&nbsp;</a></span>setScissorRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setScissorRect </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows you to set up a region in which rendering can take place. <br />
 </p>
<p>Coordinates are in pixels. No rendering will be done to render target pixels outside of the provided region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>Left border of the scissor rectangle, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Top border of the scissor rectangle, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Right border of the scissor rectangle, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>Bottom border of the scissor rectangle, in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a9ded76085d80d960bd82a190708ad0d9">RenderAPI</a>.</p>

</div>
</div>
<a id="a1e3a9c6bc9cec50f2d5c162f0dfa941f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3a9c6bc9cec50f2d5c162f0dfa941f">&#9670;&nbsp;</a></span>setStencilBufferFunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setStencilBufferFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga36e1a5e792be24b3d1ed4f5fabea818d">CompareFunction</a>&#160;</td>
          <td class="paramname"><em>func</em> = <code><a class="el" href="group___utility-_core.html#gga36e1a5e792be24b3d1ed4f5fabea818da1824eb412c62c14c1a88bb7d7bf1c688">CMPF_ALWAYS_PASS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>mask</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ccw</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a stencil buffer comparison function. </p>
<p>The result of this will cause one of 3 actions depending on whether the test fails, succeeds but with the depth buffer check still failing, or succeeds with the depth buffer check passing too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Comparison function that determines whether a stencil test fails or passes. Reference value gets compared to the value already in the buffer using this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>The bitmask applied to both the stencil value and the reference value before comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ccw</td><td>If set to true, the stencil operations will be applied to counterclockwise faces. Otherwise they will be applied to clockwise faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7439902077170662260038e74a4098a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7439902077170662260038e74a4098a8">&#9670;&nbsp;</a></span>setStencilBufferOperations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setStencilBufferOperations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gac692ecc1ffb4255c8c8628a3ce6f7a4b">StencilOperation</a>&#160;</td>
          <td class="paramname"><em>stencilFailOp</em> = <code><a class="el" href="group___utility-_core.html#ggac692ecc1ffb4255c8c8628a3ce6f7a4baef34a72d8544151ba9fe07c4ad7c4cde">SOP_KEEP</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gac692ecc1ffb4255c8c8628a3ce6f7a4b">StencilOperation</a>&#160;</td>
          <td class="paramname"><em>depthFailOp</em> = <code><a class="el" href="group___utility-_core.html#ggac692ecc1ffb4255c8c8628a3ce6f7a4baef34a72d8544151ba9fe07c4ad7c4cde">SOP_KEEP</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#gac692ecc1ffb4255c8c8628a3ce6f7a4b">StencilOperation</a>&#160;</td>
          <td class="paramname"><em>passOp</em> = <code><a class="el" href="group___utility-_core.html#ggac692ecc1ffb4255c8c8628a3ce6f7a4baef34a72d8544151ba9fe07c4ad7c4cde">SOP_KEEP</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>front</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows you to set stencil operations that are performed when stencil test passes or fails. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stencilFailOp</td><td>Operation executed when stencil test fails. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depthFailOp</td><td>Operation executed when stencil test succeeds but depth test fails. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">passOp</td><td>Operation executed when stencil test succeeds and depth test succeeds. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">front</td><td>Should the stencil operations be applied to front or back facing polygons. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab248ec6dcb48961719ab624af2caad70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab248ec6dcb48961719ab624af2caad70">&#9670;&nbsp;</a></span>setStencilBufferWriteMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setStencilBufferWriteMask </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>mask</em> = <code>0xFFFFFFFF</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The bitmask applied to the stencil value before writing it to the stencil buffer. </p>

</div>
</div>
<a id="a37af59e072dbfb460f62577df3aaf2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37af59e072dbfb460f62577df3aaf2a2">&#9670;&nbsp;</a></span>setStencilCheckEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setStencilCheckEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns stencil tests on or off. </p>
<p>By default this is disabled. Stencil testing allow you to mask out a part of the rendered image by using various stencil operations provided. </p>

</div>
</div>
<a id="a4d8812da33be62834c28e7933735d279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8812da33be62834c28e7933735d279">&#9670;&nbsp;</a></span>setStencilRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setStencilRef </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a reference value that will be used for stencil compare operations. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Reference value to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a42c3728748c7fd95e861d7d1fc54a482">RenderAPI</a>.</p>

</div>
</div>
<a id="ab2fd7a46de28a5a95e17f2beaa5c3809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2fd7a46de28a5a95e17f2beaa5c3809">&#9670;&nbsp;</a></span>setStencilRefValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setStencilRefValue </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>refValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a reference values used for stencil buffer comparisons. </p>
<p>Actual comparison function and stencil operations are set by setting the <a class="el" href="classbs_1_1ct_1_1_depth_stencil_state.html" title="Core thread version of bs::DepthStencilState. ">DepthStencilState</a>. </p>

</div>
</div>
<a id="a4b119dae0afc8530c24dae5bf8c8f1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b119dae0afc8530c24dae5bf8c8f1b8">&#9670;&nbsp;</a></span>setTextureAddressingMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setTextureAddressingMode </td>
          <td>(</td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbs_1_1_u_v_w_addressing_mode.html">UVWAddressingMode</a> &amp;&#160;</td>
          <td class="paramname"><em>uvw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the texture addressing mode for a texture unit. </p>
<p>This determines how are UV address values outside of [0, 1] range handled when sampling from texture. </p>

</div>
</div>
<a id="a602f1af68819b39fff403abce64df5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602f1af68819b39fff403abce64df5b2">&#9670;&nbsp;</a></span>setTextureAnisotropy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setTextureAnisotropy </td>
          <td>(</td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>maxAnisotropy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets anisotropy value for the specified texture unit. </p>

</div>
</div>
<a id="a6d32bce1d55573801ea8a41081a46fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d32bce1d55573801ea8a41081a46fb0">&#9670;&nbsp;</a></span>setTextureBorderColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setTextureBorderColor </td>
          <td>(</td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_color.html">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the texture border color for a texture unit. </p>
<p>Border color determines color returned by the texture sampler when border addressing mode is used and texture address is outside of [0, 1] range. </p>

</div>
</div>
<a id="a1d57b8bb3dd771fc8068c45f7e4f6780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d57b8bb3dd771fc8068c45f7e4f6780">&#9670;&nbsp;</a></span>setTextureFiltering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setTextureFiltering </td>
          <td>(</td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga7ef0ab496f57e183b484e62e2053c94f">FilterType</a>&#160;</td>
          <td class="paramname"><em>ftype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___utility-_core.html#ga7f1dfeea870eec2a3f18186ad02bc817">FilterOptions</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows you to specify how is the texture bound to the specified texture unit filtered. </p>
<p>Different filter types are used for different situations like magnifying or minifying a texture. </p>

</div>
</div>
<a id="a78ed2c0963a3b362e946c83bb83417bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ed2c0963a3b362e946c83bb83417bc">&#9670;&nbsp;</a></span>setTextureMipmapBias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setTextureMipmapBias </td>
          <td>(</td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the mipmap bias value for a given texture unit. </p>
<p>Bias allows you to adjust the mipmap selection calculation. Negative values force a larger mipmap to be used, and positive values smaller. Units are in values of mip levels, so -1 means use a mipmap one level higher than default. </p>

</div>
</div>
<a id="ae60eaf8f86ab808b8cfca1356c1167fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60eaf8f86ab808b8cfca1356c1167fa">&#9670;&nbsp;</a></span>setTextureMipmapRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setTextureMipmapRange </td>
          <td>(</td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a valid range for mipmaps (LOD) for a given texture unit. </p>
<p><code>min</code> limits the selection of the highest resolution mipmap (lowest level), and <code>max</code> limits the selection of the lowest resolution mipmap (highest level). </p>

</div>
</div>
<a id="ac6fd1d924e30098801bdb8fc72df380b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fd1d924e30098801bdb8fc72df380b">&#9670;&nbsp;</a></span>setVertexBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setVertexBuffers </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vertex_buffer.html">VertexBuffer</a> &gt; *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the provided vertex buffers starting at the specified source index. <br />
 </p>
<p>Set buffer to nullptr to clear the buffer at the specified index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index at which to start binding the vertex buffers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffers</td><td>A list of buffers to bind to the pipeline. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBuffers</td><td>Number of buffers in the <code>buffers</code> list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ab0e37a2417121c9cd5af10c81dc334ce">RenderAPI</a>.</p>

</div>
</div>
<a id="abc2f84b7fd7ec04c7de0073f923fcdb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2f84b7fd7ec04c7de0073f923fcdb6">&#9670;&nbsp;</a></span>setVertexDeclaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setVertexDeclaration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_vertex_declaration.html">VertexDeclaration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexDeclaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the vertex declaration to use when drawing. <br />
 </p>
<p>Vertex declaration is used to decode contents of a single vertex in a vertex buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexDeclaration</td><td>Vertex declaration to bind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a0e6be919aec953bca0fad3f824645d18">RenderAPI</a>.</p>

</div>
</div>
<a id="afc830dd83363d37c5d07f055b0e4b84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc830dd83363d37c5d07f055b0e4b84f">&#9670;&nbsp;</a></span>setViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setViewport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbs_1_1_rect2.html">Rect2</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the active viewport that will be used for all render operations. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Area of the viewport, in normalized ([0,1] range) coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Optional command buffer to queue the operation on. If not provided operation is executed immediately. Otherwise it is executed when executeCommands() is called. Buffer must support graphics operations. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#afd7a3caf480306534477ca6b8ff4574f">RenderAPI</a>.</p>

</div>
</div>
<a id="a4028d9ce0fd012246b961b6751a764b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4028d9ce0fd012246b961b6751a764b2">&#9670;&nbsp;</a></span>submitCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void submitCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_command_buffer.html">CommandBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>syncMask</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes all commands in the provided command buffer. <br />
 </p>
<p>Command buffer cannot be secondary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandBuffer</td><td>Command buffer whose commands to execute. Set to null to submit the main command buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">syncMask</td><td>Optional synchronization mask that determines if the submitted command buffer depends on any other command buffers. Use the <a class="el" href="classbs_1_1ct_1_1_command_sync_mask.html" title="Mask that determines synchronization between command buffers executing on different hardware queues...">CommandSyncMask</a> class to generate a mask using existing command buffers.</td></tr>
  </table>
  </dd>
</dl>
<p>This mask is only relevant if your command buffers are executing on different hardware queues, and are somehow dependant. If they are executing on the same queue (default) then they will execute sequentially in the order they are submitted. Otherwise, if there is a dependency, you must make state it explicitly here.</p>
<dl class="section note"><dt>Note</dt><dd>Core thread only. </dd></dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a86bdd357983b845df4c0a070ed47669b">RenderAPI</a>.</p>

</div>
</div>
<a id="a45aa4fc19ef23ccacb2ad0de3b7d449e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45aa4fc19ef23ccacb2ad0de3b7d449e">&#9670;&nbsp;</a></span>swapBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swapBuffers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_render_target.html">RenderTarget</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>syncMask</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the front and back buffer of the specified render target. <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Render target to perform the buffer swap on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">syncMask</td><td>Optional synchronization mask that determines for which queues should the system wait before performing the swap buffer operation. By default the system waits for all queues. However if certain queues are performing non-rendering operations, or operations not related to the provided render target, you can exclude them from the sync mask for potentially better performance. You can use <a class="el" href="classbs_1_1ct_1_1_command_sync_mask.html" title="Mask that determines synchronization between command buffers executing on different hardware queues...">CommandSyncMask</a> to generate a valid sync mask. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a0d047892af237e2bc3c3d0a73e2bb888">RenderAPI</a>.</p>

</div>
</div>
<a id="a6e3df2d89acfa9230e53dcf9a81129dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3df2d89acfa9230e53dcf9a81129dd">&#9670;&nbsp;</a></span>switchContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void switchContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; <a class="el" href="classbs_1_1ct_1_1_g_l_context.html">GLContext</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbs_1_1ct_1_1_render_window.html">RenderWindow</a> &amp;&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch the currently used OpenGL context. </p>
<p>You will need to re-bind any previously bound values manually (for example textures, gpu programs and such). </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
