<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - Advanced RTTI</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='https://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Advanced RTTI </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#advancedRtti_a">Manually defining fields</a><ul><li class="level2"><a href="#advancedRtti_a_a">Plain fields</a></li>
<li class="level2"><a href="#advancedRtti_a_b">Reflectable fields</a></li>
<li class="level2"><a href="#advancedRtti_a_c">Reflectable pointer fields</a></li>
<li class="level2"><a href="#advancedRtti_a_d">Array fields</a></li>
</ul>
</li>
<li class="level1"><a href="#advancedRtti_b">Advanced plain fields</a></li>
<li class="level1"><a href="#advancedRtti_c">Querying RTTI</a></li>
<li class="level1"><a href="#advancedRtti_d">Advanced serialization</a></li>
</ul>
</div>
<div class="textblock"><p>This manual is a continuation of the <a class="el" href="serializing_objects.html">Persisting data</a> manual, focusing on some more advanced features of the RTTI system.</p>
<h1><a class="anchor" id="advancedRtti_a"></a>
Manually defining fields</h1>
<p>Previously we have shown how to define RTTI member fields by using the BS_RTTI_MEMBER_* macros. While this method is in most cases preferable, it might not be useful if more advanced functionality is required. The macro approach is only able to reference class fields directly, but sometimes we might wish to access data returned by a method, or we might want to process the data in some way (e.g. compressing it).</p>
<p>We can do this by manually defining fields. In order to manually register fields the systems supports a several sets of <code>add*Field</code> methods, each expecting a unique name/id, and a pair of getter/setter methods. The getter/setter methods can then be used for any more advanced processing.</p>
<h2><a class="anchor" id="advancedRtti_a_a"></a>
Plain fields</h2>
<p>You register plain fields by calling <a class="el" href="classbs_1_1_r_t_t_i_type.html#a65b0e9c4be1ade14ff9ac4e6cac68a5f">RTTIType::addPlainField()</a>. The getter/setter methods must return/accept a reference to the value of the field.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyComponent : <span class="keyword">public</span> <a class="code" href="group___physics.html#gga7cb6db30c601dfbec9036428d0e49d33a2cb05e4bb7830be982f0922fed86b4cd">Component</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    UINT32 myInt;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>MyComponentRTTI : <span class="keyword">public</span> RTTIType&lt;MyComponent, Component, MyComponentRTTI&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UINT32&amp; getMyInt(MyComponent* obj) { <span class="keywordflow">return</span> obj-&gt;myInt; }</div><div class="line">    <span class="keywordtype">void</span> setMyInt(MyComponent* obj, UINT32&amp; value) { obj-&gt;myInt = value; }</div><div class="line"></div><div class="line">    MyComponentRTTI ()</div><div class="line">    {</div><div class="line">        <span class="comment">// Register the getter/setter methods above. You must specify a name and field id (both must be unique within the type).</span></div><div class="line">        addPlainField(<span class="stringliteral">&quot;myInt&quot;</span>, 0, &amp;MyComponentRTTI::getMyInt, &amp;MyComponentRTTI::setMyInt);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// ... </span></div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="advancedRtti_a_b"></a>
Reflectable fields</h2>
<p>The reflectable field getter/setter signature is similar to the plain field one, only the <a class="el" href="classbs_1_1_r_t_t_i_type.html#a620f2f969e2bfbb2e294b3333c373478">RTTIType::addReflectableField()</a> method is used for registration instead.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyComponent : <span class="keyword">public</span> <a class="code" href="group___physics.html#gga7cb6db30c601dfbec9036428d0e49d33a2cb05e4bb7830be982f0922fed86b4cd">Component</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    HMesh mesh;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>MyComponentRTTI : <span class="keyword">public</span> RTTIType&lt;MyComponent, Component, MyComponentRTTI&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    HMesh&amp; getMesh(MyComponent* obj) { <span class="keywordflow">return</span> obj-&gt;mesh; }</div><div class="line">    <span class="keywordtype">void</span> setMesh(MyComponent* obj, HMesh&amp; value) { obj-&gt;mesh = value; }</div><div class="line"></div><div class="line">    MyComponentRTTI ()</div><div class="line">    {</div><div class="line">        addReflectableField(<span class="stringliteral">&quot;mesh&quot;</span>, 0, &amp;MyComponentRTTI::getMesh, &amp;MyComponentRTTI::setMesh);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// ... </span></div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="advancedRtti_a_c"></a>
Reflectable pointer fields</h2>
<p>Reflectable pointer getter/setter methods must return shared pointers to the instance, and they're registered with <a class="el" href="classbs_1_1_r_t_t_i_type.html#a284860bab39aba61795c749705272eb5">RTTIType::addReflectablePtrField()</a>. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyClass : <span class="keyword">public</span> IReflectable</div><div class="line">{</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">class </span>MyComponent : <span class="keyword">public</span> <a class="code" href="group___physics.html#gga7cb6db30c601dfbec9036428d0e49d33a2cb05e4bb7830be982f0922fed86b4cd">Component</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    SPtr&lt;MyClass&gt; myClass;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>MyComponentRTTI : <span class="keyword">public</span> RTTIType&lt;MyComponent, Component, MyComponentRTTI&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    SPtr&lt;MyClass&gt; getMyClass(MyComponent* obj) { <span class="keywordflow">return</span> obj-&gt;myClass; }</div><div class="line">    <span class="keywordtype">void</span> setMyClass(MyComponent* obj, SPtr&lt;MyClass&gt; value) { obj-&gt;myClass = value; }</div><div class="line"></div><div class="line">    MyComponentRTTI ()</div><div class="line">    {</div><div class="line">        addReflectablePtrField(<span class="stringliteral">&quot;myClass&quot;</span>, 0, &amp;MyComponentRTTI::getMyClass, &amp;MyComponentRTTI::setMyClass);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// ... </span></div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="advancedRtti_a_d"></a>
Array fields</h2>
<p>Each of the valid field types (plain/reflectable/reflectable pointer), also come in array form. The array form requires two additional getter/setter methods that get/set array size, and normal getter/setter methods require an additional index parameter.</p>
<p>Methods for registering array fields are:</p><ul>
<li><a class="el" href="classbs_1_1_r_t_t_i_type.html#a72d69a3f3d84c416a691a10e2e7e8224">RTTIType::addPlainArrayField()</a></li>
<li><a class="el" href="classbs_1_1_r_t_t_i_type.html#a73868b51979a1048eeb96679f18ac937">RTTIType::addReflectableArrayField()</a></li>
<li><a class="el" href="classbs_1_1_r_t_t_i_type.html#ab2ba3fbc9a0fa2c86f5016b677b221f1">RTTIType::addReflectablePtrArrayField()</a></li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyComponent : <span class="keyword">public</span> <a class="code" href="group___physics.html#gga7cb6db30c601dfbec9036428d0e49d33a2cb05e4bb7830be982f0922fed86b4cd">Component</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    Vector&lt;HMesh&gt; meshes;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>MyComponentRTTI : <span class="keyword">public</span> RTTIType&lt;MyComponent, Component, MyComponentRTTI&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    HMesh&amp; getMesh(MyComponent* obj, UINT32 idx) { <span class="keywordflow">return</span> obj-&gt;meshes[idx]; }</div><div class="line">    <span class="keywordtype">void</span> setMesh(MyComponent* obj, HMesh&amp; value, UINT32 idx) { obj-&gt;meshes[idx] = value; }</div><div class="line"></div><div class="line">    UINT32 getNumMeshes(MyComponent* obj) { <span class="keywordflow">return</span> obj-&gt;meshes.size(); }</div><div class="line">    <span class="keywordtype">void</span> setNumMeshes(MyComponent* obj, UINT32 size) { obj-&gt;meshes.resize(size); }</div><div class="line"></div><div class="line">    MyComponentRTTI ()</div><div class="line">    {</div><div class="line">        addReflectablePtrArrayField(<span class="stringliteral">&quot;meshes&quot;</span>, 0, &amp;MyComponentRTTI::getMesh, &amp;MyComponentRTTI::getNumMeshes, </div><div class="line">            &amp;MyComponentRTTI::setMesh, &amp;MyComponentRTTI::setNumMeshes);</div><div class="line"></div><div class="line">        <span class="comment">// And similarly for other field types</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// ... </span></div><div class="line">};</div></div><!-- fragment --><blockquote class="doxtable">
<p>By using this form of field definitions you are also no longer limited to arrays only contained with the <b>Vector</b> container. </p>
</blockquote>
<h1><a class="anchor" id="advancedRtti_b"></a>
Advanced plain fields</h1>
<p>Although plain fields are primarily intended for simple built-in types, sometimes they also need to be used on complex types. For example a <b>std::string</b> is often used as a field type, but it is not a simple built-in type, nor can we make it derive from <b>IReflectable</b>. For these purposes you can use <a class="el" href="structbs_1_1_r_t_t_i_plain_type.html">RTTIPlainType&lt;T&gt;</a>. This is a templated class you can specialize for your specific type.</p>
<p>Once you specialize the class for your type, implementing all the required methods, you will then be able to use your type on plain fields in the RTTI class. Without this specialization the system will refuse to compile the RTTI type.</p>
<p>The specialization involves implementing methods for serializing/deserializing and retrieving object size. It has no advanced functionality like versioning (so if the structure of the type changes, it will break any previously serialized data), or keeping references to other objects.</p>
<p>For example if we wanted to serialize a string: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>RTTIPlainType&lt;<a class="code" href="namespacestd.html">std</a>::string&gt;</div><div class="line">{   </div><div class="line">    <span class="keyword">enum</span> { <span class="keywordtype">id</span> = 20 }; <span class="keyword">enum</span> { hasDynamicSize = 1 }; <span class="comment">// Provide unique ID, and a flag whether the size of the structure is dynamic.</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> toMemory(<span class="keyword">const</span> std::string&amp; data, <span class="keywordtype">char</span>* memory)</div><div class="line">    { </div><div class="line">        UINT32 size = getDynamicSize(data);</div><div class="line"></div><div class="line">        memcpy(memory, &amp;size, <span class="keyword">sizeof</span>(UINT32));</div><div class="line">        memory += <span class="keyword">sizeof</span>(UINT32);</div><div class="line">        size -= <span class="keyword">sizeof</span>(UINT32);</div><div class="line">        memcpy(memory, data.data(), size); </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> UINT32 fromMemory(std::string&amp; data, <span class="keywordtype">char</span>* memory)</div><div class="line">    { </div><div class="line">        UINT32 size;</div><div class="line">        memcpy(&amp;size, memory, <span class="keyword">sizeof</span>(UINT32)); </div><div class="line">        memory += <span class="keyword">sizeof</span>(UINT32);</div><div class="line"></div><div class="line">        UINT32 stringSize = size - <span class="keyword">sizeof</span>(UINT32);</div><div class="line">        data = std::string(memory, stringSize);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> size;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> UINT32 getDynamicSize(<span class="keyword">const</span> std::string&amp; data)   </div><div class="line">    { </div><div class="line">        UINT64 dataSize = data.size() * <span class="keyword">sizeof</span>(std::string::value_type) + <span class="keyword">sizeof</span>(UINT32);</div><div class="line">        <span class="keywordflow">return</span> (UINT32)dataSize;</div><div class="line">    }   </div><div class="line">}; </div></div><!-- fragment --><blockquote class="doxtable">
<p>Note: bs::f already provides many of such specializations, including ones for strings, vectors and maps. </p>
</blockquote>
<p>Each specialization must implement all three <b>toMemory()</b>, <b>fromMemory()</b> and <b>getDynamicSize()</b> methods. It must also provide a flag <b>hasDynamicSize</b> which determines whether or not it has dynamic size. Any structure whose size varies with each instance (like a string) must set this flag to true. You must also set it to true if the size is static but larger than 255 bytes.</p>
<p>After the specialization is implemented you will be able to use the type in getters/setters for plain fields as you would <em>int</em> or <em>float</em>.</p>
<p>For very simple classes you can also use the <a class="el" href="group___r_t_t_i.html#ga50db378ae7a89c0f117c81c8d364cd22">BS_ALLOW_MEMCPY_SERIALIZATION</a> macro instead. It will create a basic <b>RTTIPlainType&lt;T&gt;</b> specialization which uses <em>memcpy()</em> and <em>sizeof()</em> to implement the necessary methods.</p>
<div class="fragment"><div class="line"><span class="comment">// Simple plain old data type</span></div><div class="line"><span class="keyword">struct </span>SimpleData</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> some;</div><div class="line">    <span class="keywordtype">float</span> data;</div><div class="line">    <span class="keywordtype">float</span> here;</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="group___r_t_t_i.html#ga50db378ae7a89c0f117c81c8d364cd22">BS_ALLOW_MEMCPY_SERIALIZATION</a>(SimpleData)</div></div><!-- fragment --><p><b>RTTIPlainType</b> specializations can also be used as a more traditional form of serialization in case you find the RTTI system an overkill. For example if you needed to transfer data over a network and don't require advanced versioning features. The system provides helper methods that allow you to easily work with plain types in such a case:</p><ul>
<li><a class="el" href="group___r_t_t_i.html#ga4b0469ba3081cd9ddefb77efe177f862">rttiReadElem()</a> - Deserializes an object from the provided buffer and returns offset into the buffer after the read data</li>
<li><a class="el" href="group___r_t_t_i.html#gaf3b4188e84935159696af9fe97de503f">rttiWriteElem()</a> - Serializes an object into the provided buffer and returns offset into the buffer after the written data</li>
<li><a class="el" href="group___r_t_t_i.html#ga2ee64a2167a4fa8d74d99f6566b010cc">rttiGetElemSize()</a> - Returns a size an object</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Assuming Vector has a RTTIPlainType&lt;T&gt; specialization (which it has, bs::f provides it by default)</span></div><div class="line"></div><div class="line">Vector&lt;SimpleData&gt; myData;</div><div class="line"><span class="comment">// fill out myData</span></div><div class="line"></div><div class="line"><span class="comment">// Simply serialize the entire vector and all of its contents</span></div><div class="line">UINT32 size = <a class="code" href="group___r_t_t_i.html#ga2ee64a2167a4fa8d74d99f6566b010cc">rttiGetElemSize</a>(myData);</div><div class="line">UINT8* data = (UINT8*)<a class="code" href="group___memory.html#gab73a1dcfe655924d94f54e9df327e8e3">bs_alloc</a>(size);</div><div class="line"><a class="code" href="group___r_t_t_i.html#gaf3b4188e84935159696af9fe97de503f">rttiWriteElem</a>(myData, data);</div><div class="line"></div><div class="line"><span class="comment">// Simply deserialize the data</span></div><div class="line">Vector&lt;SimpleData&gt; myDataCopy;</div><div class="line"><a class="code" href="group___r_t_t_i.html#ga4b0469ba3081cd9ddefb77efe177f862">rttiReadElem</a>(myDataCopy, data);</div><div class="line"></div><div class="line"><a class="code" href="group___memory.html#ga0c82945f631c4a07c3085b3f79046a87">bs_free</a>(data);</div></div><!-- fragment --><h1><a class="anchor" id="advancedRtti_c"></a>
Querying RTTI</h1>
<p>Aside from using RTTI for serialization, you can also use it to manually query various information about objects.</p>
<p>Global queries:</p><ul>
<li><a class="el" href="group___r_t_t_i.html#ga47005b30a7bcd500c107e381483f1ba0">rtti_is_of_type&lt;T&gt;()</a> - Checks is a specific object of type <em>T</em></li>
<li><a class="el" href="group___r_t_t_i.html#ga95e43021544200f240102893f41e4eed">rtti_is_subclass&lt;T&gt;()</a> - Checks is a specific object derived from type <em>T</em></li>
<li><a class="el" href="group___r_t_t_i.html#ga476d9ab59f3da41184283cdaf90a9e50">rtti_create()</a> - Creates a new object from its type ID</li>
</ul>
<p><b>IReflectable</b> queries:</p><ul>
<li><a class="el" href="classbs_1_1_i_reflectable.html#a98e2705ee1aa41cb9fc53f7af322c780">IReflectable::getTypeName()</a> - Gets the name of the object's type</li>
<li><a class="el" href="classbs_1_1_i_reflectable.html#aa6032c8032ae82d1905740e8c0b5844d">IReflectable::getTypeId()</a> - Gets the type ID of the object's type</li>
</ul>
<p><b>RTTIType</b> queries:</p><ul>
<li><a class="el" href="classbs_1_1_r_t_t_i_type_base.html#acee3b82687404342a98330d7f62d3251">RTTITypeBase::getBaseClass()</a> - Returns the <b>RTTIType</b> object of the base class</li>
<li><a class="el" href="classbs_1_1_r_t_t_i_type_base.html#a0efa803c6eb08c593d30431744a2b3ad">RTTITypeBase::getDerivedClasses()</a> - Returns a list of <b>RTTIType</b>s for all derived classes</li>
<li><a class="el" href="classbs_1_1_r_t_t_i_type_base.html#ade0f4f6e193888301800940468c2e13a">RTTITypeBase::getNumFields()</a> - Returns the number of member fields</li>
<li><a class="el" href="classbs_1_1_r_t_t_i_type_base.html#a68226bb716b8bc9b92e666702ab673ea">RTTITypeBase::getField()</a> - Returns information about a field from its sequential index, in the form of <a class="el" href="structbs_1_1_r_t_t_i_field.html">RTTIField</a></li>
<li><a class="el" href="classbs_1_1_r_t_t_i_type_base.html#ab4509e820121c81fc48017ec4adb5ed6">RTTITypeBase::findField()</a> - Searches for a field with a specific name and returns information about it in form of <b>RTTIField</b></li>
</ul>
<p><b>RTTIField</b> queries:</p><ul>
<li><a class="el" href="structbs_1_1_r_t_t_i_field.html#ac23cee4847e888ae317b35d032e5a4db">RTTIField::isPlainType()</a> - Checks if field contains a plain data type. <b>RTTIField</b> can then be cast to <a class="el" href="structbs_1_1_r_t_t_i_plain_field_base.html">RTTIPlainFieldBase</a> for more operations.</li>
<li><a class="el" href="structbs_1_1_r_t_t_i_field.html#a2ed2d9e24301e647ffb01bc4d1867b67">RTTIField::isReflectableType()</a> - Checks if field contains an <b>IReflectable</b> data type. <b>RTTIField</b> can then be cast to <a class="el" href="structbs_1_1_r_t_t_i_reflectable_field_base.html">RTTIReflectableFieldBase</a> for more operations.</li>
<li><a class="el" href="structbs_1_1_r_t_t_i_field.html#a2c6b62a1286ec5f6c4e590eef8ea9fab">RTTIField::isReflectablePtrType()</a> - Checks if field contains an <b>IReflectable</b> pointer data type. <b>RTTIField</b> can then be cast to <a class="el" href="structbs_1_1_r_t_t_i_reflectable_ptr_field_base.html">RTTIReflectablePtrFieldBase</a> for more operations.</li>
<li><a class="el" href="structbs_1_1_r_t_t_i_field.html#aefe7cc24045c3560d7550ba662375ce4">RTTIField::isArray()</a> - Checks if the field contains an array or a single value</li>
</ul>
<div class="fragment"><div class="line">IReflectable* myObject = ...;</div><div class="line"></div><div class="line">rtti_is_of_type&lt;Texture&gt;(myObject);</div><div class="line">rtti_is_subclass&lt;Texture&gt;(myObject);</div><div class="line"><a class="code" href="group___r_t_t_i.html#ga476d9ab59f3da41184283cdaf90a9e50">rtti_create</a>(TID_Texture);</div><div class="line"></div><div class="line">myObject-&gt;getTypeName();</div><div class="line">myObject-&gt;getTypeId();</div><div class="line"></div><div class="line">RTTITypeBase* rttiType = myObject-&gt;getRTTI();</div><div class="line">rttiType-&gt;getBaseClass();</div><div class="line">rttiType-&gt;getDerivedClasses();</div><div class="line">rttiType-&gt;getNumFields();</div><div class="line">rttiType-&gt;getField(index);</div><div class="line"></div><div class="line">RTTIField* rttiField = rttiType-&gt;findField(name);</div><div class="line">rttiField-&gt;isPlainType();</div><div class="line">rttiField-&gt;isReflectableType();</div><div class="line">rttiField-&gt;isReflectablePtrType();</div><div class="line">rttiField-&gt;isArray();</div></div><!-- fragment --><p>Once you have an instance of a <b>RTTIField</b> object, you can also use it to directly read and write values on object instances for that particular field.</p>
<h1><a class="anchor" id="advancedRtti_d"></a>
Advanced serialization</h1>
<p>When implementing <b>RTTIType&lt;Type, BaseType, MyRTTIType&gt;</b> can optionally override any of these methods, for additional functionality:</p><ul>
<li><a class="el" href="classbs_1_1_r_t_t_i_type_base.html#adeaa51e6ebb01faf6d3958e58fa5545a">RTTIType::onSerializationStarted</a></li>
<li><a class="el" href="classbs_1_1_r_t_t_i_type_base.html#af445f3a985ff585777827e635a3c29cb">RTTIType::onSerializationEnded</a></li>
<li><a class="el" href="classbs_1_1_r_t_t_i_type_base.html#a40c3ac3c509fd3ee4d6a4f4dc32eddee">RTTIType::onDeserializationStarted</a></li>
<li><a class="el" href="classbs_1_1_r_t_t_i_type_base.html#ab2ec34db6685c2a2c7ff617a7d83cf31">RTTIType::onDeserializationEnded</a></li>
</ul>
<p>As their names imply they will get called during serialization/deserialization and allow you to do any pre- or post-processing of the data. Each of those methods accepts an <b>IReflectable</b> pointer to the object currently being processed. Each type that implements <b>IReflectable</b> also comes with a <em>mRTTIData</em> field which is of <b>Any</b> type, and can be used for storing temporary data during serialization/deserialization (primarily when using the methods above). </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
