<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - Geometry</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='http://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="../SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="../SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Geometry </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#geometry_a">Vertex buffer</a></li>
<li class="level1"><a href="#geometry_b">Vertex declaration</a></li>
<li class="level1"><a href="#geometry_c">Index buffer</a></li>
<li class="level1"><a href="#geometry_d">Geometry from meshes</a></li>
</ul>
</div>
<div class="textblock"><p>In this chapter we'll show how is geometry of an object represented, and how to bind that geometry to be rendered. The geometry is represented using three object types:</p><ul>
<li><a class="el" href="classbs_1_1ct_1_1_vertex_buffer.html">ct::VertexBuffer</a> - Contains per-vertex information</li>
<li><a class="el" href="classbs_1_1ct_1_1_vertex_declaration.html">ct::VertexDeclaration</a> - Contains meta-data about which properties each entry in the vertex buffer contains</li>
<li><a class="el" href="classbs_1_1ct_1_1_index_buffer.html">ct::IndexBuffer</a> - Contains a list of indices that map into the vertex buffer and determine in what order are vertices assembled into primitives (triangles, lines or points)</li>
</ul>
<h1><a class="anchor" id="geometry_a"></a>
Vertex buffer</h1>
<p><b>ct::VertexBuffer</b> is a buffer that contains all vertices of the object we wish to render. When drawing the vertices will be interpreted as primitives (either points, lines or triangles) and rendered. Each vertex can have one or multiple properties associated with it.</p>
<p>To create a vertex buffer call <a class="el" href="classbs_1_1ct_1_1_vertex_buffer.html#a3cac3cfb48871b016e5c706495a146c7">ct::VertexBuffer::create()</a> with a populated <a class="el" href="structbs_1_1_v_e_r_t_e_x___b_u_f_f_e_r___d_e_s_c.html">VERTEX_BUFFER_DESC</a> structure. You need to know the size of an individual vertex (determined by the properties each vertex requires) and the number of vertices.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a vertex buffer containing 8 vertices with just a vertex position (3D float)</span></div><div class="line">VERTEX_BUFFER_DESC desc;</div><div class="line">desc.vertexSize = <span class="keyword">sizeof</span>(Vector3);</div><div class="line">desc.numVerts = 8;</div><div class="line"></div><div class="line">SPtr&lt;VertexBuffer&gt; vb = VertexBuffer::create(desc);</div></div><!-- fragment --><p>Once the vertex buffer is created you will want to populate it with some data. For this you can use any of the following methods:</p><ul>
<li><a class="el" href="classbs_1_1_hardware_buffer.html#a0cbc193b72c0af3780c5f354dd4c821f">ct::VertexBuffer::lock()</a> - Locks a specific region of the vertex buffer and returns a pointer you can then use for reading and writing. Make sure to specify valid a <a class="el" href="group___utility-_core.html#gab3f183d1c687b60796c72dda0073e2f3">GpuLockOptions</a> signaling whether you are planning on reading or writing from the buffer. Once done call <a class="el" href="classbs_1_1_hardware_buffer.html#ae6f018536d482152b993f522d8d2942d">ct::VertexBuffer::unlock()</a> to make the locked region accessible to the GPU again.</li>
<li><a class="el" href="classbs_1_1_hardware_buffer.html#aed63b4da7c915f4b42e08824c4e60020">ct::VertexBuffer::writeData()</a> - Writes an entire block of memory at once.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Fill out a vertex buffer using lock/unlock approach</span></div><div class="line">Vector3* positions = (Vector3*)vb-&gt;lock(0, <span class="keyword">sizeof</span>(Vector3) * 8, <a class="code" href="group___utility-_core.html#ggab3f183d1c687b60796c72dda0073e2f3a4d94aea3fb84bffe6f60092392f05c79">GBL_WRITE_ONLY_DISCARD</a>);</div><div class="line">positions[0] = Vector3(0, 0, 0);</div><div class="line">positions[1] = Vector3(10, 0, 0);</div><div class="line"><span class="comment">// ... assign other 6 positions</span></div><div class="line">vb-&gt;unlock();</div></div><!-- fragment --><p>Once a vertex buffer is created and populated with data, you can bind it to the pipeline by calling <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ab0e37a2417121c9cd5af10c81dc334ce">ct::RenderAPI::setVertexBuffers()</a>. You can bind one or multiple vertex buffers at once. If binding multiple vertex buffers they must all share the same vertex count, but each may contain different vertex properties (e.g. one might contain just positions and UV, while another might contain tangents and normals).</p>
<div class="fragment"><div class="line"><span class="comment">// Bind a single vertex buffer</span></div><div class="line">RenderAPI&amp; rapi = RenderAPI::instance();</div><div class="line">rapi.setVertexBuffers(0, { vb });</div></div><!-- fragment --><h1><a class="anchor" id="geometry_b"></a>
Vertex declaration</h1>
<p>Before vertex buffer(s) can be used for rendering, you need to tell the pipeline what kind of information does each vertex in the vertex buffer(s) contain. This information lets the GPU know how to map per-vertex properties like position &amp; UV coordinates, to vertex GPU program inputs. This is done by creating a <a class="el" href="classbs_1_1ct_1_1_vertex_declaration.html">ct::VertexDeclaration</a> object.</p>
<p>In order to create one you call <a class="el" href="classbs_1_1ct_1_1_vertex_declaration.html#a8e6a511be81652204fb28b60062ce45c">ct::VertexDeclaration::create()</a> which accepts a <b>VertexDataDesc</b> as its parameter. We already explained to how create a <b>VertexDataDesc</b> in the <a class="el" href="creating_meshes.html">Advanced meshes</a> manual.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a vertex descriptor with a position, normal and UV coordinates</span></div><div class="line">SPtr&lt;VertexDataDesc&gt; vertexDesc = VertexDataDesc::create();</div><div class="line">vertexDesc-&gt;addVertElem(<a class="code" href="group___render_a_p_i.html#ggaff1f9fa06412cc13e0917617b7e8d0b3ae4a5d54927b375d5a3225252b46b7666">VET_FLOAT3</a>, <a class="code" href="group___render_a_p_i.html#ggaefea8c317b80104ca23292be815de16ca0544fdfda9308d37ae798590df511a18">VES_POSITION</a>);</div><div class="line">vertexDesc-&gt;addVertElem(<a class="code" href="group___render_a_p_i.html#ggaff1f9fa06412cc13e0917617b7e8d0b3ae4a5d54927b375d5a3225252b46b7666">VET_FLOAT3</a>, <a class="code" href="group___render_a_p_i.html#ggaefea8c317b80104ca23292be815de16ca8d273162b7f0c19183569f06985f72b9">VES_NORMAL</a>);</div><div class="line">vertexDesc-&gt;addVertElem(<a class="code" href="group___render_a_p_i.html#ggaff1f9fa06412cc13e0917617b7e8d0b3a8b7f33799c43b79dc274e1bdc0b98a4a">VET_FLOAT2</a>, <a class="code" href="group___render_a_p_i.html#ggaefea8c317b80104ca23292be815de16cacfca9b06a791a26a6b4031d191a690a5">VES_TEXCOORD</a>);</div><div class="line"></div><div class="line"><span class="comment">// Create a vertex declaration</span></div><div class="line">SPtr&lt;VertexDeclaration&gt; vertexDecl = VertexDeclaration::create(vertexDesc);</div></div><!-- fragment --><p>If you are binding multiple vertex buffers, then make use of the <code>streamIdx</code> parameter when registering elements in <b>VertexDataDesc</b>. This index will let the pipeline know in which vertex buffer to find the provided element.</p>
<p>Once created you can bind the declaration to the pipeline by calling <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#a0e6be919aec953bca0fad3f824645d18">ct::RenderAPI::setVertexDeclaration()</a>.</p>
<div class="fragment"><div class="line">RenderAPI&amp; rapi = RenderAPI::instance();</div><div class="line">rapi.setVertexDeclaration(vertexDecl);</div></div><!-- fragment --><p><b>ct::VertexDeclaration</b> can also be used for querying information about vertex size and offsets, which can be useful for creating the vertex buffer. First retrieve the <a class="el" href="classbs_1_1_vertex_declaration_properties.html">VertexDeclarationProperties</a> object by calling <a class="el" href="classbs_1_1ct_1_1_vertex_declaration.html#a6cffd490a5c31a69d1ede7a236028238">ct::VertexDeclaration::getProperties()</a>. Then you can query for information like vertex size by calling <a class="el" href="classbs_1_1_vertex_declaration_properties.html#a6c5e56ed5b95587b20eae832daaa91eb">VertexDeclarationProperties::getVertexSize()</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; props = vertexDecl-&gt;getProperties();</div><div class="line"></div><div class="line"><span class="comment">// Gets the size of an individual vertex in the 0th stream (stream index maps to bound vertex buffer at the same index)</span></div><div class="line">UINT32 vertexSize = props.getVertexSize(0);</div></div><!-- fragment --><h1><a class="anchor" id="geometry_c"></a>
Index buffer</h1>
<p>Finally, before drawing you will usually also want to also bind an index buffer. Index buffers are optional, but should be used in most cases. Each entry in an index buffer points to a vertex in the vertex buffer, and sequential indices are used to form primitives for rendering (e.g. every three indices will form a triangle). This ensures you can re-use same vertex in multiple primitives, saving on memory and bandwidth, as well as create more optimal vertex order for GPU processing. Without an index buffer the vertices are instead read sequentially in the order they are defined in the vertex buffer.</p>
<p>To create an index buffer call <a class="el" href="classbs_1_1ct_1_1_index_buffer.html#a52d89c780ce5b3df2c54d1fb86bda657">ct::IndexBuffer::create()</a> with a populated <a class="el" href="structbs_1_1_i_n_d_e_x___b_u_f_f_e_r___d_e_s_c.html">INDEX_BUFFER_DESC</a> structure. The call requires a number of indices and their type. Indices can be either 16- or 32-bit.</p>
<div class="fragment"><div class="line"><span class="comment">// Create an index buffer containing 36 16-bit indices</span></div><div class="line">INDEX_BUFFER_DESC desc;</div><div class="line">desc.indexType = <a class="code" href="group___utility-_core.html#gga2bfb0a0ff1c379a8b4e8f9d24fdd4839a5143a828ee9a70ea77be0f3a424f4fe8">IT_16BIT</a>;</div><div class="line">desc.numIndices = 36;</div><div class="line"></div><div class="line">SPtr&lt;IndexBuffer&gt; ib = IndexBuffer::create(desc);</div></div><!-- fragment --><p>Reading and writing from/to the index buffer has the identical interface to the vertex buffer, so we won't show it again.</p>
<p>To bind an index buffer to the pipeline call <a class="el" href="classbs_1_1ct_1_1_render_a_p_i.html#ae5c209ee82baae076db87065569a5b5b">ct::RenderAPI::setIndexBuffer()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Bind an index buffer</span></div><div class="line">RenderAPI&amp; rapi = RenderAPI::instance();</div><div class="line">rapi.setIndexBuffer(ib);</div></div><!-- fragment --><h1><a class="anchor" id="geometry_d"></a>
Geometry from meshes</h1>
<p>All the objects we described so far can be retrieved directly from a <b>ct::Mesh</b>. This allows you to manually bind imported mesh geometry to the pipeline.</p>
<p>This fact can also be exploited for easier vertex/index buffer and declaration creation, as creating a <b>ct::Mesh</b> is usually simpler than creating these objects individually.</p>
<p>To retrieve an index buffer from a <b>ct::Mesh</b> call <a class="el" href="classbs_1_1ct_1_1_mesh.html#a8b805964fe0d90ac3d8403bfcd4797cb">ct::Mesh::getIndexBuffer()</a>. Vertex buffer(s) and vertex declaration can be retrieved from a <a class="el" href="classbs_1_1ct_1_1_vertex_data.html">ct::VertexData</a> structure returned by <a class="el" href="classbs_1_1ct_1_1_mesh.html#aad3726437b7ba5afbcaf7ae769ff00de">ct::Mesh::getVertexData()</a>. <b>ct::VertexDeclaration</b> can then be retrieved from <a class="el" href="classbs_1_1ct_1_1_vertex_data.html#ae9b1b0e3c3ce2dc5353d20fedc483176">ct::VertexData::vertexDeclaration</a>, and vertex buffers from <a class="el" href="classbs_1_1ct_1_1_vertex_data.html#a4e31e77502949273d8de9e44d4de363e">ct::VertexData::getBuffer()</a></p>
<div class="fragment"><div class="line">SPtr&lt;Mesh&gt; mesh = ...;</div><div class="line">SPtr&lt;IndexBuffer&gt; meshIB = mesh-&gt;getIndexBuffer();</div><div class="line">SPtr&lt;VertexData&gt; vertexData = mesh-&gt;getVertexData();</div><div class="line">SPtr&lt;VertexDeclaration&gt; = vertexData-&gt;vertexDeclaration;</div><div class="line">SPtr&lt;VertexBuffer&gt; meshVB = vertexData-&gt;getBuffer(0);</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
