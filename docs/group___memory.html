<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - Memory</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='https://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory<div class="ingroups"><a class="el" href="group___layers.html">Layers</a> &raquo; <a class="el" href="group___utility.html">Utility</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Allocators, deallocators and memory manipulation. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbs_1_1_native_ptr.html">NativePtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Smart" pointer that is not smart.  <a href="structbs_1_1_native_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5d0570b754c88e4c1b7e39504856c893"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>BS_PVT_DELETE</b>(T,  ptr)</td></tr>
<tr class="separator:ga5d0570b754c88e4c1b7e39504856c893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9c14e363403d191c95e0c4685477ece"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>BS_PVT_DELETE_A</b>(T,  ptr,  Alloc)</td></tr>
<tr class="separator:gae9c14e363403d191c95e0c4685477ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga63acc968f650605f77dbc536ea082cf2"><td class="memItemLeft" align="right" valign="top">typedef std::basic_string&lt; char, std::char_traits&lt; char &gt;, <a class="el" href="classbs_1_1_std_alloc.html">StdAlloc</a>&lt; char, <a class="el" href="classbs_1_1_frame_alloc.html">FrameAlloc</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga63acc968f650605f77dbc536ea082cf2">FrameString</a></td></tr>
<tr class="memdesc:ga63acc968f650605f77dbc536ea082cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">String allocated with a frame allocator.  <a href="group___memory.html#ga63acc968f650605f77dbc536ea082cf2">More...</a><br /></td></tr>
<tr class="separator:ga63acc968f650605f77dbc536ea082cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed34f814a5e14c182455754b584828e3"><td class="memItemLeft" align="right" valign="top">typedef std::basic_string&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, <a class="el" href="classbs_1_1_std_alloc.html">StdAlloc</a>&lt; wchar_t, <a class="el" href="classbs_1_1_frame_alloc.html">FrameAlloc</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gaed34f814a5e14c182455754b584828e3">FrameWString</a></td></tr>
<tr class="memdesc:gaed34f814a5e14c182455754b584828e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">WString allocated with a frame allocator.  <a href="group___memory.html#gaed34f814a5e14c182455754b584828e3">More...</a><br /></td></tr>
<tr class="separator:gaed34f814a5e14c182455754b584828e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4503d77ccc0b655bb56f1d90746b8c51"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A  = StdAlloc&lt;T, FrameAlloc&gt;&gt; </td></tr>
<tr class="memitem:ga4503d77ccc0b655bb56f1d90746b8c51"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga4503d77ccc0b655bb56f1d90746b8c51">FrameVector</a> = std::vector&lt; T, A &gt;</td></tr>
<tr class="memdesc:ga4503d77ccc0b655bb56f1d90746b8c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector allocated with a frame allocator.  <a href="group___memory.html#ga4503d77ccc0b655bb56f1d90746b8c51">More...</a><br /></td></tr>
<tr class="separator:ga4503d77ccc0b655bb56f1d90746b8c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac13aa4c7c929c172babaca3132a6a259"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A  = StdAlloc&lt;T, FrameAlloc&gt;&gt; </td></tr>
<tr class="memitem:gac13aa4c7c929c172babaca3132a6a259"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gac13aa4c7c929c172babaca3132a6a259">FrameStack</a> = std::stack&lt; T, std::deque&lt; T, A &gt; &gt;</td></tr>
<tr class="memdesc:gac13aa4c7c929c172babaca3132a6a259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack allocated with a frame allocator.  <a href="group___memory.html#gac13aa4c7c929c172babaca3132a6a259">More...</a><br /></td></tr>
<tr class="separator:gac13aa4c7c929c172babaca3132a6a259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34def4ba9a7dccb8ce49763f93991035"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A  = StdAlloc&lt;T, FrameAlloc&gt;&gt; </td></tr>
<tr class="memitem:ga34def4ba9a7dccb8ce49763f93991035"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga34def4ba9a7dccb8ce49763f93991035">FrameQueue</a> = std::queue&lt; T, std::deque&lt; T, A &gt; &gt;</td></tr>
<tr class="memdesc:ga34def4ba9a7dccb8ce49763f93991035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue allocated with a frame allocator.  <a href="group___memory.html#ga34def4ba9a7dccb8ce49763f93991035">More...</a><br /></td></tr>
<tr class="separator:ga34def4ba9a7dccb8ce49763f93991035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1912a4118a6ac3e2a3fef2d546d57bc0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P  = std::less&lt;T&gt;, typename A  = StdAlloc&lt;T, FrameAlloc&gt;&gt; </td></tr>
<tr class="memitem:ga1912a4118a6ac3e2a3fef2d546d57bc0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga1912a4118a6ac3e2a3fef2d546d57bc0">FrameSet</a> = std::set&lt; T, P, A &gt;</td></tr>
<tr class="memdesc:ga1912a4118a6ac3e2a3fef2d546d57bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set allocated with a frame allocator.  <a href="group___memory.html#ga1912a4118a6ac3e2a3fef2d546d57bc0">More...</a><br /></td></tr>
<tr class="separator:ga1912a4118a6ac3e2a3fef2d546d57bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec13991a0574c7ec1040f545535dd5ea"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename P  = std::less&lt;K&gt;, typename A  = StdAlloc&lt;std::pair&lt;const K, V&gt;, FrameAlloc&gt;&gt; </td></tr>
<tr class="memitem:gaec13991a0574c7ec1040f545535dd5ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gaec13991a0574c7ec1040f545535dd5ea">FrameMap</a> = std::map&lt; K, V, P, A &gt;</td></tr>
<tr class="memdesc:gaec13991a0574c7ec1040f545535dd5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map allocated with a frame allocator.  <a href="group___memory.html#gaec13991a0574c7ec1040f545535dd5ea">More...</a><br /></td></tr>
<tr class="separator:gaec13991a0574c7ec1040f545535dd5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b05bd6dc089b7bbfd1ab8c643a6f411"><td class="memTemplParams" colspan="2">template&lt;typename T , typename H  = std::hash&lt;T&gt;, typename C  = std::equal_to&lt;T&gt;, typename A  = StdAlloc&lt;T, FrameAlloc&gt;&gt; </td></tr>
<tr class="memitem:ga2b05bd6dc089b7bbfd1ab8c643a6f411"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga2b05bd6dc089b7bbfd1ab8c643a6f411">FrameUnorderedSet</a> = std::unordered_set&lt; T, H, C, A &gt;</td></tr>
<tr class="memdesc:ga2b05bd6dc089b7bbfd1ab8c643a6f411"><td class="mdescLeft">&#160;</td><td class="mdescRight">UnorderedSet allocated with a frame allocator.  <a href="group___memory.html#ga2b05bd6dc089b7bbfd1ab8c643a6f411">More...</a><br /></td></tr>
<tr class="separator:ga2b05bd6dc089b7bbfd1ab8c643a6f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac78c32b63a25886b54a015e0af626d18"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename H  = std::hash&lt;K&gt;, typename C  = std::equal_to&lt;K&gt;, typename A  = StdAlloc&lt;std::pair&lt;const K, V&gt;, FrameAlloc&gt;&gt; </td></tr>
<tr class="memitem:gac78c32b63a25886b54a015e0af626d18"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gac78c32b63a25886b54a015e0af626d18">FrameUnorderedMap</a> = std::unordered_map&lt; K, V, H, C, A &gt;</td></tr>
<tr class="memdesc:gac78c32b63a25886b54a015e0af626d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">UnorderedMap allocated with a frame allocator.  <a href="group___memory.html#gac78c32b63a25886b54a015e0af626d18">More...</a><br /></td></tr>
<tr class="separator:gac78c32b63a25886b54a015e0af626d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed7488f042d1afce054eb155a3f74417"><td class="memTemplParams" colspan="2">template&lt;typename T , int Count&gt; </td></tr>
<tr class="memitem:gaed7488f042d1afce054eb155a3f74417"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gaed7488f042d1afce054eb155a3f74417">StaticVector</a> = std::vector&lt; T, <a class="el" href="classbs_1_1_std_static_alloc.html">StdStaticAlloc</a>&lt; sizeof(T) *Count, T &gt; &gt;</td></tr>
<tr class="memdesc:gaed7488f042d1afce054eb155a3f74417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to Vector, except it avoids any dynamic allocations until the number of elements exceeds <code>Count</code>.  <a href="group___memory.html#gaed7488f042d1afce054eb155a3f74417">More...</a><br /></td></tr>
<tr class="separator:gaed7488f042d1afce054eb155a3f74417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5076b1659821c8d7ce06da09452ba382"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5076b1659821c8d7ce06da09452ba382"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a> = std::shared_ptr&lt; T &gt;</td></tr>
<tr class="memdesc:ga5076b1659821c8d7ce06da09452ba382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer that retains shared ownership of an project through a pointer.  <a href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">More...</a><br /></td></tr>
<tr class="separator:ga5076b1659821c8d7ce06da09452ba382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fcfc1ebb9680543572a71214449d00d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc  = GenAlloc, typename Delete  = decltype(&amp;bs_delete&lt;T, Alloc&gt;)&gt; </td></tr>
<tr class="memitem:ga2fcfc1ebb9680543572a71214449d00d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga2fcfc1ebb9680543572a71214449d00d">UPtr</a> = std::unique_ptr&lt; T, Delete &gt;</td></tr>
<tr class="memdesc:ga2fcfc1ebb9680543572a71214449d00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer that retains shared ownership of an project through a pointer.  <a href="group___memory.html#ga2fcfc1ebb9680543572a71214449d00d">More...</a><br /></td></tr>
<tr class="separator:ga2fcfc1ebb9680543572a71214449d00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac715d8821d71ff2f87733d5c1def4c71"><td class="memTemplParams" colspan="2"><a id="gac715d8821d71ff2f87733d5c1def4c71"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac715d8821d71ff2f87733d5c1def4c71"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NPtr</b> = <a class="el" href="structbs_1_1_native_ptr.html">NativePtr</a>&lt; T &gt;</td></tr>
<tr class="separator:gac715d8821d71ff2f87733d5c1def4c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1cf5c0d91e15acdc8992d20105fca069"><td class="memItemLeft" align="right" valign="top">BS_UTILITY_EXPORT <a class="el" href="classbs_1_1_frame_alloc.html">FrameAlloc</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga1cf5c0d91e15acdc8992d20105fca069">gFrameAlloc</a> ()</td></tr>
<tr class="memdesc:ga1cf5c0d91e15acdc8992d20105fca069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a global, application wide <a class="el" href="classbs_1_1_frame_alloc.html" title="Frame allocator. ">FrameAlloc</a>.  <a href="group___memory.html#ga1cf5c0d91e15acdc8992d20105fca069">More...</a><br /></td></tr>
<tr class="separator:ga1cf5c0d91e15acdc8992d20105fca069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga405c0dc20a2c748eb66210a217bc484e"><td class="memItemLeft" align="right" valign="top">BS_UTILITY_EXPORT UINT8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga405c0dc20a2c748eb66210a217bc484e">bs_frame_alloc</a> (UINT32 numBytes)</td></tr>
<tr class="memdesc:ga405c0dc20a2c748eb66210a217bc484e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates some memory using the global frame allocator.  <a href="group___memory.html#ga405c0dc20a2c748eb66210a217bc484e">More...</a><br /></td></tr>
<tr class="separator:ga405c0dc20a2c748eb66210a217bc484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb3d2292b1c8b8fad12a4c3b16f6a98"><td class="memItemLeft" align="right" valign="top">BS_UTILITY_EXPORT UINT8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gafbb3d2292b1c8b8fad12a4c3b16f6a98">bs_frame_alloc_aligned</a> (UINT32 count, UINT32 align)</td></tr>
<tr class="memdesc:gafbb3d2292b1c8b8fad12a4c3b16f6a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the specified number of bytes aligned to the provided boundary, using the global frame allocator.  <a href="group___memory.html#gafbb3d2292b1c8b8fad12a4c3b16f6a98">More...</a><br /></td></tr>
<tr class="separator:gafbb3d2292b1c8b8fad12a4c3b16f6a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcad7521458d565efa07349c6331a579"><td class="memItemLeft" align="right" valign="top">BS_UTILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gabcad7521458d565efa07349c6331a579">bs_frame_free</a> (void *data)</td></tr>
<tr class="memdesc:gabcad7521458d565efa07349c6331a579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates memory allocated with the global frame allocator.  <a href="group___memory.html#gabcad7521458d565efa07349c6331a579">More...</a><br /></td></tr>
<tr class="separator:gabcad7521458d565efa07349c6331a579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga540ef2e9c63dbf46ff74935d95c13953"><td class="memItemLeft" align="right" valign="top">BS_UTILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga540ef2e9c63dbf46ff74935d95c13953">bs_frame_free_aligned</a> (void *data)</td></tr>
<tr class="memdesc:ga540ef2e9c63dbf46ff74935d95c13953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory previously allocated with <a class="el" href="group___memory.html#gafbb3d2292b1c8b8fad12a4c3b16f6a98" title="Allocates the specified number of bytes aligned to the provided boundary, using the global frame allo...">bs_frame_alloc_aligned()</a>.  <a href="group___memory.html#ga540ef2e9c63dbf46ff74935d95c13953">More...</a><br /></td></tr>
<tr class="separator:ga540ef2e9c63dbf46ff74935d95c13953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf52da285cef42ae4e706af6587939f5"><td class="memTemplParams" colspan="2"><a id="gadf52da285cef42ae4e706af6587939f5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gadf52da285cef42ae4e706af6587939f5"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gadf52da285cef42ae4e706af6587939f5">bs_frame_alloc</a> ()</td></tr>
<tr class="memdesc:gadf52da285cef42ae4e706af6587939f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates enough memory to hold the object of specified type using the global frame allocator, but does not construct the object. <br /></td></tr>
<tr class="separator:gadf52da285cef42ae4e706af6587939f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c4fa2bbfb04261850c43822a2739af"><td class="memTemplParams" colspan="2"><a id="ga32c4fa2bbfb04261850c43822a2739af"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga32c4fa2bbfb04261850c43822a2739af"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga32c4fa2bbfb04261850c43822a2739af">bs_frame_new</a> (UINT32 count=0)</td></tr>
<tr class="memdesc:ga32c4fa2bbfb04261850c43822a2739af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates enough memory to hold the object(s) of specified type using the global frame allocator, and constructs them. <br /></td></tr>
<tr class="separator:ga32c4fa2bbfb04261850c43822a2739af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89be9c306429e2cac13b3ac2fb0ba215"><td class="memTemplParams" colspan="2"><a id="ga89be9c306429e2cac13b3ac2fb0ba215"></a>
template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:ga89be9c306429e2cac13b3ac2fb0ba215"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga89be9c306429e2cac13b3ac2fb0ba215">bs_frame_new</a> (Args &amp;&amp;...args, UINT32 count=0)</td></tr>
<tr class="memdesc:ga89be9c306429e2cac13b3ac2fb0ba215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates enough memory to hold the object(s) of specified type using the global frame allocator, and constructs them. <br /></td></tr>
<tr class="separator:ga89be9c306429e2cac13b3ac2fb0ba215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ff34b8abcaa5a9fd073c825a0ea46d5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6ff34b8abcaa5a9fd073c825a0ea46d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga6ff34b8abcaa5a9fd073c825a0ea46d5">bs_frame_delete</a> (T *data)</td></tr>
<tr class="memdesc:ga6ff34b8abcaa5a9fd073c825a0ea46d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs and deallocates an object allocated with the global frame allocator.  <a href="group___memory.html#ga6ff34b8abcaa5a9fd073c825a0ea46d5">More...</a><br /></td></tr>
<tr class="separator:ga6ff34b8abcaa5a9fd073c825a0ea46d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c4774963ae360415777728ea9902b2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae2c4774963ae360415777728ea9902b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gae2c4774963ae360415777728ea9902b2">bs_frame_delete</a> (T *data, UINT32 count)</td></tr>
<tr class="memdesc:gae2c4774963ae360415777728ea9902b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs and deallocates an array of objects allocated with the global frame allocator.  <a href="group___memory.html#gae2c4774963ae360415777728ea9902b2">More...</a><br /></td></tr>
<tr class="separator:gae2c4774963ae360415777728ea9902b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3293dd38212269dafc81577a543ac81a"><td class="memItemLeft" align="right" valign="top">BS_UTILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga3293dd38212269dafc81577a543ac81a">bs_frame_mark</a> ()</td></tr>
<tr class="memdesc:ga3293dd38212269dafc81577a543ac81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a new frame. <br />
  <a href="group___memory.html#ga3293dd38212269dafc81577a543ac81a">More...</a><br /></td></tr>
<tr class="separator:ga3293dd38212269dafc81577a543ac81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85036849159c6716e001f4fae97c6488"><td class="memItemLeft" align="right" valign="top">BS_UTILITY_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga85036849159c6716e001f4fae97c6488">bs_frame_clear</a> ()</td></tr>
<tr class="memdesc:ga85036849159c6716e001f4fae97c6488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates all allocated memory since the last call to markFrame() (or all the memory if there was no call to markFrame()). <br />
  <a href="group___memory.html#ga85036849159c6716e001f4fae97c6488">More...</a><br /></td></tr>
<tr class="separator:ga85036849159c6716e001f4fae97c6488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab73a1dcfe655924d94f54e9df327e8e3"><td class="memTemplParams" colspan="2">template&lt;class Alloc &gt; </td></tr>
<tr class="memitem:gab73a1dcfe655924d94f54e9df327e8e3"><td class="memTemplItemLeft" align="right" valign="top">void *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gab73a1dcfe655924d94f54e9df327e8e3">bs_alloc</a> (size_t count)</td></tr>
<tr class="memdesc:gab73a1dcfe655924d94f54e9df327e8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the specified number of bytes.  <a href="group___memory.html#gab73a1dcfe655924d94f54e9df327e8e3">More...</a><br /></td></tr>
<tr class="separator:gab73a1dcfe655924d94f54e9df327e8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bb8b9b46e983e55f00bf2d774761681"><td class="memTemplParams" colspan="2">template&lt;class T , class Alloc &gt; </td></tr>
<tr class="memitem:ga4bb8b9b46e983e55f00bf2d774761681"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga4bb8b9b46e983e55f00bf2d774761681">bs_alloc</a> ()</td></tr>
<tr class="memdesc:ga4bb8b9b46e983e55f00bf2d774761681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates enough bytes to hold the specified type, but doesn't construct it.  <a href="group___memory.html#ga4bb8b9b46e983e55f00bf2d774761681">More...</a><br /></td></tr>
<tr class="separator:ga4bb8b9b46e983e55f00bf2d774761681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf8c59cbf547bda772d666ee1659635"><td class="memTemplParams" colspan="2">template&lt;class T , class Alloc &gt; </td></tr>
<tr class="memitem:ga4bf8c59cbf547bda772d666ee1659635"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga4bf8c59cbf547bda772d666ee1659635">bs_newN</a> (size_t count)</td></tr>
<tr class="memdesc:ga4bf8c59cbf547bda772d666ee1659635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and constructs an array of <code>count</code> elements.  <a href="group___memory.html#ga4bf8c59cbf547bda772d666ee1659635">More...</a><br /></td></tr>
<tr class="separator:ga4bf8c59cbf547bda772d666ee1659635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad97b177adbca77be8c146b4c6b05a897"><td class="memTemplParams" colspan="2">template&lt;class Type , class Alloc , class... Args&gt; </td></tr>
<tr class="memitem:gad97b177adbca77be8c146b4c6b05a897"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gad97b177adbca77be8c146b4c6b05a897">bs_new</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:gad97b177adbca77be8c146b4c6b05a897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new object with the specified allocator and the specified parameters.  <a href="group___memory.html#gad97b177adbca77be8c146b4c6b05a897">More...</a><br /></td></tr>
<tr class="separator:gad97b177adbca77be8c146b4c6b05a897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c82945f631c4a07c3085b3f79046a87"><td class="memTemplParams" colspan="2">template&lt;class Alloc &gt; </td></tr>
<tr class="memitem:ga0c82945f631c4a07c3085b3f79046a87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga0c82945f631c4a07c3085b3f79046a87">bs_free</a> (void *ptr)</td></tr>
<tr class="memdesc:ga0c82945f631c4a07c3085b3f79046a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all the bytes allocated at the specified location.  <a href="group___memory.html#ga0c82945f631c4a07c3085b3f79046a87">More...</a><br /></td></tr>
<tr class="separator:ga0c82945f631c4a07c3085b3f79046a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga803d542d4a7812addf807ef555000767"><td class="memTemplParams" colspan="2">template&lt;class T , class Alloc  = GenAlloc&gt; </td></tr>
<tr class="memitem:ga803d542d4a7812addf807ef555000767"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga803d542d4a7812addf807ef555000767">bs_delete</a> (T *ptr)</td></tr>
<tr class="memdesc:ga803d542d4a7812addf807ef555000767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs and frees the specified object.  <a href="group___memory.html#ga803d542d4a7812addf807ef555000767">More...</a><br /></td></tr>
<tr class="separator:ga803d542d4a7812addf807ef555000767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6967cd5f8a61aca6c6935b6fcdc2580"><td class="memTemplParams" colspan="2">template&lt;class T , class Alloc  = GenAlloc&gt; </td></tr>
<tr class="memitem:gae6967cd5f8a61aca6c6935b6fcdc2580"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gae6967cd5f8a61aca6c6935b6fcdc2580">bs_deleteN</a> (T *ptr, size_t count)</td></tr>
<tr class="memdesc:gae6967cd5f8a61aca6c6935b6fcdc2580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs and frees the specified array of objects.  <a href="group___memory.html#gae6967cd5f8a61aca6c6935b6fcdc2580">More...</a><br /></td></tr>
<tr class="separator:gae6967cd5f8a61aca6c6935b6fcdc2580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4e7375977d8eb27ea0d321500432e3e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab4e7375977d8eb27ea0d321500432e3e"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gab4e7375977d8eb27ea0d321500432e3e">bs_alloc</a> ()</td></tr>
<tr class="memdesc:gab4e7375977d8eb27ea0d321500432e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates enough bytes to hold the specified type, but doesn't construct it.  <a href="group___memory.html#gab4e7375977d8eb27ea0d321500432e3e">More...</a><br /></td></tr>
<tr class="separator:gab4e7375977d8eb27ea0d321500432e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa83bb81b3f3f7a71c6dc819271772a1e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gaa83bb81b3f3f7a71c6dc819271772a1e">bs_alloc_aligned</a> (size_t count, size_t align)</td></tr>
<tr class="memdesc:gaa83bb81b3f3f7a71c6dc819271772a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the specified number of bytes aligned to the provided boundary.  <a href="group___memory.html#gaa83bb81b3f3f7a71c6dc819271772a1e">More...</a><br /></td></tr>
<tr class="separator:gaa83bb81b3f3f7a71c6dc819271772a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00241e4fbcdb571f8e6db60f6b37de4b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga00241e4fbcdb571f8e6db60f6b37de4b">bs_alloc_aligned16</a> (size_t count)</td></tr>
<tr class="memdesc:ga00241e4fbcdb571f8e6db60f6b37de4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the specified number of bytes aligned to a 16 bytes boundary.  <a href="group___memory.html#ga00241e4fbcdb571f8e6db60f6b37de4b">More...</a><br /></td></tr>
<tr class="separator:ga00241e4fbcdb571f8e6db60f6b37de4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1050d5941d6fabacec7f2b64c4c95f77"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga1050d5941d6fabacec7f2b64c4c95f77"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga1050d5941d6fabacec7f2b64c4c95f77">bs_allocN</a> (size_t count)</td></tr>
<tr class="memdesc:ga1050d5941d6fabacec7f2b64c4c95f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates enough bytes to hold an array of <code>count</code> elements the specified type, but doesn't construct them.  <a href="group___memory.html#ga1050d5941d6fabacec7f2b64c4c95f77">More...</a><br /></td></tr>
<tr class="separator:ga1050d5941d6fabacec7f2b64c4c95f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a89d72add3a8803d8b45126dbdbf24a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga1a89d72add3a8803d8b45126dbdbf24a"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga1a89d72add3a8803d8b45126dbdbf24a">bs_newN</a> (size_t count)</td></tr>
<tr class="memdesc:ga1a89d72add3a8803d8b45126dbdbf24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and constructs an array of <code>count</code> elements.  <a href="group___memory.html#ga1a89d72add3a8803d8b45126dbdbf24a">More...</a><br /></td></tr>
<tr class="separator:ga1a89d72add3a8803d8b45126dbdbf24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaafb15d9e460a3abfaa8f749f6ae7097"><td class="memTemplParams" colspan="2">template&lt;class Type , class... Args&gt; </td></tr>
<tr class="memitem:gaaafb15d9e460a3abfaa8f749f6ae7097"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gaaafb15d9e460a3abfaa8f749f6ae7097">bs_new</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:gaaafb15d9e460a3abfaa8f749f6ae7097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new object with the specified allocator and the specified parameters.  <a href="group___memory.html#gaaafb15d9e460a3abfaa8f749f6ae7097">More...</a><br /></td></tr>
<tr class="separator:gaaafb15d9e460a3abfaa8f749f6ae7097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad91b449ee651b7b8817119de2c027c89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#gad91b449ee651b7b8817119de2c027c89">bs_free_aligned</a> (void *ptr)</td></tr>
<tr class="memdesc:gad91b449ee651b7b8817119de2c027c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory previously allocated with <a class="el" href="group___memory.html#gaa83bb81b3f3f7a71c6dc819271772a1e" title="Allocates the specified number of bytes aligned to the provided boundary. ">bs_alloc_aligned()</a>.  <a href="group___memory.html#gad91b449ee651b7b8817119de2c027c89">More...</a><br /></td></tr>
<tr class="separator:gad91b449ee651b7b8817119de2c027c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga513872d1bdad7db57d62d080d15f633b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga513872d1bdad7db57d62d080d15f633b">bs_free_aligned16</a> (void *ptr)</td></tr>
<tr class="memdesc:ga513872d1bdad7db57d62d080d15f633b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory previously allocated with <a class="el" href="group___memory.html#ga00241e4fbcdb571f8e6db60f6b37de4b" title="Allocates the specified number of bytes aligned to a 16 bytes boundary. ">bs_alloc_aligned16()</a>.  <a href="group___memory.html#ga513872d1bdad7db57d62d080d15f633b">More...</a><br /></td></tr>
<tr class="separator:ga513872d1bdad7db57d62d080d15f633b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90acb2cfce60ceef66b28d426976c6e2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga90acb2cfce60ceef66b28d426976c6e2">bs_stack_alloc</a> (UINT32 amount)</td></tr>
<tr class="memdesc:ga90acb2cfce60ceef66b28d426976c6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the given amount of memory on the stack. <br />
  <a href="group___memory.html#ga90acb2cfce60ceef66b28d426976c6e2">More...</a><br /></td></tr>
<tr class="separator:ga90acb2cfce60ceef66b28d426976c6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa48a830bc86aa80982e125323f76524"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaaa48a830bc86aa80982e125323f76524"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gaaa48a830bc86aa80982e125323f76524">bs_stack_alloc</a> ()</td></tr>
<tr class="memdesc:gaaa48a830bc86aa80982e125323f76524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates enough memory to hold the specified type, on the stack, but does not initialize the object.  <a href="group___memory.html#gaaa48a830bc86aa80982e125323f76524">More...</a><br /></td></tr>
<tr class="separator:gaaa48a830bc86aa80982e125323f76524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bbf50949ca59d848c31464b128b1d0d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6bbf50949ca59d848c31464b128b1d0d"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga6bbf50949ca59d848c31464b128b1d0d">bs_stack_new</a> (UINT32 count=0)</td></tr>
<tr class="memdesc:ga6bbf50949ca59d848c31464b128b1d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates enough memory to hold the specified type, on the stack, and constructs the object.  <a href="group___memory.html#ga6bbf50949ca59d848c31464b128b1d0d">More...</a><br /></td></tr>
<tr class="separator:ga6bbf50949ca59d848c31464b128b1d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56875fb0c6b332a2e3a3ebc335e9c13"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:gab56875fb0c6b332a2e3a3ebc335e9c13"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gab56875fb0c6b332a2e3a3ebc335e9c13">bs_stack_new</a> (Args &amp;&amp;...args, UINT32 count=0)</td></tr>
<tr class="memdesc:gab56875fb0c6b332a2e3a3ebc335e9c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates enough memory to hold the specified type, on the stack, and constructs the object.  <a href="group___memory.html#gab56875fb0c6b332a2e3a3ebc335e9c13">More...</a><br /></td></tr>
<tr class="separator:gab56875fb0c6b332a2e3a3ebc335e9c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5377cdd5d095cefe6c394d40a071455b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5377cdd5d095cefe6c394d40a071455b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga5377cdd5d095cefe6c394d40a071455b">bs_stack_delete</a> (T *data)</td></tr>
<tr class="memdesc:ga5377cdd5d095cefe6c394d40a071455b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs and deallocates last allocated entry currently located on stack.  <a href="group___memory.html#ga5377cdd5d095cefe6c394d40a071455b">More...</a><br /></td></tr>
<tr class="separator:ga5377cdd5d095cefe6c394d40a071455b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf58c1b2072f7702c5a0e4c5eca4fff"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gadbf58c1b2072f7702c5a0e4c5eca4fff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gadbf58c1b2072f7702c5a0e4c5eca4fff">bs_stack_delete</a> (T *data, UINT32 count)</td></tr>
<tr class="memdesc:gadbf58c1b2072f7702c5a0e4c5eca4fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs an array of objects and deallocates last allocated entry currently located on stack.  <a href="group___memory.html#gadbf58c1b2072f7702c5a0e4c5eca4fff">More...</a><br /></td></tr>
<tr class="separator:gadbf58c1b2072f7702c5a0e4c5eca4fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e8c54648877a868f0bf83378afc6133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___memory.html#ga9e8c54648877a868f0bf83378afc6133">bs_stack_free</a> (void *data)</td></tr>
<tr class="memdesc:ga9e8c54648877a868f0bf83378afc6133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates the given memory. <br />
  <a href="group___memory.html#ga9e8c54648877a868f0bf83378afc6133">More...</a><br /></td></tr>
<tr class="separator:ga9e8c54648877a868f0bf83378afc6133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac31f635d3674cace8ebb4bc24f02cd50"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename AllocCategory  = GenAlloc, typename... Args&gt; </td></tr>
<tr class="memitem:gac31f635d3674cace8ebb4bc24f02cd50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gac31f635d3674cace8ebb4bc24f02cd50">bs_shared_ptr_new</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gac31f635d3674cace8ebb4bc24f02cd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new shared pointer using a custom allocator category.  <a href="group___memory.html#gac31f635d3674cace8ebb4bc24f02cd50">More...</a><br /></td></tr>
<tr class="separator:gac31f635d3674cace8ebb4bc24f02cd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ebb1521ba3a4100a39212ab127e659a"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename MainAlloc  = GenAlloc, typename PtrDataAlloc  = GenAlloc, typename Deleter  = decltype(&amp;bs_delete&lt;Type, MainAlloc&gt;)&gt; </td></tr>
<tr class="memitem:ga9ebb1521ba3a4100a39212ab127e659a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga9ebb1521ba3a4100a39212ab127e659a">bs_shared_ptr</a> (Type *data, Deleter del=&amp;<a class="el" href="group___memory.html#ga803d542d4a7812addf807ef555000767">bs_delete</a>&lt; Type, MainAlloc &gt;)</td></tr>
<tr class="memdesc:ga9ebb1521ba3a4100a39212ab127e659a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new shared pointer from a previously constructed object.  <a href="group___memory.html#ga9ebb1521ba3a4100a39212ab127e659a">More...</a><br /></td></tr>
<tr class="separator:ga9ebb1521ba3a4100a39212ab127e659a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0366f428651831d3585dae578cd99e4f"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Alloc  = GenAlloc, typename Deleter  = decltype(&amp;bs_delete&lt;Type, Alloc&gt;)&gt; </td></tr>
<tr class="memitem:ga0366f428651831d3585dae578cd99e4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group___memory.html#ga2fcfc1ebb9680543572a71214449d00d">UPtr</a>&lt; Type, Alloc, Deleter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#ga0366f428651831d3585dae578cd99e4f">bs_unique_ptr</a> (Type *data, Deleter del=&amp;<a class="el" href="group___memory.html#ga803d542d4a7812addf807ef555000767">bs_delete</a>&lt; Type, Alloc &gt;)</td></tr>
<tr class="memdesc:ga0366f428651831d3585dae578cd99e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new unique pointer from a previously constructed object.  <a href="group___memory.html#ga0366f428651831d3585dae578cd99e4f">More...</a><br /></td></tr>
<tr class="separator:ga0366f428651831d3585dae578cd99e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef07c929a2f670e4336d7c8afb89a175"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Alloc  = GenAlloc, typename Deleter  = decltype(&amp;bs_delete&lt;Type, Alloc&gt;), typename... Args&gt; </td></tr>
<tr class="memitem:gaef07c929a2f670e4336d7c8afb89a175"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group___memory.html#ga2fcfc1ebb9680543572a71214449d00d">UPtr</a>&lt; Type, Alloc, Deleter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___memory.html#gaef07c929a2f670e4336d7c8afb89a175">bs_unique_ptr_new</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaef07c929a2f670e4336d7c8afb89a175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new unique pointer using a custom allocator category.  <a href="group___memory.html#gaef07c929a2f670e4336d7c8afb89a175">More...</a><br /></td></tr>
<tr class="separator:gaef07c929a2f670e4336d7c8afb89a175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga456fdbd65af849f4999adb3c88a78499"><td class="memTemplParams" colspan="2"><a id="ga456fdbd65af849f4999adb3c88a78499"></a>
template&lt;typename L_T , typename R_T &gt; </td></tr>
<tr class="memitem:ga456fdbd65af849f4999adb3c88a78499"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="structbs_1_1_native_ptr.html">NPtr</a>&lt; L_T &gt; &amp;lhs, const <a class="el" href="structbs_1_1_native_ptr.html">NPtr</a>&lt; R_T &gt; &amp;rhs)</td></tr>
<tr class="separator:ga456fdbd65af849f4999adb3c88a78499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73b6a12113d25b8abca7f94b6800f00"><td class="memTemplParams" colspan="2"><a id="gad73b6a12113d25b8abca7f94b6800f00"></a>
template&lt;typename L_T , typename R_T &gt; </td></tr>
<tr class="memitem:gad73b6a12113d25b8abca7f94b6800f00"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="structbs_1_1_native_ptr.html">NPtr</a>&lt; L_T &gt; &amp;lhs, const <a class="el" href="structbs_1_1_native_ptr.html">NPtr</a>&lt; R_T &gt; &amp;rhs)</td></tr>
<tr class="separator:gad73b6a12113d25b8abca7f94b6800f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga874bd2709b630450cbc6f1cbaad47922"><td class="memTemplParams" colspan="2"><a id="ga874bd2709b630450cbc6f1cbaad47922"></a>
template&lt;typename L_T , typename R_T &gt; </td></tr>
<tr class="memitem:ga874bd2709b630450cbc6f1cbaad47922"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="structbs_1_1_native_ptr.html">NPtr</a>&lt; L_T &gt; &amp;lhs, const <a class="el" href="structbs_1_1_native_ptr.html">NPtr</a>&lt; R_T &gt; &amp;rhs)</td></tr>
<tr class="separator:ga874bd2709b630450cbc6f1cbaad47922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f62d4a6bf1add415de7d4f469423dc"><td class="memTemplParams" colspan="2"><a id="ga50f62d4a6bf1add415de7d4f469423dc"></a>
template&lt;typename L_T , typename R_T &gt; </td></tr>
<tr class="memitem:ga50f62d4a6bf1add415de7d4f469423dc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="structbs_1_1_native_ptr.html">NPtr</a>&lt; L_T &gt; &amp;lhs, const <a class="el" href="structbs_1_1_native_ptr.html">NPtr</a>&lt; R_T &gt; &amp;rhs)</td></tr>
<tr class="separator:ga50f62d4a6bf1add415de7d4f469423dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf36aa80c32706ab64dbf1b38410d53f0"><td class="memTemplParams" colspan="2"><a id="gaf36aa80c32706ab64dbf1b38410d53f0"></a>
template&lt;typename L_T , typename R_T &gt; </td></tr>
<tr class="memitem:gaf36aa80c32706ab64dbf1b38410d53f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structbs_1_1_native_ptr.html">NPtr</a>&lt; L_T &gt; &amp;lhs, const <a class="el" href="structbs_1_1_native_ptr.html">NPtr</a>&lt; R_T &gt; &amp;rhs)</td></tr>
<tr class="separator:gaf36aa80c32706ab64dbf1b38410d53f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga252b3e3f3ee9ee15ba14c652388743d8"><td class="memTemplParams" colspan="2"><a id="ga252b3e3f3ee9ee15ba14c652388743d8"></a>
template&lt;typename L_T , typename R_T &gt; </td></tr>
<tr class="memitem:ga252b3e3f3ee9ee15ba14c652388743d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structbs_1_1_native_ptr.html">NPtr</a>&lt; L_T &gt; &amp;lhs, const <a class="el" href="structbs_1_1_native_ptr.html">NPtr</a>&lt; R_T &gt; &amp;rhs)</td></tr>
<tr class="separator:ga252b3e3f3ee9ee15ba14c652388743d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga5d0570b754c88e4c1b7e39504856c893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d0570b754c88e4c1b7e39504856c893">&#9670;&nbsp;</a></span>BS_PVT_DELETE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_PVT_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(ptr)-&gt;~T(); \</div><div class="line">    MemoryAllocator&lt;GenAlloc&gt;::free(ptr);</div></div><!-- fragment -->
</div>
</div>
<a id="gae9c14e363403d191c95e0c4685477ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9c14e363403d191c95e0c4685477ece">&#9670;&nbsp;</a></span>BS_PVT_DELETE_A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BS_PVT_DELETE_A</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Alloc&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(ptr)-&gt;~T(); \</div><div class="line">    MemoryAllocator&lt;Alloc&gt;::free(ptr);</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaec13991a0574c7ec1040f545535dd5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec13991a0574c7ec1040f545535dd5ea">&#9670;&nbsp;</a></span>FrameMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___memory.html#gaec13991a0574c7ec1040f545535dd5ea">FrameMap</a> =  std::map &lt; K, V, P, A &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map allocated with a frame allocator. </p>

</div>
</div>
<a id="ga34def4ba9a7dccb8ce49763f93991035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34def4ba9a7dccb8ce49763f93991035">&#9670;&nbsp;</a></span>FrameQueue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___memory.html#ga34def4ba9a7dccb8ce49763f93991035">FrameQueue</a> =  std::queue&lt;T, std::deque&lt;T, A&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue allocated with a frame allocator. </p>

</div>
</div>
<a id="ga1912a4118a6ac3e2a3fef2d546d57bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1912a4118a6ac3e2a3fef2d546d57bc0">&#9670;&nbsp;</a></span>FrameSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___memory.html#ga1912a4118a6ac3e2a3fef2d546d57bc0">FrameSet</a> =  std::set &lt; T, P, A &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set allocated with a frame allocator. </p>

</div>
</div>
<a id="gac13aa4c7c929c172babaca3132a6a259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac13aa4c7c929c172babaca3132a6a259">&#9670;&nbsp;</a></span>FrameStack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___memory.html#gac13aa4c7c929c172babaca3132a6a259">FrameStack</a> =  std::stack &lt; T, std::deque&lt;T, A&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack allocated with a frame allocator. </p>

</div>
</div>
<a id="ga63acc968f650605f77dbc536ea082cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63acc968f650605f77dbc536ea082cf2">&#9670;&nbsp;</a></span>FrameString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::basic_string&lt;char, std::char_traits&lt;char&gt;, <a class="el" href="classbs_1_1_std_alloc.html">StdAlloc</a>&lt;char, <a class="el" href="classbs_1_1_frame_alloc.html">FrameAlloc</a>&gt; &gt; <a class="el" href="group___memory.html#ga63acc968f650605f77dbc536ea082cf2">FrameString</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String allocated with a frame allocator. </p>

</div>
</div>
<a id="gac78c32b63a25886b54a015e0af626d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac78c32b63a25886b54a015e0af626d18">&#9670;&nbsp;</a></span>FrameUnorderedMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___memory.html#gac78c32b63a25886b54a015e0af626d18">FrameUnorderedMap</a> =  std::unordered_map &lt; K, V, H, C, A &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UnorderedMap allocated with a frame allocator. </p>

</div>
</div>
<a id="ga2b05bd6dc089b7bbfd1ab8c643a6f411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b05bd6dc089b7bbfd1ab8c643a6f411">&#9670;&nbsp;</a></span>FrameUnorderedSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___memory.html#ga2b05bd6dc089b7bbfd1ab8c643a6f411">FrameUnorderedSet</a> =  std::unordered_set &lt; T, H, C, A &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UnorderedSet allocated with a frame allocator. </p>

</div>
</div>
<a id="ga4503d77ccc0b655bb56f1d90746b8c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4503d77ccc0b655bb56f1d90746b8c51">&#9670;&nbsp;</a></span>FrameVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___memory.html#ga4503d77ccc0b655bb56f1d90746b8c51">FrameVector</a> =  std::vector &lt; T, A &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector allocated with a frame allocator. </p>

</div>
</div>
<a id="gaed34f814a5e14c182455754b584828e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed34f814a5e14c182455754b584828e3">&#9670;&nbsp;</a></span>FrameWString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::basic_string&lt;wchar_t, std::char_traits&lt;wchar_t&gt;, <a class="el" href="classbs_1_1_std_alloc.html">StdAlloc</a>&lt;wchar_t, <a class="el" href="classbs_1_1_frame_alloc.html">FrameAlloc</a>&gt; &gt; <a class="el" href="group___memory.html#gaed34f814a5e14c182455754b584828e3">FrameWString</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WString allocated with a frame allocator. </p>

</div>
</div>
<a id="ga5076b1659821c8d7ce06da09452ba382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5076b1659821c8d7ce06da09452ba382">&#9670;&nbsp;</a></span>SPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a> =  std::shared_ptr&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer that retains shared ownership of an project through a pointer. </p>
<p>The object is destroyed automatically when the last shared pointer to the object is destroyed. </p>

</div>
</div>
<a id="gaed7488f042d1afce054eb155a3f74417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed7488f042d1afce054eb155a3f74417">&#9670;&nbsp;</a></span>StaticVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___memory.html#gaed7488f042d1afce054eb155a3f74417">StaticVector</a> =  std::vector&lt;T, <a class="el" href="classbs_1_1_std_static_alloc.html">StdStaticAlloc</a>&lt;sizeof(T) * Count, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to Vector, except it avoids any dynamic allocations until the number of elements exceeds <code>Count</code>. </p>
<p>Requires allocator to be explicitly provided. </p>

</div>
</div>
<a id="ga2fcfc1ebb9680543572a71214449d00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fcfc1ebb9680543572a71214449d00d">&#9670;&nbsp;</a></span>UPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___memory.html#ga2fcfc1ebb9680543572a71214449d00d">UPtr</a> =  std::unique_ptr&lt;T, Delete&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer that retains shared ownership of an project through a pointer. </p>
<p>Reference to the object must be unique. The object is destroyed automatically when the pointer to the object is destroyed. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab73a1dcfe655924d94f54e9df327e8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab73a1dcfe655924d94f54e9df327e8e3">&#9670;&nbsp;</a></span>bs_alloc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * bs_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates the specified number of bytes. </p>

</div>
</div>
<a id="ga4bb8b9b46e983e55f00bf2d774761681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bb8b9b46e983e55f00bf2d774761681">&#9670;&nbsp;</a></span>bs_alloc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T* bs::bs_alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates enough bytes to hold the specified type, but doesn't construct it. </p>

</div>
</div>
<a id="gab4e7375977d8eb27ea0d321500432e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4e7375977d8eb27ea0d321500432e3e">&#9670;&nbsp;</a></span>bs_alloc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T* bs::bs_alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates enough bytes to hold the specified type, but doesn't construct it. </p>

</div>
</div>
<a id="gaa83bb81b3f3f7a71c6dc819271772a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa83bb81b3f3f7a71c6dc819271772a1e">&#9670;&nbsp;</a></span>bs_alloc_aligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bs::bs_alloc_aligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates the specified number of bytes aligned to the provided boundary. </p>
<p>Boundary is in bytes and must be a power of two. </p>

</div>
</div>
<a id="ga00241e4fbcdb571f8e6db60f6b37de4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00241e4fbcdb571f8e6db60f6b37de4b">&#9670;&nbsp;</a></span>bs_alloc_aligned16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bs::bs_alloc_aligned16 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates the specified number of bytes aligned to a 16 bytes boundary. </p>

</div>
</div>
<a id="ga1050d5941d6fabacec7f2b64c4c95f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1050d5941d6fabacec7f2b64c4c95f77">&#9670;&nbsp;</a></span>bs_allocN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T* bs::bs_allocN </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates enough bytes to hold an array of <code>count</code> elements the specified type, but doesn't construct them. </p>

</div>
</div>
<a id="ga803d542d4a7812addf807ef555000767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga803d542d4a7812addf807ef555000767">&#9670;&nbsp;</a></span>bs_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bs::bs_delete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructs and frees the specified object. </p>

</div>
</div>
<a id="gae6967cd5f8a61aca6c6935b6fcdc2580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6967cd5f8a61aca6c6935b6fcdc2580">&#9670;&nbsp;</a></span>bs_deleteN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bs::bs_deleteN </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructs and frees the specified array of objects. </p>

</div>
</div>
<a id="ga405c0dc20a2c748eb66210a217bc484e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga405c0dc20a2c748eb66210a217bc484e">&#9670;&nbsp;</a></span>bs_frame_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * bs_frame_alloc </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates some memory using the global frame allocator. </p>
<p>Allocates enough memory to hold N objects of specified type using the global frame allocator, but does not construct the object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numBytes</td><td>Number of bytes to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafbb3d2292b1c8b8fad12a4c3b16f6a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbb3d2292b1c8b8fad12a4c3b16f6a98">&#9670;&nbsp;</a></span>bs_frame_alloc_aligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BS_UTILITY_EXPORT UINT8* bs::bs_frame_alloc_aligned </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates the specified number of bytes aligned to the provided boundary, using the global frame allocator. </p>
<p>Boundary is in bytes and must be a power of two. </p>

</div>
</div>
<a id="ga85036849159c6716e001f4fae97c6488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85036849159c6716e001f4fae97c6488">&#9670;&nbsp;</a></span>bs_frame_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BS_UTILITY_EXPORT void bs::bs_frame_clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates all allocated memory since the last call to markFrame() (or all the memory if there was no call to markFrame()). <br />
 </p>
<dl class="section note"><dt>Note</dt><dd>Not thread safe. </dd></dl>

</div>
</div>
<a id="ga6ff34b8abcaa5a9fd073c825a0ea46d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ff34b8abcaa5a9fd073c825a0ea46d5">&#9670;&nbsp;</a></span>bs_frame_delete() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bs::bs_frame_delete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructs and deallocates an object allocated with the global frame allocator. </p>
<dl class="section note"><dt>Note</dt><dd>Must be called on the same thread the memory was allocated on. </dd></dl>

</div>
</div>
<a id="gae2c4774963ae360415777728ea9902b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2c4774963ae360415777728ea9902b2">&#9670;&nbsp;</a></span>bs_frame_delete() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bs::bs_frame_delete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructs and deallocates an array of objects allocated with the global frame allocator. </p>
<dl class="section note"><dt>Note</dt><dd>Must be called on the same thread the memory was allocated on. </dd></dl>

</div>
</div>
<a id="gabcad7521458d565efa07349c6331a579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcad7521458d565efa07349c6331a579">&#9670;&nbsp;</a></span>bs_frame_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BS_UTILITY_EXPORT void bs::bs_frame_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates memory allocated with the global frame allocator. </p>
<dl class="section note"><dt>Note</dt><dd>Must be called on the same thread the memory was allocated on. </dd></dl>

</div>
</div>
<a id="ga540ef2e9c63dbf46ff74935d95c13953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga540ef2e9c63dbf46ff74935d95c13953">&#9670;&nbsp;</a></span>bs_frame_free_aligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BS_UTILITY_EXPORT void bs::bs_frame_free_aligned </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory previously allocated with <a class="el" href="group___memory.html#gafbb3d2292b1c8b8fad12a4c3b16f6a98" title="Allocates the specified number of bytes aligned to the provided boundary, using the global frame allo...">bs_frame_alloc_aligned()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Must be called on the same thread the memory was allocated on. </dd></dl>

</div>
</div>
<a id="ga3293dd38212269dafc81577a543ac81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3293dd38212269dafc81577a543ac81a">&#9670;&nbsp;</a></span>bs_frame_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BS_UTILITY_EXPORT void bs::bs_frame_mark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a new frame. <br />
 </p>
<p>Next call to clear() will only clear memory allocated past this point. </p>

</div>
</div>
<a id="ga0c82945f631c4a07c3085b3f79046a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c82945f631c4a07c3085b3f79046a87">&#9670;&nbsp;</a></span>bs_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bs_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all the bytes allocated at the specified location. </p>

</div>
</div>
<a id="gad91b449ee651b7b8817119de2c027c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad91b449ee651b7b8817119de2c027c89">&#9670;&nbsp;</a></span>bs_free_aligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bs::bs_free_aligned </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory previously allocated with <a class="el" href="group___memory.html#gaa83bb81b3f3f7a71c6dc819271772a1e" title="Allocates the specified number of bytes aligned to the provided boundary. ">bs_alloc_aligned()</a>. </p>

</div>
</div>
<a id="ga513872d1bdad7db57d62d080d15f633b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga513872d1bdad7db57d62d080d15f633b">&#9670;&nbsp;</a></span>bs_free_aligned16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bs::bs_free_aligned16 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory previously allocated with <a class="el" href="group___memory.html#ga00241e4fbcdb571f8e6db60f6b37de4b" title="Allocates the specified number of bytes aligned to a 16 bytes boundary. ">bs_alloc_aligned16()</a>. </p>

</div>
</div>
<a id="gad97b177adbca77be8c146b4c6b05a897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad97b177adbca77be8c146b4c6b05a897">&#9670;&nbsp;</a></span>bs_new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Type* bs::bs_new </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new object with the specified allocator and the specified parameters. </p>

</div>
</div>
<a id="gaaafb15d9e460a3abfaa8f749f6ae7097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaafb15d9e460a3abfaa8f749f6ae7097">&#9670;&nbsp;</a></span>bs_new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Type* bs::bs_new </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new object with the specified allocator and the specified parameters. </p>

</div>
</div>
<a id="ga4bf8c59cbf547bda772d666ee1659635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bf8c59cbf547bda772d666ee1659635">&#9670;&nbsp;</a></span>bs_newN() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T* bs::bs_newN </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and constructs an array of <code>count</code> elements. </p>

</div>
</div>
<a id="ga1a89d72add3a8803d8b45126dbdbf24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a89d72add3a8803d8b45126dbdbf24a">&#9670;&nbsp;</a></span>bs_newN() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T* bs::bs_newN </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and constructs an array of <code>count</code> elements. </p>

</div>
</div>
<a id="ga9ebb1521ba3a4100a39212ab127e659a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ebb1521ba3a4100a39212ab127e659a">&#9670;&nbsp;</a></span>bs_shared_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;Type&gt; bs::bs_shared_ptr </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>del</em> = <code>&amp;<a class="el" href="group___memory.html#ga803d542d4a7812addf807ef555000767">bs_delete</a>&lt;Type,&#160;MainAlloc&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new shared pointer from a previously constructed object. </p>
<p>Pointer specific data will be allocated using the provided allocator category. </p>

</div>
</div>
<a id="gac31f635d3674cace8ebb4bc24f02cd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac31f635d3674cace8ebb4bc24f02cd50">&#9670;&nbsp;</a></span>bs_shared_ptr_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___memory.html#ga5076b1659821c8d7ce06da09452ba382">SPtr</a>&lt;Type&gt; bs::bs_shared_ptr_new </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new shared pointer using a custom allocator category. </p>

</div>
</div>
<a id="ga90acb2cfce60ceef66b28d426976c6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90acb2cfce60ceef66b28d426976c6e2">&#9670;&nbsp;</a></span>bs_stack_alloc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * bs_stack_alloc </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>amount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates the given amount of memory on the stack. <br />
 </p>
<p>Allocates enough memory to hold N objects of the specified type, on the stack, but does not initialize the objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">amount</td><td>The amount to allocate in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><br />
Allocates the memory in the currently active block if it is large enough, otherwise a new block is allocated. If the allocation is larger than default block size a separate block will be allocated only for that allocation, making it essentially a slower heap allocator. </dd>
<dd>
<br />
Each allocation comes with a 4 byte overhead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">amount</td><td>Number of entries of the requested type to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbs_1_1_mem_stack_internal.html#ad6886390fd8d5403f8553b8c8369489b" title="Allocates the given amount of memory on the stack. ">MemStackInternal::alloc()</a> </dd></dl>

</div>
</div>
<a id="gaaa48a830bc86aa80982e125323f76524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa48a830bc86aa80982e125323f76524">&#9670;&nbsp;</a></span>bs_stack_alloc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T* bs::bs_stack_alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates enough memory to hold the specified type, on the stack, but does not initialize the object. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbs_1_1_mem_stack_internal.html#ad6886390fd8d5403f8553b8c8369489b" title="Allocates the given amount of memory on the stack. ">MemStackInternal::alloc()</a> </dd></dl>

</div>
</div>
<a id="ga5377cdd5d095cefe6c394d40a071455b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5377cdd5d095cefe6c394d40a071455b">&#9670;&nbsp;</a></span>bs_stack_delete() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bs::bs_stack_delete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructs and deallocates last allocated entry currently located on stack. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbs_1_1_mem_stack_internal.html#aa044a028afbe928dc29e171fb6ccbcc6" title="Deallocates the given memory. ">MemStackInternal::dealloc()</a> </dd></dl>

</div>
</div>
<a id="gadbf58c1b2072f7702c5a0e4c5eca4fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbf58c1b2072f7702c5a0e4c5eca4fff">&#9670;&nbsp;</a></span>bs_stack_delete() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bs::bs_stack_delete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructs an array of objects and deallocates last allocated entry currently located on stack. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbs_1_1_mem_stack_internal.html#aa044a028afbe928dc29e171fb6ccbcc6" title="Deallocates the given memory. ">MemStackInternal::dealloc()</a> </dd></dl>

</div>
</div>
<a id="ga9e8c54648877a868f0bf83378afc6133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e8c54648877a868f0bf83378afc6133">&#9670;&nbsp;</a></span>bs_stack_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bs::bs_stack_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates the given memory. <br />
 </p>
<p>Data must be deallocated in opposite order then when it was allocated. </p>

</div>
</div>
<a id="ga6bbf50949ca59d848c31464b128b1d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bbf50949ca59d848c31464b128b1d0d">&#9670;&nbsp;</a></span>bs_stack_new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T* bs::bs_stack_new </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>count</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates enough memory to hold the specified type, on the stack, and constructs the object. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbs_1_1_mem_stack_internal.html#ad6886390fd8d5403f8553b8c8369489b" title="Allocates the given amount of memory on the stack. ">MemStackInternal::alloc()</a> </dd></dl>

</div>
</div>
<a id="gab56875fb0c6b332a2e3a3ebc335e9c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56875fb0c6b332a2e3a3ebc335e9c13">&#9670;&nbsp;</a></span>bs_stack_new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T* bs::bs_stack_new </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates enough memory to hold the specified type, on the stack, and constructs the object. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbs_1_1_mem_stack_internal.html#ad6886390fd8d5403f8553b8c8369489b" title="Allocates the given amount of memory on the stack. ">MemStackInternal::alloc()</a> </dd></dl>

</div>
</div>
<a id="ga0366f428651831d3585dae578cd99e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0366f428651831d3585dae578cd99e4f">&#9670;&nbsp;</a></span>bs_unique_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___memory.html#ga2fcfc1ebb9680543572a71214449d00d">UPtr</a>&lt;Type, Alloc, Deleter&gt; bs::bs_unique_ptr </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>del</em> = <code>&amp;<a class="el" href="group___memory.html#ga803d542d4a7812addf807ef555000767">bs_delete</a>&lt;Type,&#160;Alloc&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new unique pointer from a previously constructed object. </p>
<p>Pointer specific data will be allocated using the provided allocator category. </p>

</div>
</div>
<a id="gaef07c929a2f670e4336d7c8afb89a175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef07c929a2f670e4336d7c8afb89a175">&#9670;&nbsp;</a></span>bs_unique_ptr_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___memory.html#ga2fcfc1ebb9680543572a71214449d00d">UPtr</a>&lt;Type, Alloc, Deleter&gt; bs::bs_unique_ptr_new </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new unique pointer using a custom allocator category. </p>

</div>
</div>
<a id="ga1cf5c0d91e15acdc8992d20105fca069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf5c0d91e15acdc8992d20105fca069">&#9670;&nbsp;</a></span>gFrameAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BS_UTILITY_EXPORT <a class="el" href="classbs_1_1_frame_alloc.html">FrameAlloc</a>&amp; bs::gFrameAlloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a global, application wide <a class="el" href="classbs_1_1_frame_alloc.html" title="Frame allocator. ">FrameAlloc</a>. </p>
<p>Each thread gets its own frame allocator.</p>
<dl class="section note"><dt>Note</dt><dd>Thread safe. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
