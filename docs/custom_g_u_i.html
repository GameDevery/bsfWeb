<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>bs::f docs - Extending the GUI system</title>
<link rel="icon" type="image/png" href="logo.png">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href='http://fonts.googleapis.com/css?family=Lato:normal,bold|Cabin:normal,bold' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="../SemanticUI/semantic.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle.css" rel="stylesheet" type="text/css"/>
<link href="../SemanticUI/semantic.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="everything">
	<div class="ui inverted vertical center aligned segment" id="menuSegment">
		<div class="ui container">
			<div class="ui inverted mainmenu menu">
				<a href="https://www.bsframework.io"><div class="item" id="logoItem"><img class="ui image" id="logo" src="logoHeader.png"></div></a>
				<div class="right menu">
					<a class="borderless item" href="https://www.bsframework.io">Home</a>
					<a class="item" href="https://www.bsframework.io/download.html">Download</a>
					<a class="item" href="https://discourse.bsframework.io">Community</a>
					<a class="active item" href="https://www.bsframework.io/docs/index.html">Documentation</a>
					<a class="item" href="https://github.com/gamefoundry/bsf"><i class="github icon"></i>GitHub</a>
				</div>
			</div>
		</div>
	</div>	
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Extending the GUI system </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#customGUI_a">GUIElement implementation</a><ul><li class="level2"><a href="#customGUI_a_a">Construction</a></li>
<li class="level2"><a href="#customGUI_a_b">Graphics</a></li>
<li class="level2"><a href="#customGUI_a_c">Layout</a></li>
</ul>
</li>
<li class="level1"><a href="#customGUI_b">Redrawing</a></li>
<li class="level1"><a href="#customGUI_c">Input</a></li>
</ul>
</div>
<div class="textblock"><p>Even though bs::f provides fully skinnable and very customizable GUI elements, sometimes the built-in ones are just not enough if you need some very specialized functionality or look. bs::f allows you to create brand new elements and fully customize the way how they are rendered and how the user interacts with such elements.</p>
<p>You are expected to have read the user-facing GUI manuals before proceeding, and as such familiarized yourself with the basics.</p>
<p>All GUI elements derive from the base <a class="el" href="classbs_1_1_g_u_i_element_base.html">GUIElementBase</a> type. The elements can be categorized into two major groups:</p><ul>
<li><em>Layouts</em> - They derive from <a class="el" href="classbs_1_1_g_u_i_layout.html">GUILayout</a> and do not have any graphics, but instead they control the placement of all elements attached to them.</li>
<li><em>Elements</em> - They derive from <a class="el" href="classbs_1_1_g_u_i_element.html">GUIElement</a>, and they're standard GUI elements like buttons, input boxes, sliders and such.</li>
</ul>
<p>It's unlikely you will have the need to create <b>GUILayout</b> types, so we will instead focus on creating custom GUI elements.</p>
<h1><a class="anchor" id="customGUI_a"></a>
GUIElement implementation</h1>
<p>When creating a custom GUI element you will need to override the <b>GUIElement</b> class. In this section we'll go over the <em>minimum</em> set of functionality every GUI element must implement, split into relevant sections. In later sections we'll focus on optional functionality.</p>
<div class="fragment"><div class="line"><span class="comment">// GUI element that displays a single texture</span></div><div class="line"><span class="keyword">class </span>GUITexture : <span class="keyword">public</span> GUIElement</div><div class="line">{</div><div class="line">    <span class="comment">// ... implementation</span></div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="customGUI_a_a"></a>
Construction</h2>
<p>In its constructor <b>GUIElement</b> expects two parameters:</p><ul>
<li><code>styleName</code> - Name of the style to use for rendering the element. This will be looked up in the currently active <b>GUISkin</b> and relevant <a class="el" href="structbs_1_1_g_u_i_element_style.html">GUIElementStyle</a> objects will be used for determining object's textures, fonts, colors, borders, margins and similar. Each GUI element type should have a unique default style name, but you also might want to allow the user to override the default style name if he desires.</li>
<li><code>dimensions</code> - Initial set of dimensions determining GUI element's position and size, represented by <a class="el" href="structbs_1_1_g_u_i_dimensions.html">GUIDimensions</a>. You can create an empty set of dimensions by calling <a class="el" href="structbs_1_1_g_u_i_dimensions.html#a566d0180736992fa38d9661e51396370">GUIDimensions::create()</a>, in which case the system will use whichever dimensions are provided by the <b>GUIElementStyle</b>. Other overload of <b>GUIDimensions::create()</b> accepts a <a class="el" href="classbs_1_1_g_u_i_options.html">GUIOptions</a> object, in which you can specify an arbitrary sized array of various dimension related options.</li>
</ul>
<p>As a rule of thumb in order to aid construction GUI elements should provide a set of static <code>create()</code> methods (but aren't required to). You usually want to provide a few overloads of <code>create()</code> that allow the user to use custom style/dimensions or stick with the default one.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>GUITexture : <span class="keyword">public</span> GUIElement</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a>&amp; getGUITypeName()</div><div class="line">    {</div><div class="line">        <span class="comment">// Returns the name of this GUI element, used for looking up the default style</span></div><div class="line">        <span class="keyword">static</span> <a class="code" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> name = <span class="stringliteral">&quot;Texture&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span> name;</div><div class="line">    }</div><div class="line"></div><div class="line">    GUITexture(<span class="keyword">const</span> <a class="code" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a>&amp; styleName, <span class="keyword">const</span> GUIDimensions&amp; dimensions)</div><div class="line">        :GUIElement(styleName, dimensions)</div><div class="line">    { }</div><div class="line"></div><div class="line">    <span class="comment">// create() overload accepting custom dimensions in the form of GUIOptions</span></div><div class="line">    <span class="keyword">static</span> GUITexture* create(<span class="keyword">const</span> GUIOptions&amp; options, <span class="keyword">const</span> <a class="code" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a>&amp; styleName = StringUtil::BLANK)</div><div class="line">    {</div><div class="line">        <span class="comment">// If user didn&#39;t provide a style name, use the default</span></div><div class="line">        <a class="code" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> finalStyleName = styleName;</div><div class="line">        <span class="keywordflow">if</span>(styleName == StringUtil::BLANK)</div><div class="line">            finalStyleName = getGUITypeName();</div><div class="line"></div><div class="line">        <span class="comment">// Pass style name, and construct dimensions from the provided list of options</span></div><div class="line">        <span class="keywordflow">return</span> bs_new&lt;GUITexture&gt;(finalStyleName, GUIDimensions::create(options));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// create() overload using default dimensions</span></div><div class="line">    <span class="keyword">static</span> GUITexture* create(<span class="keyword">const</span> <a class="code" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a>&amp; styleName = StringUtil::BLANK)</div><div class="line">    {</div><div class="line">        <span class="comment">// Same as above</span></div><div class="line">        <a class="code" href="group___string.html#gad5ba86fc2c60a7dec2e22553e0bc20d3">String</a> finalStyleName = styleName;</div><div class="line">        <span class="keywordflow">if</span>(styleName == StringUtil::BLANK)</div><div class="line">            finalStyleName = getGUITypeName();</div><div class="line"></div><div class="line">        <span class="comment">// Pass style name, and construct default dimensions object</span></div><div class="line">        <span class="keywordflow">return</span> bs_new&lt;GUITexture&gt;(finalStyleName, GUIDimensions::create());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// ... remaining GUITexture implementation</span></div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="customGUI_a_b"></a>
Graphics</h2>
<p>In order for your GUI element to be visible you need to define its graphics. This involves:</p><ul>
<li>Creating a set of vertices and indices that represent your GUI element</li>
<li>Create the material to render the GUI element with, and bind required textures and other properties to it</li>
</ul>
<p>This is done by implementing the following methods:</p>
<p><a class="el" href="classbs_1_1_g_u_i_element.html#a8130186fdb1818667d71a0783883ae66">GUIElement::_getNumRenderElements()</a></p>
<p>Returns the number of separate elements that your GUI element consists of. Each element corresponds to a mesh and a material to render the mesh with. For most GUI elements there will be only one element, but you will need multiple elements in case your GUI element uses multiple textures or materials.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>GUITexture : <span class="keyword">public</span> GUIElement</div><div class="line">{</div><div class="line">    <span class="comment">// ... remaining GUITexture implementation</span></div><div class="line"></div><div class="line">    UINT32 _getNumRenderElements()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="comment">// Our simple GUI element has just a single render element (a single quad to be exact)</span></div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p><a class="el" href="classbs_1_1_g_u_i_element.html#a6de46db80338b3019451dbc668e1a9a6">GUIElement::_getMeshInfo()</a></p>
<p>Takes a render element index as input and returns the number of vertices and indices for the mesh at the specified index. This allows external systems to know how big of a buffer to allocate for the element's mesh. It also returns the type of the mesh which lets external systems know how to render the provided vertices.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>GUITexture : <span class="keyword">public</span> GUIElement</div><div class="line">{</div><div class="line">    <span class="comment">// ... remaining GUITexture implementation</span></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> _getMeshInfo(UINT32 renderElementIdx, UINT32&amp; numVertices, UINT32&amp; numIndices, <a class="code" href="group___utility-_engine.html#ga4b7ce34cc007dd94e52d9b4964712d8d">GUIMeshType</a>&amp; type)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="comment">// Since we&#39;re rendering a single quad, we use 4 vertices, rendered as 2 triangles (6 indices)</span></div><div class="line">        numVertices = 4;</div><div class="line">        numIndices = 6;</div><div class="line">        type = GUIMeshType::Triangle;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p><a class="el" href="classbs_1_1_g_u_i_element.html#ab91fb0df08e41a2284868d3b404bea42">GUIElement::_fillBuffer()</a></p>
<p>This is the primary method when it comes to <b>GUIElement</b> graphics. It allows you to provide the actual vertex and index data that will be used for rendering the GUI element. Note that number of vertices and indices provided must match the number returned by <b>GUIElement::_getMeshInfo()</b>.</p>
<p>The method receives pointers to the index and vertex memory that must be populated by the function, offsets at which memory location should the function output its data at, and external buffer sizes (used for overflow checking if needed).</p>
<p>The vertices are always in a specific format:</p><ul>
<li>Each vertex contains a 2D position, followed by 2D texture coordinates</li>
<li>Vertex size is <code>sizeof(Vector2) * 2</code></li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>GUITexture : <span class="keyword">public</span> GUIElement</div><div class="line">{</div><div class="line">    <span class="comment">// ... remaining GUITexture implementation</span></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> _fillBuffer(UINT8* vertices, UINT32* indices, UINT32 vertexOffset, UINT32 indexOffset,</div><div class="line">        UINT32 maxNumVerts, UINT32 maxNumIndices, UINT32 renderElementIdx)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        UINT32 vertexStride = <span class="keyword">sizeof</span>(Vector2) * 2;</div><div class="line">        UINT32 indexStride = <span class="keyword">sizeof</span>(UINT32);</div><div class="line"></div><div class="line">        <span class="comment">// Get location of this element in the provided buffers</span></div><div class="line">        vertices += vertexStride * vertexOffset;</div><div class="line">        UINT8* uvs = vertices + <span class="keyword">sizeof</span>(Vector2);</div><div class="line"></div><div class="line">        indices += indexStride * indexOffset;</div><div class="line"></div><div class="line">        <span class="comment">// Populate the vertices, uv and indices buffer</span></div><div class="line">        <span class="comment">// ... generate vertices, uvs and indices as you would for any mesh</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>bs::f also provides a set of helper classes for generating required geometry in the form of <a class="el" href="classbs_1_1_image_sprite.html">ImageSprite</a> and <a class="el" href="classbs_1_1_text_sprite.html">TextSprite</a> classes. <b>ImageSprite</b> can easily generate image geometry of specified size, whether a simple quad or a scale-9-grid image (scalable image with fixed borders). And <b>TextSprite</b> will take a text string, font and additional options as input, and output a set of quads required for text rendering.</p>
<p><a class="el" href="classbs_1_1_g_u_i_element.html#a79a2752dc7c151dc35329a7ca70ef804">GUIElement::_getMaterial()</a></p>
<p>Takes a render element index as input and returns a material to render the element with, as well material parameters.</p>
<p>GUI materials are represented by the <a class="el" href="classbs_1_1_sprite_material.html">SpriteMaterial</a> type and you can use <a class="el" href="classbs_1_1_sprite_manager.html">SpriteManager</a> to retrieve the built-in materials. You can also create your own sprite materials by implementing the <b>SpriteMaterial</b> class and registering them with the <b>SpriteManager</b> by calling <a class="el" href="classbs_1_1_sprite_manager.html#afd86cf450a272f420ec9ad5f83be1c5f">SpriteManager::registerMaterial()</a>.</p>
<p>Material parameters are represented by the <a class="el" href="structbs_1_1_sprite_material_info.html">SpriteMaterialInfo</a> structure, which contains the texture and color to render the element with. It also contains a <code>groupId</code> identifier which tells the external systems with which other GUI elements is this element allowed to be grouped with. Grouped elements are rendered together (batched) for better performance, but sometimes this is not wanted. Generally you want to provide the memory address of the parent <b>GUIWidget</b> for the <code>groupId</code> field, and don't need to worry about it further. You can retrieve the element's <b>GUIWidget</b> by calling <a class="el" href="classbs_1_1_g_u_i_element_base.html#a263a7f9fd9367504f27b53f322d4701c">GUIElement::_getParentWidget()</a>.</p>
<p>Textures used by the material parameter can be retrieved from the current <b>GUIElementStyle</b>, or provided directly to the GUI element by user-specified means. It is preferred to use the <b>GUIElementStyle</b> approach as this allows the user to customize the element look through <b>GUISkin</b>s, or by providing a custom style name. To retrieve the currently active style call <a class="el" href="classbs_1_1_g_u_i_element.html#acec4f79d149d78be7f680aa6729f4ced">GUIElement::_getStyle()</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>GUITexture : <span class="keyword">public</span> GUIElement</div><div class="line">{</div><div class="line">    <span class="comment">// ... remaining GUITexture implementation</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> SpriteMaterialInfo&amp; _getMaterial(UINT32 renderElementIdx, SpriteMaterial** material)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="comment">// Get material for rendering opaque images</span></div><div class="line">        *material = SpriteManager::instance().getImageOpaqueMaterial();</div><div class="line"></div><div class="line">        <span class="comment">// Populate the material parameters (normally you want to populate this when properties change and just return it here)</span></div><div class="line"><span class="comment"></span>        mMatParams.texture = _getStyle().normal.texture;</div><div class="line"></div><div class="line">        mMatParams.tint = Color::White;</div><div class="line"></div><div class="line">        mMatParams.groupId = (UINT64)_getParentWidget();</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> mMatParams;</div><div class="line">    }</div><div class="line"></div><div class="line">    SpriteMaterialInfo mMatParams;</div><div class="line">};</div></div><!-- fragment --><p><a class="el" href="classbs_1_1_g_u_i_element.html#a428bea213e1bad0821497ec1ba5c5464">GUIElement::updateRenderElementsInternal()</a></p>
<p>Called whenever the element's size or style changes. This is the method where you should rebuild the GUI element's mesh. While you could do it directly in <b>GUIElement::_fillBuffer()</b> it is better performance-wise to do it here, and instead just return the cached mesh when <b>GUIElement::_fillBuffer()</b> is called. This is because <b>GUIElement::_fillBuffer()</b> will get called even when mesh geometry didn't change, if the external systems deem it required.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>GUITexture : <span class="keyword">public</span> GUIElement</div><div class="line">{</div><div class="line">    <span class="comment">// ... remaining GUITexture implementation</span></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> updateRenderElementsInternal()</div><div class="line">    {       </div><div class="line">        <span class="comment">// Move the code for vertex/index generation here, cache the generate data and then just return the cached data when _fillBuffer() is called.</span></div><div class="line"></div><div class="line">        GUIElement::updateRenderElementsInternal();</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="customGUI_a_c"></a>
Layout</h2>
<p>In order for the GUI element to work well with the automatic positioning performed by GUI layouts, you must override the <a class="el" href="classbs_1_1_g_u_i_element_base.html#acf34e3a2ae42459bf6c450071e3461c5">GUIElement::_getOptimalSize()</a> method. As the name implies the method should return the optimal size of your GUI element. For example if your element was displaying a texture 64x64 in size, then the optimal size should probably return 64x64. If you element is displaying text you can use <a class="el" href="classbs_1_1_g_u_i_helper.html">GUIHelper</a> to help you calculate the bounds of the text. If displaying something else then it's up to you to determine what constitutes an optimal size.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>GUITexture : <span class="keyword">public</span> GUIElement</div><div class="line">{</div><div class="line">    <span class="comment">// ... remaining GUITexture implementation</span></div><div class="line"></div><div class="line">    Vector2I _getOptimalSize()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        Vector2I optimalSize;</div><div class="line"></div><div class="line">        <span class="comment">// Retrieve the size of the main texture, if one is provided</span></div><div class="line">        HSpriteTexture tex = _getStyle().normal.texture;</div><div class="line">        <span class="keywordflow">if</span>(tex != <span class="keyword">nullptr</span>)</div><div class="line">        {</div><div class="line">            optimalSize.x = tex-&gt;getWidth();</div><div class="line">            optimalSize.y = tex-&gt;getHeight();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> optimalSize;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>This concludes the minimal set of functionality required for implementing a <b>GUIElement</b>. At this point you will have a static GUI element that allows no user interaction. In next sections we expand on this by adding support for user input and dynamic graphics.</p>
<h1><a class="anchor" id="customGUI_b"></a>
Redrawing</h1>
<p>If your element allows the user to update certain contents of it after creation (i.e. it's not static), you need to notify the GUI system so it knows when to rebuild the element. For example if your GUI element displays a text string you might provide a <code>setText()</code> method that allows the user to change what is displayed. When text is changed the GUI system will need to update the batched GUI mesh, update the GUI element's mesh and/or update the layout position/size of the element.</p>
<p>There are three ways to notify the GUI system the element is dirty, each more expensive in performance than the previous:</p><ul>
<li><a class="el" href="classbs_1_1_g_u_i_element_base.html#ae3e6a4adfad276acd7a7ba84d512405a">GUIElement::_markMeshAsDirty()</a> - Causes the batched GUI mesh to be re-assembled. Will cause a call to <b>GUIElement::_fillBuffer()</b>. Call this if element's contents and size didn't change (e.g. when its position, or depth changes). Batched GUI mesh is a mesh managed by the GUI system that consists of multiple GUI elements sharing the same material properties (used to improve rendering performance).</li>
<li><a class="el" href="classbs_1_1_g_u_i_element_base.html#afbe57e5455efeab0691f3e7a074b3a60">GUIElement::_markContentAsDirty()</a> - Has the same effect as <b>GUIElement::_markMeshDirty()</b>, but will also trigger a <b>GUIElement::updateRenderElementsInternal()</b> call so the GUI element mesh will be fully rebuilt. Call this when contents of the GUI element change, but not its size (e.g. changing a texture but it is the same dimensions as the old one.)</li>
<li><a class="el" href="classbs_1_1_g_u_i_element_base.html#a3cada990af3da3d1898827c1e2b5fc2d">GUIElement::_markLayoutAsDirty()</a> - Has the same effect as <b>GUIElement::_markContentDirty()</b>, but will also cause the layout system to recalculate the element's position and size. This can be expensive as this will generally trigger layout updates for all siblings and children, potentially even parent GUI elements. Call this when element changes and no other dirty calls are appropriate. Normally you have to call this whenever the element's size changes.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>GUITexture : <span class="keyword">public</span> GUIElement</div><div class="line">{</div><div class="line">    <span class="comment">// ... remaining GUITexture implementation</span></div><div class="line"></div><div class="line">    <span class="comment">// Changes the look of the GUI element by fading it out when enabled</span></div><div class="line">    <span class="keywordtype">void</span> setFadeOut(<span class="keywordtype">bool</span> fadeOut)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span>(fadeOut)</div><div class="line">            mMatParams.tint = Color(1.0f, 1.0f, 1.0f, 0.5f);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            mMatParams.tint = Color::White;</div><div class="line"></div><div class="line">        <span class="comment">// Ensure the system redraws the mesh. Since neither the size or contents changed we can call the cheapest redraw method, &#39;_markMeshAsDirty()&#39;</span></div><div class="line">        _markMeshAsDirty();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Updated version of _getMaterial()</span></div><div class="line">    <span class="keyword">const</span> SpriteMaterialInfo&amp; _getMaterial(UINT32 renderElementIdx, SpriteMaterial** material)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="comment">// Get material for rendering opaque images</span></div><div class="line">        *material = SpriteManager::instance().getImageOpaqueMaterial();</div><div class="line"></div><div class="line">        <span class="comment">// Assuming remaining mMatParams contents are populated elsewhere</span></div><div class="line">        <span class="keywordflow">return</span> mMatParams;</div><div class="line">    }</div><div class="line"></div><div class="line">    SpriteMaterialInfo mMatParams;</div><div class="line">};</div></div><!-- fragment --><h1><a class="anchor" id="customGUI_c"></a>
Input</h1>
<p>In order for the GUI element to accept input from the user you can implement any or all of the following methods:</p><ul>
<li><a class="el" href="classbs_1_1_g_u_i_element.html#ae5f7c33eb616e49d7c2ca280fca6d5df">GUIElement::_mouseEvent()</a> - Triggered when the mouse moves and/or is clicked. See <a class="el" href="group___g_u_i.html#ga4af9d569c6fdedceec3f4cbc7c07d130">GUIMouseEventType</a> for a list of events. Receives <a class="el" href="classbs_1_1_g_u_i_mouse_event.html">GUIMouseEvent</a> structure as input.</li>
<li><a class="el" href="classbs_1_1_g_u_i_element.html#a268246bfd24e33e748cd21b6be1a1c3b">GUIElement::_textInputEvent()</a> - Triggered when the user inputs some text on the keyboard, while the GUI element is in focus. Receives <a class="el" href="classbs_1_1_g_u_i_text_input_event.html">GUITextInputEvent</a> structure as input.</li>
<li><a class="el" href="classbs_1_1_g_u_i_element.html#aa31369f086780a0cba4bd0c4ae7358b1">GUIElement::_virtualButtonEvent()</a> - Triggered when a certain virtual button is pressed, while the GUI element is in focus. Receives <a class="el" href="classbs_1_1_g_u_i_virtual_button_event.html">GUIVirtualButtonEvent</a> structure as input.</li>
<li><a class="el" href="classbs_1_1_g_u_i_element.html#ac6e5d291896124e50411937e162f05f0">GUIElement::_commandEvent()</a> - Triggers when some kind of a specialized event happens, like losing/gaining focus, deleting text, selecting text, forcing redraw and similar. See <a class="el" href="group___g_u_i-_internal.html#ga462413cd62d4c866900f456798f11040">GUICommandEventType</a> for an explanation of what each event type does. Receives <a class="el" href="classbs_1_1_g_u_i_command_event.html">GUICommandEvent</a> structure as input.</li>
</ul>
<p>Each of the methods should return false if other GUI elements are allowed to receive the same event. If true is returned the GUI element will consume the event and it wont be visible to others.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>GUITexture : <span class="keyword">public</span> GUIElement</div><div class="line">{</div><div class="line">    <span class="comment">// ... remaining GUITexture implementation</span></div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> _mouseEvent(<span class="keyword">const</span> GUIMouseEvent&amp; ev)</div><div class="line">    {</div><div class="line">        <span class="comment">// Fade out the texture when user mouses over the element</span></div><div class="line">        <span class="keywordflow">if</span>(ev.getType() == GUIMouseEventType::MouseOver)</div><div class="line">            setFadeOut(<span class="keyword">true</span>);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ev.getType() == GUIMouseEventType::MouseOut)</div><div class="line">            setFadeOut(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
    <!-- Footer -->
    <div class="myFooter">
		<div class="ui inverted vertical footer segment" style="border-top: 2px solid #f9500d;">
			<div class="ui container">
				<div class="ui stackable inverted divided equal height grid">
					<div class="three wide column">
						<h4 class="ui inverted header">Contact</h4>
						<div class="ui inverted link list">
							<a href="mailto:contact@bsframework.io" class="item">Contact us</a>
							<a href="https://github.com/GameFoundry/bsf/issues" target="_blank" class="item">Report an issue</a>
						</div>
					</div>
					<div class="three wide column">
						<h4 class="ui inverted header">Info</h4>
						<div class="ui inverted link list">
							<a href="https://github.com/GameFoundry/bsf" target="_blank" class="item">Contribute</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/Documentation/GitHub/roadmap.md" target="_blank" class="item">Roadmap</a>
							<a href="https://github.com/GameFoundry/bsf/blob/master/LICENSE.md" target="_blank" class="item">License</a>
						</div>
					</div>
					<div class="seven wide column">
						<h4 class="ui inverted header">Donate</h4>
						<div class="ui horizontal list">
							<div class="item"><a href="https://www.patreon.com/bsf"><img class="ui image" src="become_a_patron_button.png"></a></div>
							<div class="item"><a href="https://www.paypal.me/MarkoPintera/10" target="_blank"><img class="ui image" src="paypalDonate.png"></a></div>
						</div>
						<p style="padding-top:7px"><i>bs::f</i> is developed by Marko Pintera and contributors.</p>
					</div>
				</div>
			</div>
		</div>
	</div>
</div> <!-- Everything -->
</body>
</html>
